(set-option :auto_config false)
(set-option :smt.mbqi false)
(set-option :smt.case_split 3)
(set-option :smt.qi.eager_threshold 100.0)
(set-option :smt.delay_units true)
(set-option :smt.arith.solver 2)
(set-option :smt.arith.nl false)
(set-option :rlimit 0)

;; Prelude

;; AIR prelude

(declare-sort FuelId)
(declare-sort Fuel)
(declare-const zero Fuel)
(declare-fun succ (Fuel) Fuel)
(declare-fun fuel_bool (FuelId) Bool)
(declare-fun fuel_bool_default (FuelId) Bool)
(declare-const fuel_defaults Bool)
(axiom (=>
  fuel_defaults
  (forall ((id FuelId)) (!
    (= (fuel_bool id) (fuel_bool_default id))
    :pattern ((fuel_bool id))
))))
(declare-sort Poly)
(declare-fun I (Int) Poly)
(declare-fun B (Bool) Poly)
(declare-fun %I (Poly) Int)
(declare-fun %B (Poly) Bool)
(declare-sort Type)
(declare-const BOOL Type)
(declare-const INT Type)
(declare-const NAT Type)
(declare-fun UINT (Int) Type)
(declare-fun SINT (Int) Type)
(declare-fun has_type (Poly Type) Bool)
(declare-fun as_type (Poly Type) Poly)
(declare-fun mk_fun (Fun) Fun)
(axiom (has_type (B true) BOOL))
(axiom (has_type (B false) BOOL))
(axiom (forall ((x Poly) (t Type)) (!
   (and
    (has_type (as_type x t) t)
    (=>
     (has_type x t)
     (= x (as_type x t))
   ))
   :pattern ((as_type x t))
)))
(axiom (forall ((x Fun)) (!
   (= (mk_fun x) x)
   :pattern ((mk_fun x))
)))
(axiom (forall ((x Bool)) (!
   (= x (%B (B x)))
   :pattern ((B x))
)))
(axiom (forall ((x Int)) (!
   (= x (%I (I x)))
   :pattern ((I x))
)))
(axiom (forall ((x Poly)) (!
   (=>
    (has_type x BOOL)
    (= x (B (%B x)))
   )
   :pattern ((has_type x BOOL))
)))
(axiom (forall ((x Poly)) (!
   (=>
    (has_type x INT)
    (= x (I (%I x)))
   )
   :pattern ((has_type x INT))
)))
(axiom (forall ((x Poly)) (!
   (=>
    (has_type x NAT)
    (= x (I (%I x)))
   )
   :pattern ((has_type x NAT))
)))
(axiom (forall ((bits Int) (x Poly)) (!
   (=>
    (has_type x (UINT bits))
    (= x (I (%I x)))
   )
   :pattern ((has_type x (UINT bits)))
)))
(axiom (forall ((bits Int) (x Poly)) (!
   (=>
    (has_type x (SINT bits))
    (= x (I (%I x)))
   )
   :pattern ((has_type x (SINT bits)))
)))
(declare-const SZ Int)
(axiom (or
  (= SZ 32)
  (= SZ 64)
))
(declare-fun uHi (Int) Int)
(declare-fun iLo (Int) Int)
(declare-fun iHi (Int) Int)
(axiom (= (uHi 8) 256))
(axiom (= (uHi 16) 65536))
(axiom (= (uHi 32) 4294967296))
(axiom (= (uHi 64) 18446744073709551616))
(axiom (= (uHi 128) (+ 1 340282366920938463463374607431768211455)))
(axiom (= (iLo 8) (- 128)))
(axiom (= (iLo 16) (- 32768)))
(axiom (= (iLo 32) (- 2147483648)))
(axiom (= (iLo 64) (- 9223372036854775808)))
(axiom (= (iLo 128) (- 170141183460469231731687303715884105728)))
(axiom (= (iHi 8) 128))
(axiom (= (iHi 16) 32768))
(axiom (= (iHi 32) 2147483648))
(axiom (= (iHi 64) 9223372036854775808))
(axiom (= (iHi 128) 170141183460469231731687303715884105728))
(declare-fun nClip (Int) Int)
(declare-fun uClip (Int Int) Int)
(declare-fun iClip (Int Int) Int)
(axiom (forall ((i Int)) (!
   (and
    (<= 0 (nClip i))
    (=>
     (<= 0 i)
     (= i (nClip i))
   ))
   :pattern ((nClip i))
)))
(axiom (forall ((bits Int) (i Int)) (!
   (and
    (<= 0 (uClip bits i))
    (< (uClip bits i) (uHi bits))
    (=>
     (and
      (<= 0 i)
      (< i (uHi bits))
     )
     (= i (uClip bits i))
   ))
   :pattern ((uClip bits i))
)))
(axiom (forall ((bits Int) (i Int)) (!
   (and
    (<= (iLo bits) (iClip bits i))
    (< (iClip bits i) (iHi bits))
    (=>
     (and
      (<= (iLo bits) i)
      (< i (iHi bits))
     )
     (= i (iClip bits i))
   ))
   :pattern ((iClip bits i))
)))
(declare-fun uInv (Int Int) Bool)
(declare-fun iInv (Int Int) Bool)
(axiom (forall ((bits Int) (i Int)) (!
   (= (uInv bits i) (and
     (<= 0 i)
     (< i (uHi bits))
   ))
   :pattern ((uInv bits i))
)))
(axiom (forall ((bits Int) (i Int)) (!
   (= (iInv bits i) (and
     (<= (iLo bits) i)
     (< i (iHi bits))
   ))
   :pattern ((iInv bits i))
)))
(axiom (forall ((x Int)) (!
   (has_type (I x) INT)
   :pattern ((has_type (I x) INT))
)))
(axiom (forall ((x Int)) (!
   (=>
    (<= 0 x)
    (has_type (I x) NAT)
   )
   :pattern ((has_type (I x) NAT))
)))
(axiom (forall ((bits Int) (x Int)) (!
   (=>
    (uInv bits x)
    (has_type (I x) (UINT bits))
   )
   :pattern ((has_type (I x) (UINT bits)))
)))
(axiom (forall ((bits Int) (x Int)) (!
   (=>
    (iInv bits x)
    (has_type (I x) (SINT bits))
   )
   :pattern ((has_type (I x) (SINT bits)))
)))
(axiom (forall ((x Poly)) (!
   (=>
    (has_type x NAT)
    (<= 0 (%I x))
   )
   :pattern ((has_type x NAT))
)))
(axiom (forall ((bits Int) (x Poly)) (!
   (=>
    (has_type x (UINT bits))
    (uInv bits (%I x))
   )
   :pattern ((has_type x (UINT bits)))
)))
(axiom (forall ((bits Int) (x Poly)) (!
   (=>
    (has_type x (SINT bits))
    (iInv bits (%I x))
   )
   :pattern ((has_type x (SINT bits)))
)))
(declare-fun check_decrease_int.? (Int Int Bool) Bool)
(axiom (forall ((cur Int) (prev Int) (otherwise Bool)) (!
   (= (check_decrease_int.? cur prev otherwise) (or
     (and
      (<= 0 cur)
      (< cur prev)
     )
     (and
      (= cur prev)
      otherwise
   )))
   :pattern ((check_decrease_int.? cur prev otherwise))
)))
(declare-fun height.? (Poly) Int)
(axiom (forall ((x Poly)) (!
   (<= 0 (height.? x))
   :pattern ((height.? x))
)))
(declare-fun uintxor (Int Poly Poly) Int)
(declare-fun uintand (Int Poly Poly) Int)
(declare-fun uintor (Int Poly Poly) Int)
(declare-fun uintshr (Int Poly Poly) Int)
(declare-fun uintshl (Int Poly Poly) Int)
(declare-fun uintnot (Int Poly) Int)

;; MODULE ''
(push)

 ;; Fuel
 (axiom true)

 ;; Datatypes
 (declare-datatypes () ((tuple%0. (tuple%0./tuple%0))))
 (declare-fun TYPE%pervasive.invariant.Invariant. (Type) Type)
 (declare-fun TYPE%pervasive.invariant.LocalInvariant. (Type) Type)
 (declare-const TYPE%tuple%0. Type)
 (declare-fun Poly%tuple%0. (tuple%0.) Poly)
 (declare-fun %Poly%tuple%0. (Poly) tuple%0.)
 (axiom (forall ((x@ tuple%0.)) (!
    (= x@ (%Poly%tuple%0. (Poly%tuple%0. x@)))
    :pattern ((Poly%tuple%0. x@))
 )))
 (axiom (forall ((x@ Poly)) (!
    (=>
     (has_type x@ TYPE%tuple%0.)
     (= x@ (Poly%tuple%0. (%Poly%tuple%0. x@)))
    )
    :pattern ((has_type x@ TYPE%tuple%0.))
 )))
 (axiom (forall ((x@ tuple%0.)) (!
    (has_type (Poly%tuple%0. x@) TYPE%tuple%0.)
    :pattern ((has_type (Poly%tuple%0. x@) TYPE%tuple%0.))
 )))

 ;; Function-Decl crate::pervasive::invariant::Invariant::inv
 (declare-fun pervasive.invariant.Invariant.inv.? (Type Poly Poly) Bool)

 ;; Function-Decl crate::pervasive::invariant::Invariant::namespace
 (declare-fun pervasive.invariant.Invariant.namespace.? (Type Poly) Int)

 ;; Function-Decl crate::pervasive::invariant::LocalInvariant::inv
 (declare-fun pervasive.invariant.LocalInvariant.inv.? (Type Poly Poly) Bool)

 ;; Function-Decl crate::pervasive::invariant::LocalInvariant::namespace
 (declare-fun pervasive.invariant.LocalInvariant.namespace.? (Type Poly) Int)

 ;; Function-Def crate::main
 (check-valid
  (axiom fuel_defaults)
  (block)
 )
(pop)

;; MODULE 'memory_types'
(push)

 ;; Fuel
 (declare-const fuel%memory_types.BASE_PAGE_SIZE. FuelId)
 (axiom (distinct fuel%memory_types.BASE_PAGE_SIZE.))

 ;; Datatypes
 (declare-datatypes () ())
 (declare-fun TYPE%pervasive.invariant.Invariant. (Type) Type)
 (declare-fun TYPE%pervasive.invariant.LocalInvariant. (Type) Type)

 ;; Function-Decl crate::memory_types::BASE_PAGE_SIZE
 (declare-fun memory_types.BASE_PAGE_SIZE.? () Int)

 ;; Function-Decl crate::pervasive::invariant::Invariant::inv
 (declare-fun pervasive.invariant.Invariant.inv.? (Type Poly Poly) Bool)

 ;; Function-Decl crate::pervasive::invariant::Invariant::namespace
 (declare-fun pervasive.invariant.Invariant.namespace.? (Type Poly) Int)

 ;; Function-Decl crate::pervasive::invariant::LocalInvariant::inv
 (declare-fun pervasive.invariant.LocalInvariant.inv.? (Type Poly Poly) Bool)

 ;; Function-Decl crate::pervasive::invariant::LocalInvariant::namespace
 (declare-fun pervasive.invariant.LocalInvariant.namespace.? (Type Poly) Int)

 ;; Function-Axioms crate::memory_types::BASE_PAGE_SIZE
 (axiom (fuel_bool_default fuel%memory_types.BASE_PAGE_SIZE.))
 (axiom (=>
   (fuel_bool fuel%memory_types.BASE_PAGE_SIZE.)
   (= (memory_types.BASE_PAGE_SIZE.?) 4096)
 ))
 (axiom (<= 0 (memory_types.BASE_PAGE_SIZE.?)))

 ;; Function-Def crate::memory_types::BASE_PAGE_SIZE
 (check-valid
  (declare-const %return@ Int)
  (axiom fuel_defaults)
  (assume
   (= %return@ 4096)
 ))
(pop)

;; MODULE 'spec'
(push)

 ;; Fuel
 (declare-const fuel%pervasive.map.Map.new. FuelId)
 (declare-const fuel%pervasive.map.Map.ext_equal. FuelId)
 (declare-const fuel%pervasive.map.Map.union_prefer_right. FuelId)
 (declare-const fuel%pervasive.seq.Seq.ext_equal. FuelId)
 (declare-const fuel%pervasive.set.Set.ext_equal. FuelId)
 (declare-const fuel%pervasive.set.Set.choose. FuelId)
 (declare-const fuel%spec.strictly_decreasing. FuelId)
 (declare-const fuel%spec.Arch.inv. FuelId)
 (declare-const fuel%spec.Arch.contains_entry_size. FuelId)
 (declare-const fuel%spec.aligned. FuelId)
 (declare-const fuel%spec.overlap. FuelId)
 (declare-const fuel%spec.PageTableContents.ext_equal. FuelId)
 (declare-const fuel%spec.PageTableContents.inv. FuelId)
 (declare-const fuel%spec.PageTableContents.accepted_mapping. FuelId)
 (declare-const fuel%spec.PageTableContents.valid_mapping. FuelId)
 (declare-const fuel%spec.PageTableContents.map_frame. FuelId)
 (declare-const fuel%spec.PageTableContents.resolve. FuelId)
 (declare-const fuel%spec.PageTableContents.unmap. FuelId)
 (declare-const fuel%spec.Directory.well_formed. FuelId)
 (declare-const fuel%spec.Directory.arch_layer. FuelId)
 (declare-const fuel%spec.Directory.entry_size. FuelId)
 (declare-const fuel%spec.Directory.num_entries. FuelId)
 (declare-const fuel%spec.Directory.pages_match_entry_size. FuelId)
 (declare-const fuel%spec.Directory.directories_are_in_next_layer. FuelId)
 (declare-const fuel%spec.Directory.directories_obey_invariant. FuelId)
 (declare-const fuel%spec.Directory.directories_match_arch. FuelId)
 (declare-const fuel%spec.Directory.frames_aligned. FuelId)
 (declare-const fuel%spec.Directory.inv. FuelId)
 (declare-const fuel%spec.Directory.interp. FuelId)
 (declare-const fuel%spec.Directory.interp_aux. FuelId)
 (axiom (distinct fuel%pervasive.map.Map.new. fuel%pervasive.map.Map.ext_equal. fuel%pervasive.map.Map.union_prefer_right.
   fuel%pervasive.seq.Seq.ext_equal. fuel%pervasive.set.Set.ext_equal. fuel%pervasive.set.Set.choose.
   fuel%spec.strictly_decreasing. fuel%spec.Arch.inv. fuel%spec.Arch.contains_entry_size.
   fuel%spec.aligned. fuel%spec.overlap. fuel%spec.PageTableContents.ext_equal. fuel%spec.PageTableContents.inv.
   fuel%spec.PageTableContents.accepted_mapping. fuel%spec.PageTableContents.valid_mapping.
   fuel%spec.PageTableContents.map_frame. fuel%spec.PageTableContents.resolve. fuel%spec.PageTableContents.unmap.
   fuel%spec.Directory.well_formed. fuel%spec.Directory.arch_layer. fuel%spec.Directory.entry_size.
   fuel%spec.Directory.num_entries. fuel%spec.Directory.pages_match_entry_size. fuel%spec.Directory.directories_are_in_next_layer.
   fuel%spec.Directory.directories_obey_invariant. fuel%spec.Directory.directories_match_arch.
   fuel%spec.Directory.frames_aligned. fuel%spec.Directory.inv. fuel%spec.Directory.interp.
   fuel%spec.Directory.interp_aux.
 ))

 ;; Datatypes
 (declare-sort pervasive.map.Map<nat./spec.MemRegion.>.)
 (declare-sort pervasive.seq.Seq<nat.>.)
 (declare-sort pervasive.seq.Seq<spec.ArchLayer.>.)
 (declare-sort pervasive.seq.Seq<spec.NodeEntry.>.)
 (declare-sort pervasive.set.Set<nat.>.)
 (declare-datatypes () ((spec.MemRegion. (spec.MemRegion./MemRegion (spec.MemRegion./MemRegion/?base
      Int
     ) (spec.MemRegion./MemRegion/?size Int)
    )
   ) (spec.ArchLayer. (spec.ArchLayer./ArchLayer (spec.ArchLayer./ArchLayer/?entry_size
      Int
     ) (spec.ArchLayer./ArchLayer/?num_entries Int)
    )
   ) (spec.Arch. (spec.Arch./Arch (spec.Arch./Arch/?layers pervasive.seq.Seq<spec.ArchLayer.>.)))
   (spec.PageTableContents. (spec.PageTableContents./PageTableContents (spec.PageTableContents./PageTableContents/?map
      pervasive.map.Map<nat./spec.MemRegion.>.
     ) (spec.PageTableContents./PageTableContents/?arch spec.Arch.)
    )
   ) (spec.Directory. (spec.Directory./Directory (spec.Directory./Directory/?entries pervasive.seq.Seq<spec.NodeEntry.>.)
     (spec.Directory./Directory/?layer Int) (spec.Directory./Directory/?base_vaddr Int)
     (spec.Directory./Directory/?arch spec.Arch.)
    )
   ) (pervasive.result.Result. (pervasive.result.Result./Ok (pervasive.result.Result./Ok/?_0
      Poly
     )
    ) (pervasive.result.Result./Err (pervasive.result.Result./Err/?_0 Poly))
   ) (spec.NodeEntry. (spec.NodeEntry./Directory (spec.NodeEntry./Directory/?_0 spec.Directory.))
    (spec.NodeEntry./Page (spec.NodeEntry./Page/?_0 spec.MemRegion.)) (spec.NodeEntry./Empty)
   ) (tuple%0. (tuple%0./tuple%0)) (tuple%2. (tuple%2./tuple%2 (tuple%2./tuple%2/?field%0
      Poly
     ) (tuple%2./tuple%2/?field%1 Poly)
 ))))
 (declare-fun spec.MemRegion./MemRegion/base (spec.MemRegion.) Int)
 (declare-fun spec.MemRegion./MemRegion/size (spec.MemRegion.) Int)
 (declare-fun spec.ArchLayer./ArchLayer/entry_size (spec.ArchLayer.) Int)
 (declare-fun spec.ArchLayer./ArchLayer/num_entries (spec.ArchLayer.) Int)
 (declare-fun spec.Arch./Arch/layers (spec.Arch.) pervasive.seq.Seq<spec.ArchLayer.>.)
 (declare-fun spec.PageTableContents./PageTableContents/map (spec.PageTableContents.)
  pervasive.map.Map<nat./spec.MemRegion.>.
 )
 (declare-fun spec.PageTableContents./PageTableContents/arch (spec.PageTableContents.)
  spec.Arch.
 )
 (declare-fun spec.Directory./Directory/entries (spec.Directory.) pervasive.seq.Seq<spec.NodeEntry.>.)
 (declare-fun spec.Directory./Directory/layer (spec.Directory.) Int)
 (declare-fun spec.Directory./Directory/base_vaddr (spec.Directory.) Int)
 (declare-fun spec.Directory./Directory/arch (spec.Directory.) spec.Arch.)
 (declare-fun pervasive.result.Result./Ok/_0 (pervasive.result.Result.) Poly)
 (declare-fun pervasive.result.Result./Err/_0 (pervasive.result.Result.) Poly)
 (declare-fun spec.NodeEntry./Directory/_0 (spec.NodeEntry.) spec.Directory.)
 (declare-fun spec.NodeEntry./Page/_0 (spec.NodeEntry.) spec.MemRegion.)
 (declare-fun tuple%2./tuple%2/field%0 (tuple%2.) Poly)
 (declare-fun tuple%2./tuple%2/field%1 (tuple%2.) Poly)
 (declare-fun TYPE%fun%1. (Type Type) Type)
 (declare-fun TYPE%pervasive.map.Map. (Type Type) Type)
 (declare-fun TYPE%pervasive.seq.Seq. (Type) Type)
 (declare-fun TYPE%pervasive.set.Set. (Type) Type)
 (declare-fun TYPE%pervasive.invariant.Invariant. (Type) Type)
 (declare-fun TYPE%pervasive.invariant.LocalInvariant. (Type) Type)
 (declare-const TYPE%spec.MemRegion. Type)
 (declare-const TYPE%spec.ArchLayer. Type)
 (declare-const TYPE%spec.Arch. Type)
 (declare-const TYPE%spec.PageTableContents. Type)
 (declare-const TYPE%spec.Directory. Type)
 (declare-fun TYPE%pervasive.result.Result. (Type Type) Type)
 (declare-const TYPE%spec.NodeEntry. Type)
 (declare-const TYPE%tuple%0. Type)
 (declare-fun TYPE%tuple%2. (Type Type) Type)
 (declare-fun Poly%fun%1. (Fun) Poly)
 (declare-fun %Poly%fun%1. (Poly) Fun)
 (declare-fun Poly%pervasive.map.Map<nat./spec.MemRegion.>. (pervasive.map.Map<nat./spec.MemRegion.>.)
  Poly
 )
 (declare-fun %Poly%pervasive.map.Map<nat./spec.MemRegion.>. (Poly) pervasive.map.Map<nat./spec.MemRegion.>.)
 (declare-fun Poly%pervasive.seq.Seq<nat.>. (pervasive.seq.Seq<nat.>.) Poly)
 (declare-fun %Poly%pervasive.seq.Seq<nat.>. (Poly) pervasive.seq.Seq<nat.>.)
 (declare-fun Poly%pervasive.seq.Seq<spec.ArchLayer.>. (pervasive.seq.Seq<spec.ArchLayer.>.)
  Poly
 )
 (declare-fun %Poly%pervasive.seq.Seq<spec.ArchLayer.>. (Poly) pervasive.seq.Seq<spec.ArchLayer.>.)
 (declare-fun Poly%pervasive.seq.Seq<spec.NodeEntry.>. (pervasive.seq.Seq<spec.NodeEntry.>.)
  Poly
 )
 (declare-fun %Poly%pervasive.seq.Seq<spec.NodeEntry.>. (Poly) pervasive.seq.Seq<spec.NodeEntry.>.)
 (declare-fun Poly%pervasive.set.Set<nat.>. (pervasive.set.Set<nat.>.) Poly)
 (declare-fun %Poly%pervasive.set.Set<nat.>. (Poly) pervasive.set.Set<nat.>.)
 (declare-fun Poly%spec.MemRegion. (spec.MemRegion.) Poly)
 (declare-fun %Poly%spec.MemRegion. (Poly) spec.MemRegion.)
 (declare-fun Poly%spec.ArchLayer. (spec.ArchLayer.) Poly)
 (declare-fun %Poly%spec.ArchLayer. (Poly) spec.ArchLayer.)
 (declare-fun Poly%spec.Arch. (spec.Arch.) Poly)
 (declare-fun %Poly%spec.Arch. (Poly) spec.Arch.)
 (declare-fun Poly%spec.PageTableContents. (spec.PageTableContents.) Poly)
 (declare-fun %Poly%spec.PageTableContents. (Poly) spec.PageTableContents.)
 (declare-fun Poly%spec.Directory. (spec.Directory.) Poly)
 (declare-fun %Poly%spec.Directory. (Poly) spec.Directory.)
 (declare-fun Poly%pervasive.result.Result. (pervasive.result.Result.) Poly)
 (declare-fun %Poly%pervasive.result.Result. (Poly) pervasive.result.Result.)
 (declare-fun Poly%spec.NodeEntry. (spec.NodeEntry.) Poly)
 (declare-fun %Poly%spec.NodeEntry. (Poly) spec.NodeEntry.)
 (declare-fun Poly%tuple%0. (tuple%0.) Poly)
 (declare-fun %Poly%tuple%0. (Poly) tuple%0.)
 (declare-fun Poly%tuple%2. (tuple%2.) Poly)
 (declare-fun %Poly%tuple%2. (Poly) tuple%2.)
 (axiom (forall ((x@ Fun)) (!
    (= x@ (%Poly%fun%1. (Poly%fun%1. x@)))
    :pattern ((Poly%fun%1. x@))
 )))
 (axiom (forall ((T%0& Type) (T%1& Type) (x@ Poly)) (!
    (=>
     (has_type x@ (TYPE%fun%1. T%0& T%1&))
     (= x@ (Poly%fun%1. (%Poly%fun%1. x@)))
    )
    :pattern ((has_type x@ (TYPE%fun%1. T%0& T%1&)))
 )))
 (axiom (forall ((T%0& Type) (T%1& Type) (x@ Fun)) (!
    (=>
     (forall ((T%0@ Poly)) (!
       (=>
        (has_type T%0@ T%0&)
        (has_type (apply Poly x@ T%0@) T%1&)
       )
       :pattern ((has_type (apply Poly x@ T%0@) T%1&))
     ))
     (has_type (Poly%fun%1. (mk_fun x@)) (TYPE%fun%1. T%0& T%1&))
    )
    :pattern ((has_type (Poly%fun%1. (mk_fun x@)) (TYPE%fun%1. T%0& T%1&)))
 )))
 (axiom (forall ((T%0& Type) (T%1& Type) (T%0@ Poly) (x@ Fun)) (!
    (=>
     (and
      (has_type (Poly%fun%1. x@) (TYPE%fun%1. T%0& T%1&))
      (has_type T%0@ T%0&)
     )
     (has_type (apply Poly x@ T%0@) T%1&)
    )
    :pattern ((apply Poly x@ T%0@) (has_type (Poly%fun%1. x@) (TYPE%fun%1. T%0& T%1&)))
 )))
 (axiom (forall ((x@ pervasive.map.Map<nat./spec.MemRegion.>.)) (!
    (= x@ (%Poly%pervasive.map.Map<nat./spec.MemRegion.>. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
       x@
    )))
    :pattern ((Poly%pervasive.map.Map<nat./spec.MemRegion.>. x@))
 )))
 (axiom (forall ((x@ Poly)) (!
    (=>
     (has_type x@ (TYPE%pervasive.map.Map. NAT TYPE%spec.MemRegion.))
     (= x@ (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (%Poly%pervasive.map.Map<nat./spec.MemRegion.>.
        x@
    ))))
    :pattern ((has_type x@ (TYPE%pervasive.map.Map. NAT TYPE%spec.MemRegion.)))
 )))
 (axiom (forall ((x@ pervasive.map.Map<nat./spec.MemRegion.>.)) (!
    (has_type (Poly%pervasive.map.Map<nat./spec.MemRegion.>. x@) (TYPE%pervasive.map.Map.
      NAT TYPE%spec.MemRegion.
    ))
    :pattern ((has_type (Poly%pervasive.map.Map<nat./spec.MemRegion.>. x@) (TYPE%pervasive.map.Map.
       NAT TYPE%spec.MemRegion.
 ))))))
 (axiom (forall ((x@ pervasive.seq.Seq<nat.>.)) (!
    (= x@ (%Poly%pervasive.seq.Seq<nat.>. (Poly%pervasive.seq.Seq<nat.>. x@)))
    :pattern ((Poly%pervasive.seq.Seq<nat.>. x@))
 )))
 (axiom (forall ((x@ Poly)) (!
    (=>
     (has_type x@ (TYPE%pervasive.seq.Seq. NAT))
     (= x@ (Poly%pervasive.seq.Seq<nat.>. (%Poly%pervasive.seq.Seq<nat.>. x@)))
    )
    :pattern ((has_type x@ (TYPE%pervasive.seq.Seq. NAT)))
 )))
 (axiom (forall ((x@ pervasive.seq.Seq<nat.>.)) (!
    (has_type (Poly%pervasive.seq.Seq<nat.>. x@) (TYPE%pervasive.seq.Seq. NAT))
    :pattern ((has_type (Poly%pervasive.seq.Seq<nat.>. x@) (TYPE%pervasive.seq.Seq. NAT)))
 )))
 (axiom (forall ((x@ pervasive.seq.Seq<spec.ArchLayer.>.)) (!
    (= x@ (%Poly%pervasive.seq.Seq<spec.ArchLayer.>. (Poly%pervasive.seq.Seq<spec.ArchLayer.>.
       x@
    )))
    :pattern ((Poly%pervasive.seq.Seq<spec.ArchLayer.>. x@))
 )))
 (axiom (forall ((x@ Poly)) (!
    (=>
     (has_type x@ (TYPE%pervasive.seq.Seq. TYPE%spec.ArchLayer.))
     (= x@ (Poly%pervasive.seq.Seq<spec.ArchLayer.>. (%Poly%pervasive.seq.Seq<spec.ArchLayer.>.
        x@
    ))))
    :pattern ((has_type x@ (TYPE%pervasive.seq.Seq. TYPE%spec.ArchLayer.)))
 )))
 (axiom (forall ((x@ pervasive.seq.Seq<spec.ArchLayer.>.)) (!
    (has_type (Poly%pervasive.seq.Seq<spec.ArchLayer.>. x@) (TYPE%pervasive.seq.Seq. TYPE%spec.ArchLayer.))
    :pattern ((has_type (Poly%pervasive.seq.Seq<spec.ArchLayer.>. x@) (TYPE%pervasive.seq.Seq.
       TYPE%spec.ArchLayer.
 ))))))
 (axiom (forall ((x@ pervasive.seq.Seq<spec.NodeEntry.>.)) (!
    (= x@ (%Poly%pervasive.seq.Seq<spec.NodeEntry.>. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
       x@
    )))
    :pattern ((Poly%pervasive.seq.Seq<spec.NodeEntry.>. x@))
 )))
 (axiom (forall ((x@ Poly)) (!
    (=>
     (has_type x@ (TYPE%pervasive.seq.Seq. TYPE%spec.NodeEntry.))
     (= x@ (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (%Poly%pervasive.seq.Seq<spec.NodeEntry.>.
        x@
    ))))
    :pattern ((has_type x@ (TYPE%pervasive.seq.Seq. TYPE%spec.NodeEntry.)))
 )))
 (axiom (forall ((x@ pervasive.seq.Seq<spec.NodeEntry.>.)) (!
    (has_type (Poly%pervasive.seq.Seq<spec.NodeEntry.>. x@) (TYPE%pervasive.seq.Seq. TYPE%spec.NodeEntry.))
    :pattern ((has_type (Poly%pervasive.seq.Seq<spec.NodeEntry.>. x@) (TYPE%pervasive.seq.Seq.
       TYPE%spec.NodeEntry.
 ))))))
 (axiom (forall ((x@ pervasive.set.Set<nat.>.)) (!
    (= x@ (%Poly%pervasive.set.Set<nat.>. (Poly%pervasive.set.Set<nat.>. x@)))
    :pattern ((Poly%pervasive.set.Set<nat.>. x@))
 )))
 (axiom (forall ((x@ Poly)) (!
    (=>
     (has_type x@ (TYPE%pervasive.set.Set. NAT))
     (= x@ (Poly%pervasive.set.Set<nat.>. (%Poly%pervasive.set.Set<nat.>. x@)))
    )
    :pattern ((has_type x@ (TYPE%pervasive.set.Set. NAT)))
 )))
 (axiom (forall ((x@ pervasive.set.Set<nat.>.)) (!
    (has_type (Poly%pervasive.set.Set<nat.>. x@) (TYPE%pervasive.set.Set. NAT))
    :pattern ((has_type (Poly%pervasive.set.Set<nat.>. x@) (TYPE%pervasive.set.Set. NAT)))
 )))
 (axiom (forall ((x@ spec.MemRegion.)) (!
    (= x@ (%Poly%spec.MemRegion. (Poly%spec.MemRegion. x@)))
    :pattern ((Poly%spec.MemRegion. x@))
 )))
 (axiom (forall ((x@ Poly)) (!
    (=>
     (has_type x@ TYPE%spec.MemRegion.)
     (= x@ (Poly%spec.MemRegion. (%Poly%spec.MemRegion. x@)))
    )
    :pattern ((has_type x@ TYPE%spec.MemRegion.))
 )))
 (axiom (forall ((base@ Int) (size@ Int)) (!
    (=>
     (and
      (<= 0 base@)
      (<= 0 size@)
     )
     (has_type (Poly%spec.MemRegion. (spec.MemRegion./MemRegion base@ size@)) TYPE%spec.MemRegion.)
    )
    :pattern ((has_type (Poly%spec.MemRegion. (spec.MemRegion./MemRegion base@ size@))
      TYPE%spec.MemRegion.
 )))))
 (axiom (forall ((x@ spec.MemRegion.)) (!
    (= (spec.MemRegion./MemRegion/base x@) (spec.MemRegion./MemRegion/?base x@))
    :pattern ((spec.MemRegion./MemRegion/base x@))
 )))
 (axiom (forall ((x@ Poly)) (!
    (=>
     (has_type x@ TYPE%spec.MemRegion.)
     (<= 0 (spec.MemRegion./MemRegion/base (%Poly%spec.MemRegion. x@)))
    )
    :pattern ((spec.MemRegion./MemRegion/base (%Poly%spec.MemRegion. x@)) (has_type x@
      TYPE%spec.MemRegion.
 )))))
 (axiom (forall ((x@ spec.MemRegion.)) (!
    (= (spec.MemRegion./MemRegion/size x@) (spec.MemRegion./MemRegion/?size x@))
    :pattern ((spec.MemRegion./MemRegion/size x@))
 )))
 (axiom (forall ((x@ Poly)) (!
    (=>
     (has_type x@ TYPE%spec.MemRegion.)
     (<= 0 (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. x@)))
    )
    :pattern ((spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. x@)) (has_type x@
      TYPE%spec.MemRegion.
 )))))
 (axiom (forall ((x@ spec.ArchLayer.)) (!
    (= x@ (%Poly%spec.ArchLayer. (Poly%spec.ArchLayer. x@)))
    :pattern ((Poly%spec.ArchLayer. x@))
 )))
 (axiom (forall ((x@ Poly)) (!
    (=>
     (has_type x@ TYPE%spec.ArchLayer.)
     (= x@ (Poly%spec.ArchLayer. (%Poly%spec.ArchLayer. x@)))
    )
    :pattern ((has_type x@ TYPE%spec.ArchLayer.))
 )))
 (axiom (forall ((entry_size@ Int) (num_entries@ Int)) (!
    (=>
     (and
      (<= 0 entry_size@)
      (<= 0 num_entries@)
     )
     (has_type (Poly%spec.ArchLayer. (spec.ArchLayer./ArchLayer entry_size@ num_entries@))
      TYPE%spec.ArchLayer.
    ))
    :pattern ((has_type (Poly%spec.ArchLayer. (spec.ArchLayer./ArchLayer entry_size@ num_entries@))
      TYPE%spec.ArchLayer.
 )))))
 (axiom (forall ((x@ spec.ArchLayer.)) (!
    (= (spec.ArchLayer./ArchLayer/entry_size x@) (spec.ArchLayer./ArchLayer/?entry_size
      x@
    ))
    :pattern ((spec.ArchLayer./ArchLayer/entry_size x@))
 )))
 (axiom (forall ((x@ Poly)) (!
    (=>
     (has_type x@ TYPE%spec.ArchLayer.)
     (<= 0 (spec.ArchLayer./ArchLayer/entry_size (%Poly%spec.ArchLayer. x@)))
    )
    :pattern ((spec.ArchLayer./ArchLayer/entry_size (%Poly%spec.ArchLayer. x@)) (has_type
      x@ TYPE%spec.ArchLayer.
 )))))
 (axiom (forall ((x@ spec.ArchLayer.)) (!
    (= (spec.ArchLayer./ArchLayer/num_entries x@) (spec.ArchLayer./ArchLayer/?num_entries
      x@
    ))
    :pattern ((spec.ArchLayer./ArchLayer/num_entries x@))
 )))
 (axiom (forall ((x@ Poly)) (!
    (=>
     (has_type x@ TYPE%spec.ArchLayer.)
     (<= 0 (spec.ArchLayer./ArchLayer/num_entries (%Poly%spec.ArchLayer. x@)))
    )
    :pattern ((spec.ArchLayer./ArchLayer/num_entries (%Poly%spec.ArchLayer. x@)) (has_type
      x@ TYPE%spec.ArchLayer.
 )))))
 (axiom (forall ((x@ spec.Arch.)) (!
    (= x@ (%Poly%spec.Arch. (Poly%spec.Arch. x@)))
    :pattern ((Poly%spec.Arch. x@))
 )))
 (axiom (forall ((x@ Poly)) (!
    (=>
     (has_type x@ TYPE%spec.Arch.)
     (= x@ (Poly%spec.Arch. (%Poly%spec.Arch. x@)))
    )
    :pattern ((has_type x@ TYPE%spec.Arch.))
 )))
 (axiom (forall ((x@ spec.Arch.)) (!
    (= (spec.Arch./Arch/layers x@) (spec.Arch./Arch/?layers x@))
    :pattern ((spec.Arch./Arch/layers x@))
 )))
 (axiom (forall ((x@ spec.Arch.)) (!
    (has_type (Poly%spec.Arch. x@) TYPE%spec.Arch.)
    :pattern ((has_type (Poly%spec.Arch. x@) TYPE%spec.Arch.))
 )))
 (axiom (forall ((x@ spec.PageTableContents.)) (!
    (= x@ (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. x@)))
    :pattern ((Poly%spec.PageTableContents. x@))
 )))
 (axiom (forall ((x@ Poly)) (!
    (=>
     (has_type x@ TYPE%spec.PageTableContents.)
     (= x@ (Poly%spec.PageTableContents. (%Poly%spec.PageTableContents. x@)))
    )
    :pattern ((has_type x@ TYPE%spec.PageTableContents.))
 )))
 (axiom (forall ((x@ spec.PageTableContents.)) (!
    (= (spec.PageTableContents./PageTableContents/map x@) (spec.PageTableContents./PageTableContents/?map
      x@
    ))
    :pattern ((spec.PageTableContents./PageTableContents/map x@))
 )))
 (axiom (forall ((x@ spec.PageTableContents.)) (!
    (= (spec.PageTableContents./PageTableContents/arch x@) (spec.PageTableContents./PageTableContents/?arch
      x@
    ))
    :pattern ((spec.PageTableContents./PageTableContents/arch x@))
 )))
 (axiom (forall ((x@ spec.PageTableContents.)) (!
    (has_type (Poly%spec.PageTableContents. x@) TYPE%spec.PageTableContents.)
    :pattern ((has_type (Poly%spec.PageTableContents. x@) TYPE%spec.PageTableContents.))
 )))
 (axiom (forall ((x spec.PageTableContents.)) (!
    (< (height.? (Poly%spec.Arch. (spec.PageTableContents./PageTableContents/arch x)))
     (height.? (Poly%spec.PageTableContents. x))
    )
    :pattern ((height.? (Poly%spec.Arch. (spec.PageTableContents./PageTableContents/arch
        x
 )))))))
 (axiom (forall ((x@ spec.Directory.)) (!
    (= x@ (%Poly%spec.Directory. (Poly%spec.Directory. x@)))
    :pattern ((Poly%spec.Directory. x@))
 )))
 (axiom (forall ((x@ Poly)) (!
    (=>
     (has_type x@ TYPE%spec.Directory.)
     (= x@ (Poly%spec.Directory. (%Poly%spec.Directory. x@)))
    )
    :pattern ((has_type x@ TYPE%spec.Directory.))
 )))
 (axiom (forall ((entries@ pervasive.seq.Seq<spec.NodeEntry.>.) (layer@ Int) (base_vaddr@
     Int
    ) (arch@ spec.Arch.)
   ) (!
    (=>
     (and
      (<= 0 layer@)
      (<= 0 base_vaddr@)
     )
     (has_type (Poly%spec.Directory. (spec.Directory./Directory entries@ layer@ base_vaddr@
        arch@
       )
      ) TYPE%spec.Directory.
    ))
    :pattern ((has_type (Poly%spec.Directory. (spec.Directory./Directory entries@ layer@
        base_vaddr@ arch@
       )
      ) TYPE%spec.Directory.
 )))))
 (axiom (forall ((x@ spec.Directory.)) (!
    (= (spec.Directory./Directory/entries x@) (spec.Directory./Directory/?entries x@))
    :pattern ((spec.Directory./Directory/entries x@))
 )))
 (axiom (forall ((x@ spec.Directory.)) (!
    (= (spec.Directory./Directory/layer x@) (spec.Directory./Directory/?layer x@))
    :pattern ((spec.Directory./Directory/layer x@))
 )))
 (axiom (forall ((x@ Poly)) (!
    (=>
     (has_type x@ TYPE%spec.Directory.)
     (<= 0 (spec.Directory./Directory/layer (%Poly%spec.Directory. x@)))
    )
    :pattern ((spec.Directory./Directory/layer (%Poly%spec.Directory. x@)) (has_type x@
      TYPE%spec.Directory.
 )))))
 (axiom (forall ((x@ spec.Directory.)) (!
    (= (spec.Directory./Directory/base_vaddr x@) (spec.Directory./Directory/?base_vaddr
      x@
    ))
    :pattern ((spec.Directory./Directory/base_vaddr x@))
 )))
 (axiom (forall ((x@ Poly)) (!
    (=>
     (has_type x@ TYPE%spec.Directory.)
     (<= 0 (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. x@)))
    )
    :pattern ((spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. x@)) (has_type
      x@ TYPE%spec.Directory.
 )))))
 (axiom (forall ((x@ spec.Directory.)) (!
    (= (spec.Directory./Directory/arch x@) (spec.Directory./Directory/?arch x@))
    :pattern ((spec.Directory./Directory/arch x@))
 )))
 (axiom (forall ((x spec.Directory.)) (!
    (< (height.? (Poly%spec.Arch. (spec.Directory./Directory/arch x))) (height.? (Poly%spec.Directory.
       x
    )))
    :pattern ((height.? (Poly%spec.Arch. (spec.Directory./Directory/arch x))))
 )))
 (axiom (forall ((x@ pervasive.result.Result.)) (!
    (= x@ (%Poly%pervasive.result.Result. (Poly%pervasive.result.Result. x@)))
    :pattern ((Poly%pervasive.result.Result. x@))
 )))
 (axiom (forall ((T& Type) (E& Type) (x@ Poly)) (!
    (=>
     (has_type x@ (TYPE%pervasive.result.Result. T& E&))
     (= x@ (Poly%pervasive.result.Result. (%Poly%pervasive.result.Result. x@)))
    )
    :pattern ((has_type x@ (TYPE%pervasive.result.Result. T& E&)))
 )))
 (axiom (forall ((T& Type) (E& Type) (_0@ Poly)) (!
    (=>
     (has_type _0@ T&)
     (has_type (Poly%pervasive.result.Result. (pervasive.result.Result./Ok _0@)) (TYPE%pervasive.result.Result.
       T& E&
    )))
    :pattern ((has_type (Poly%pervasive.result.Result. (pervasive.result.Result./Ok _0@))
      (TYPE%pervasive.result.Result. T& E&)
 )))))
 (axiom (forall ((x@ pervasive.result.Result.)) (!
    (= (pervasive.result.Result./Ok/_0 x@) (pervasive.result.Result./Ok/?_0 x@))
    :pattern ((pervasive.result.Result./Ok/_0 x@))
 )))
 (axiom (forall ((T& Type) (E& Type) (x@ Poly)) (!
    (=>
     (has_type x@ (TYPE%pervasive.result.Result. T& E&))
     (has_type (pervasive.result.Result./Ok/_0 (%Poly%pervasive.result.Result. x@)) T&)
    )
    :pattern ((pervasive.result.Result./Ok/_0 (%Poly%pervasive.result.Result. x@)) (has_type
      x@ (TYPE%pervasive.result.Result. T& E&)
 )))))
 (axiom (forall ((T& Type) (E& Type) (_0@ Poly)) (!
    (=>
     (has_type _0@ E&)
     (has_type (Poly%pervasive.result.Result. (pervasive.result.Result./Err _0@)) (TYPE%pervasive.result.Result.
       T& E&
    )))
    :pattern ((has_type (Poly%pervasive.result.Result. (pervasive.result.Result./Err _0@))
      (TYPE%pervasive.result.Result. T& E&)
 )))))
 (axiom (forall ((x@ pervasive.result.Result.)) (!
    (= (pervasive.result.Result./Err/_0 x@) (pervasive.result.Result./Err/?_0 x@))
    :pattern ((pervasive.result.Result./Err/_0 x@))
 )))
 (axiom (forall ((T& Type) (E& Type) (x@ Poly)) (!
    (=>
     (has_type x@ (TYPE%pervasive.result.Result. T& E&))
     (has_type (pervasive.result.Result./Err/_0 (%Poly%pervasive.result.Result. x@)) E&)
    )
    :pattern ((pervasive.result.Result./Err/_0 (%Poly%pervasive.result.Result. x@)) (has_type
      x@ (TYPE%pervasive.result.Result. T& E&)
 )))))
 (axiom (forall ((x@ spec.NodeEntry.)) (!
    (= x@ (%Poly%spec.NodeEntry. (Poly%spec.NodeEntry. x@)))
    :pattern ((Poly%spec.NodeEntry. x@))
 )))
 (axiom (forall ((x@ Poly)) (!
    (=>
     (has_type x@ TYPE%spec.NodeEntry.)
     (= x@ (Poly%spec.NodeEntry. (%Poly%spec.NodeEntry. x@)))
    )
    :pattern ((has_type x@ TYPE%spec.NodeEntry.))
 )))
 (axiom (forall ((_0@ spec.Directory.)) (!
    (=>
     (has_type (Poly%spec.Directory. _0@) TYPE%spec.Directory.)
     (has_type (Poly%spec.NodeEntry. (spec.NodeEntry./Directory _0@)) TYPE%spec.NodeEntry.)
    )
    :pattern ((has_type (Poly%spec.NodeEntry. (spec.NodeEntry./Directory _0@)) TYPE%spec.NodeEntry.))
 )))
 (axiom (forall ((x@ spec.NodeEntry.)) (!
    (= (spec.NodeEntry./Directory/_0 x@) (spec.NodeEntry./Directory/?_0 x@))
    :pattern ((spec.NodeEntry./Directory/_0 x@))
 )))
 (axiom (forall ((x@ Poly)) (!
    (=>
     (has_type x@ TYPE%spec.NodeEntry.)
     (has_type (Poly%spec.Directory. (spec.NodeEntry./Directory/_0 (%Poly%spec.NodeEntry.
         x@
       ))
      ) TYPE%spec.Directory.
    ))
    :pattern ((spec.NodeEntry./Directory/_0 (%Poly%spec.NodeEntry. x@)) (has_type x@ TYPE%spec.NodeEntry.))
 )))
 (axiom (forall ((_0@ spec.MemRegion.)) (!
    (=>
     (has_type (Poly%spec.MemRegion. _0@) TYPE%spec.MemRegion.)
     (has_type (Poly%spec.NodeEntry. (spec.NodeEntry./Page _0@)) TYPE%spec.NodeEntry.)
    )
    :pattern ((has_type (Poly%spec.NodeEntry. (spec.NodeEntry./Page _0@)) TYPE%spec.NodeEntry.))
 )))
 (axiom (forall ((x@ spec.NodeEntry.)) (!
    (= (spec.NodeEntry./Page/_0 x@) (spec.NodeEntry./Page/?_0 x@))
    :pattern ((spec.NodeEntry./Page/_0 x@))
 )))
 (axiom (forall ((x@ Poly)) (!
    (=>
     (has_type x@ TYPE%spec.NodeEntry.)
     (has_type (Poly%spec.MemRegion. (spec.NodeEntry./Page/_0 (%Poly%spec.NodeEntry. x@)))
      TYPE%spec.MemRegion.
    ))
    :pattern ((spec.NodeEntry./Page/_0 (%Poly%spec.NodeEntry. x@)) (has_type x@ TYPE%spec.NodeEntry.))
 )))
 (axiom (has_type (Poly%spec.NodeEntry. (spec.NodeEntry./Empty)) TYPE%spec.NodeEntry.))
 (axiom (forall ((x spec.NodeEntry.)) (!
    (< (height.? (Poly%spec.Directory. (spec.NodeEntry./Directory/_0 x))) (height.? (Poly%spec.NodeEntry.
       x
    )))
    :pattern ((height.? (Poly%spec.Directory. (spec.NodeEntry./Directory/_0 x))))
 )))
 (axiom (forall ((x spec.NodeEntry.)) (!
    (< (height.? (Poly%spec.MemRegion. (spec.NodeEntry./Page/_0 x))) (height.? (Poly%spec.NodeEntry.
       x
    )))
    :pattern ((height.? (Poly%spec.MemRegion. (spec.NodeEntry./Page/_0 x))))
 )))
 (axiom (forall ((x@ tuple%0.)) (!
    (= x@ (%Poly%tuple%0. (Poly%tuple%0. x@)))
    :pattern ((Poly%tuple%0. x@))
 )))
 (axiom (forall ((x@ Poly)) (!
    (=>
     (has_type x@ TYPE%tuple%0.)
     (= x@ (Poly%tuple%0. (%Poly%tuple%0. x@)))
    )
    :pattern ((has_type x@ TYPE%tuple%0.))
 )))
 (axiom (forall ((x@ tuple%0.)) (!
    (has_type (Poly%tuple%0. x@) TYPE%tuple%0.)
    :pattern ((has_type (Poly%tuple%0. x@) TYPE%tuple%0.))
 )))
 (axiom (forall ((x@ tuple%2.)) (!
    (= x@ (%Poly%tuple%2. (Poly%tuple%2. x@)))
    :pattern ((Poly%tuple%2. x@))
 )))
 (axiom (forall ((T%0& Type) (T%1& Type) (x@ Poly)) (!
    (=>
     (has_type x@ (TYPE%tuple%2. T%0& T%1&))
     (= x@ (Poly%tuple%2. (%Poly%tuple%2. x@)))
    )
    :pattern ((has_type x@ (TYPE%tuple%2. T%0& T%1&)))
 )))
 (axiom (forall ((T%0& Type) (T%1& Type) (field%0@ Poly) (field%1@ Poly)) (!
    (=>
     (and
      (has_type field%0@ T%0&)
      (has_type field%1@ T%1&)
     )
     (has_type (Poly%tuple%2. (tuple%2./tuple%2 field%0@ field%1@)) (TYPE%tuple%2. T%0&
       T%1&
    )))
    :pattern ((has_type (Poly%tuple%2. (tuple%2./tuple%2 field%0@ field%1@)) (TYPE%tuple%2.
       T%0& T%1&
 ))))))
 (axiom (forall ((x@ tuple%2.)) (!
    (= (tuple%2./tuple%2/field%0 x@) (tuple%2./tuple%2/?field%0 x@))
    :pattern ((tuple%2./tuple%2/field%0 x@))
 )))
 (axiom (forall ((T%0& Type) (T%1& Type) (x@ Poly)) (!
    (=>
     (has_type x@ (TYPE%tuple%2. T%0& T%1&))
     (has_type (tuple%2./tuple%2/field%0 (%Poly%tuple%2. x@)) T%0&)
    )
    :pattern ((tuple%2./tuple%2/field%0 (%Poly%tuple%2. x@)) (has_type x@ (TYPE%tuple%2.
       T%0& T%1&
 ))))))
 (axiom (forall ((x@ tuple%2.)) (!
    (= (tuple%2./tuple%2/field%1 x@) (tuple%2./tuple%2/?field%1 x@))
    :pattern ((tuple%2./tuple%2/field%1 x@))
 )))
 (axiom (forall ((T%0& Type) (T%1& Type) (x@ Poly)) (!
    (=>
     (has_type x@ (TYPE%tuple%2. T%0& T%1&))
     (has_type (tuple%2./tuple%2/field%1 (%Poly%tuple%2. x@)) T%1&)
    )
    :pattern ((tuple%2./tuple%2/field%1 (%Poly%tuple%2. x@)) (has_type x@ (TYPE%tuple%2.
       T%0& T%1&
 ))))))

 ;; Function-Decl crate::pervasive::map::Map::empty
 (declare-fun pervasive.map.Map.empty.? (Type Type) Poly)

 ;; Function-Decl crate::pervasive::map::Map::new
 (declare-fun pervasive.map.Map.new.? (Type Type Poly Poly) Poly)

 ;; Function-Decl crate::pervasive::map::Map::dom
 (declare-fun pervasive.map.Map.dom.? (Type Type Poly) Poly)

 ;; Function-Decl crate::pervasive::map::Map::index
 (declare-fun pervasive.map.Map.index.? (Type Type Poly Poly) Poly)

 ;; Function-Decl crate::pervasive::map::Map::insert
 (declare-fun pervasive.map.Map.insert.? (Type Type Poly Poly Poly) Poly)

 ;; Function-Decl crate::pervasive::map::Map::remove
 (declare-fun pervasive.map.Map.remove.? (Type Type Poly Poly) Poly)

 ;; Function-Decl crate::pervasive::map::Map::ext_equal
 (declare-fun pervasive.map.Map.ext_equal.? (Type Type Poly Poly) Bool)

 ;; Function-Decl crate::pervasive::map::Map::union_prefer_right
 (declare-fun pervasive.map.Map.union_prefer_right.? (Type Type Poly Poly) Poly)

 ;; Function-Decl crate::pervasive::seq::Seq::empty
 (declare-fun pervasive.seq.Seq.empty.? (Type) Poly)

 ;; Function-Decl crate::pervasive::seq::Seq::new
 (declare-fun pervasive.seq.Seq.new.? (Type Poly Poly) Poly)

 ;; Function-Decl crate::pervasive::seq::Seq::len
 (declare-fun pervasive.seq.Seq.len.? (Type Poly) Int)

 ;; Function-Decl crate::pervasive::seq::Seq::index
 (declare-fun pervasive.seq.Seq.index.? (Type Poly Poly) Poly)

 ;; Function-Decl crate::pervasive::seq::Seq::push
 (declare-fun pervasive.seq.Seq.push.? (Type Poly Poly) Poly)

 ;; Function-Decl crate::pervasive::seq::Seq::update
 (declare-fun pervasive.seq.Seq.update.? (Type Poly Poly Poly) Poly)

 ;; Function-Decl crate::pervasive::seq::Seq::ext_equal
 (declare-fun pervasive.seq.Seq.ext_equal.? (Type Poly Poly) Bool)

 ;; Function-Decl crate::pervasive::seq::Seq::subrange
 (declare-fun pervasive.seq.Seq.subrange.? (Type Poly Poly Poly) Poly)

 ;; Function-Decl crate::pervasive::seq::Seq::add
 (declare-fun pervasive.seq.Seq.add.? (Type Poly Poly) Poly)

 ;; Function-Decl crate::pervasive::set::Set::empty
 (declare-fun pervasive.set.Set.empty.? (Type) Poly)

 ;; Function-Decl crate::pervasive::set::Set::new
 (declare-fun pervasive.set.Set.new.? (Type Poly) Poly)

 ;; Function-Decl crate::pervasive::set::Set::contains
 (declare-fun pervasive.set.Set.contains.? (Type Poly Poly) Bool)

 ;; Function-Decl crate::pervasive::set::Set::ext_equal
 (declare-fun pervasive.set.Set.ext_equal.? (Type Poly Poly) Bool)

 ;; Function-Decl crate::pervasive::set::Set::insert
 (declare-fun pervasive.set.Set.insert.? (Type Poly Poly) Poly)

 ;; Function-Decl crate::pervasive::set::Set::remove
 (declare-fun pervasive.set.Set.remove.? (Type Poly Poly) Poly)

 ;; Function-Decl crate::pervasive::set::Set::union
 (declare-fun pervasive.set.Set.union.? (Type Poly Poly) Poly)

 ;; Function-Decl crate::pervasive::set::Set::intersect
 (declare-fun pervasive.set.Set.intersect.? (Type Poly Poly) Poly)

 ;; Function-Decl crate::pervasive::set::Set::difference
 (declare-fun pervasive.set.Set.difference.? (Type Poly Poly) Poly)

 ;; Function-Decl crate::pervasive::set::Set::complement
 (declare-fun pervasive.set.Set.complement.? (Type Poly) Poly)

 ;; Function-Decl crate::pervasive::set::Set::finite
 (declare-fun pervasive.set.Set.finite.? (Type Poly) Bool)

 ;; Function-Decl crate::pervasive::set::Set::len
 (declare-fun pervasive.set.Set.len.? (Type Poly) Int)

 ;; Function-Decl crate::pervasive::set::Set::choose
 (declare-fun pervasive.set.Set.choose.? (Type Poly) Poly)

 ;; Function-Decl crate::pervasive::set::Set::mk_map
 (declare-fun pervasive.set.Set.mk_map.? (Type Type Poly Poly) Poly)

 ;; Function-Decl crate::pervasive::arbitrary
 (declare-fun pervasive.arbitrary.? (Type) Poly)

 ;; Function-Decl crate::spec::strictly_decreasing
 (declare-fun spec.strictly_decreasing.? (Poly) Bool)

 ;; Function-Decl crate::spec::Arch::inv
 (declare-fun spec.Arch.inv.? (Poly) Bool)

 ;; Function-Decl crate::spec::Arch::contains_entry_size
 (declare-fun spec.Arch.contains_entry_size.? (Poly Poly) Bool)

 ;; Function-Decl crate::spec::aligned
 (declare-fun spec.aligned.? (Poly Poly) Bool)

 ;; Function-Decl crate::spec::overlap
 (declare-fun spec.overlap.? (Poly Poly) Bool)

 ;; Function-Decl crate::spec::PageTableContents::ext_equal
 (declare-fun spec.PageTableContents.ext_equal.? (Poly Poly) Bool)

 ;; Function-Decl crate::spec::PageTableContents::inv
 (declare-fun spec.PageTableContents.inv.? (Poly) Bool)

 ;; Function-Decl crate::spec::PageTableContents::accepted_mapping
 (declare-fun spec.PageTableContents.accepted_mapping.? (Poly Poly Poly) Bool)

 ;; Function-Decl crate::spec::PageTableContents::valid_mapping
 (declare-fun spec.PageTableContents.valid_mapping.? (Poly Poly Poly) Bool)

 ;; Function-Decl crate::spec::PageTableContents::map_frame
 (declare-fun spec.PageTableContents.map_frame.? (Poly Poly Poly) pervasive.result.Result.)

 ;; Function-Decl crate::spec::PageTableContents::resolve
 (declare-fun spec.PageTableContents.resolve.? (Poly Poly) Int)

 ;; Function-Decl crate::spec::PageTableContents::unmap
 (declare-fun spec.PageTableContents.unmap.? (Poly Poly) spec.PageTableContents.)

 ;; Function-Decl crate::spec::Directory::well_formed
 (declare-fun spec.Directory.well_formed.? (Poly) Bool)

 ;; Function-Decl crate::spec::Directory::arch_layer
 (declare-fun spec.Directory.arch_layer.? (Poly) spec.ArchLayer.)

 ;; Function-Decl crate::spec::Directory::entry_size
 (declare-fun spec.Directory.entry_size.? (Poly) Int)

 ;; Function-Decl crate::spec::Directory::num_entries
 (declare-fun spec.Directory.num_entries.? (Poly) Int)

 ;; Function-Decl crate::spec::Directory::pages_match_entry_size
 (declare-fun spec.Directory.pages_match_entry_size.? (Poly) Bool)

 ;; Function-Decl crate::spec::Directory::directories_are_in_next_layer
 (declare-fun spec.Directory.directories_are_in_next_layer.? (Poly) Bool)

 ;; Function-Decl crate::spec::Directory::directories_obey_invariant
 (declare-fun spec.Directory.directories_obey_invariant.? (Poly) Bool)
 (declare-fun spec.Directory.rec%directories_obey_invariant.? (Poly Fuel) Bool)

 ;; Function-Decl crate::spec::Directory::directories_match_arch
 (declare-fun spec.Directory.directories_match_arch.? (Poly) Bool)

 ;; Function-Decl crate::spec::Directory::frames_aligned
 (declare-fun spec.Directory.frames_aligned.? (Poly) Bool)

 ;; Function-Decl crate::spec::Directory::inv
 (declare-fun spec.Directory.inv.? (Poly) Bool)
 (declare-fun spec.Directory.rec%inv.? (Poly Fuel) Bool)

 ;; Function-Decl crate::spec::Directory::interp
 (declare-fun spec.Directory.interp.? (Poly) spec.PageTableContents.)

 ;; Function-Decl crate::spec::Directory::interp_aux
 (declare-fun spec.Directory.interp_aux.? (Poly Poly) spec.PageTableContents.)
 (declare-fun spec.Directory.rec%interp_aux.? (Poly Poly Fuel) spec.PageTableContents.)

 ;; Function-Decl crate::pervasive::invariant::Invariant::inv
 (declare-fun pervasive.invariant.Invariant.inv.? (Type Poly Poly) Bool)

 ;; Function-Decl crate::pervasive::invariant::Invariant::namespace
 (declare-fun pervasive.invariant.Invariant.namespace.? (Type Poly) Int)

 ;; Function-Decl crate::pervasive::invariant::LocalInvariant::inv
 (declare-fun pervasive.invariant.LocalInvariant.inv.? (Type Poly Poly) Bool)

 ;; Function-Decl crate::pervasive::invariant::LocalInvariant::namespace
 (declare-fun pervasive.invariant.LocalInvariant.namespace.? (Type Poly) Int)

 ;; Function-Axioms crate::pervasive::map::Map::empty
 (axiom (forall ((K& Type) (V& Type)) (!
    (has_type (pervasive.map.Map.empty.? K& V&) (TYPE%pervasive.map.Map. K& V&))
    :pattern ((pervasive.map.Map.empty.? K& V&))
 )))

 ;; Function-Axioms crate::pervasive::set::Set::mk_map
 (axiom (forall ((A& Type) (V& Type) (self@ Poly) (f@ Poly)) (!
    (=>
     (and
      (has_type self@ (TYPE%pervasive.set.Set. A&))
      (has_type f@ (TYPE%fun%1. A& V&))
     )
     (has_type (pervasive.set.Set.mk_map.? A& V& self@ f@) (TYPE%pervasive.map.Map. A& V&))
    )
    :pattern ((pervasive.set.Set.mk_map.? A& V& self@ f@))
 )))

 ;; Function-Axioms crate::pervasive::set::Set::complement
 (axiom (forall ((A& Type) (self@ Poly)) (!
    (=>
     (has_type self@ (TYPE%pervasive.set.Set. A&))
     (has_type (pervasive.set.Set.complement.? A& self@) (TYPE%pervasive.set.Set. A&))
    )
    :pattern ((pervasive.set.Set.complement.? A& self@))
 )))

 ;; Function-Axioms crate::pervasive::set::Set::empty
 (axiom (forall ((A& Type)) (!
    (has_type (pervasive.set.Set.empty.? A&) (TYPE%pervasive.set.Set. A&))
    :pattern ((pervasive.set.Set.empty.? A&))
 )))

 ;; Function-Axioms crate::pervasive::set::Set::new
 (axiom (forall ((A& Type) (f@ Poly)) (!
    (=>
     (has_type f@ (TYPE%fun%1. A& BOOL))
     (has_type (pervasive.set.Set.new.? A& f@) (TYPE%pervasive.set.Set. A&))
    )
    :pattern ((pervasive.set.Set.new.? A& f@))
 )))

 ;; Function-Axioms crate::pervasive::map::Map::new
 (axiom (fuel_bool_default fuel%pervasive.map.Map.new.))
 (axiom (=>
   (fuel_bool fuel%pervasive.map.Map.new.)
   (forall ((K& Type) (V& Type) (fk@ Poly) (fv@ Poly)) (!
     (= (pervasive.map.Map.new.? K& V& fk@ fv@) (pervasive.set.Set.mk_map.? K& V& (pervasive.set.Set.new.?
        K& fk@
       ) fv@
     ))
     :pattern ((pervasive.map.Map.new.? K& V& fk@ fv@))
 ))))
 (axiom (forall ((K& Type) (V& Type) (fk@ Poly) (fv@ Poly)) (!
    (=>
     (and
      (has_type fk@ (TYPE%fun%1. K& BOOL))
      (has_type fv@ (TYPE%fun%1. K& V&))
     )
     (has_type (pervasive.map.Map.new.? K& V& fk@ fv@) (TYPE%pervasive.map.Map. K& V&))
    )
    :pattern ((pervasive.map.Map.new.? K& V& fk@ fv@))
 )))

 ;; Function-Axioms crate::pervasive::map::Map::dom
 (axiom (forall ((K& Type) (V& Type) (self@ Poly)) (!
    (=>
     (has_type self@ (TYPE%pervasive.map.Map. K& V&))
     (has_type (pervasive.map.Map.dom.? K& V& self@) (TYPE%pervasive.set.Set. K&))
    )
    :pattern ((pervasive.map.Map.dom.? K& V& self@))
 )))

 ;; Function-Axioms crate::pervasive::map::Map::index
 (declare-fun req%pervasive.map.Map.index. (Type Type Poly Poly) Bool)
 (axiom (forall ((K& Type) (V& Type) (self@ Poly) (key@ Poly)) (!
    (= (req%pervasive.map.Map.index. K& V& self@ key@) (axiom_location ("recommendation not met")
      (pervasive.set.Set.contains.? K& (pervasive.map.Map.dom.? K& V& self@) key@)
    ))
    :pattern ((req%pervasive.map.Map.index. K& V& self@ key@))
 )))
 (axiom (forall ((K& Type) (V& Type) (self@ Poly) (key@ Poly)) (!
    (=>
     (and
      (has_type self@ (TYPE%pervasive.map.Map. K& V&))
      (has_type key@ K&)
     )
     (has_type (pervasive.map.Map.index.? K& V& self@ key@) V&)
    )
    :pattern ((pervasive.map.Map.index.? K& V& self@ key@))
 )))

 ;; Function-Axioms crate::pervasive::map::Map::insert
 (axiom (forall ((K& Type) (V& Type) (self@ Poly) (key@ Poly) (value@ Poly)) (!
    (=>
     (and
      (has_type self@ (TYPE%pervasive.map.Map. K& V&))
      (has_type key@ K&)
      (has_type value@ V&)
     )
     (has_type (pervasive.map.Map.insert.? K& V& self@ key@ value@) (TYPE%pervasive.map.Map.
       K& V&
    )))
    :pattern ((pervasive.map.Map.insert.? K& V& self@ key@ value@))
 )))

 ;; Function-Axioms crate::pervasive::map::Map::remove
 (axiom (forall ((K& Type) (V& Type) (self@ Poly) (key@ Poly)) (!
    (=>
     (and
      (has_type self@ (TYPE%pervasive.map.Map. K& V&))
      (has_type key@ K&)
     )
     (has_type (pervasive.map.Map.remove.? K& V& self@ key@) (TYPE%pervasive.map.Map. K&
       V&
    )))
    :pattern ((pervasive.map.Map.remove.? K& V& self@ key@))
 )))

 ;; Function-Axioms crate::pervasive::set::Set::ext_equal
 (axiom (fuel_bool_default fuel%pervasive.set.Set.ext_equal.))
 (axiom (=>
   (fuel_bool fuel%pervasive.set.Set.ext_equal.)
   (forall ((A& Type) (self@ Poly) (s2@ Poly)) (!
     (= (pervasive.set.Set.ext_equal.? A& self@ s2@) (forall ((a$ Poly)) (!
        (=>
         (has_type a$ A&)
         (= (pervasive.set.Set.contains.? A& self@ a$) (pervasive.set.Set.contains.? A& s2@
           a$
        )))
        :pattern ((pervasive.set.Set.contains.? A& self@ a$))
        :pattern ((pervasive.set.Set.contains.? A& s2@ a$))
     )))
     :pattern ((pervasive.set.Set.ext_equal.? A& self@ s2@))
 ))))

 ;; Function-Axioms crate::pervasive::map::Map::ext_equal
 (axiom (fuel_bool_default fuel%pervasive.map.Map.ext_equal.))
 (axiom (=>
   (fuel_bool fuel%pervasive.map.Map.ext_equal.)
   (forall ((K& Type) (V& Type) (self@ Poly) (m2@ Poly)) (!
     (= (pervasive.map.Map.ext_equal.? K& V& self@ m2@) (and
       (pervasive.set.Set.ext_equal.? K& (pervasive.map.Map.dom.? K& V& self@) (pervasive.map.Map.dom.?
         K& V& m2@
       ))
       (forall ((k$ Poly)) (!
         (=>
          (has_type k$ K&)
          (=>
           (pervasive.set.Set.contains.? K& (pervasive.map.Map.dom.? K& V& self@) k$)
           (= (pervasive.map.Map.index.? K& V& self@ k$) (pervasive.map.Map.index.? K& V& m2@
             k$
         ))))
         :pattern ((pervasive.map.Map.index.? K& V& self@ k$))
         :pattern ((pervasive.map.Map.index.? K& V& m2@ k$))
     ))))
     :pattern ((pervasive.map.Map.ext_equal.? K& V& self@ m2@))
 ))))

 ;; Function-Axioms crate::pervasive::map::Map::union_prefer_right
 (axiom (fuel_bool_default fuel%pervasive.map.Map.union_prefer_right.))
 (axiom (=>
   (fuel_bool fuel%pervasive.map.Map.union_prefer_right.)
   (forall ((K& Type) (V& Type) (self@ Poly) (m2@ Poly)) (!
     (= (pervasive.map.Map.union_prefer_right.? K& V& self@ m2@) (pervasive.map.Map.new.?
       K& V& (Poly%fun%1. (mk_fun (lambda ((k$ Poly)) (B (or
            (pervasive.set.Set.contains.? K& (pervasive.map.Map.dom.? K& V& self@) k$)
            (pervasive.set.Set.contains.? K& (pervasive.map.Map.dom.? K& V& m2@) k$)
        ))))
       ) (Poly%fun%1. (mk_fun (lambda ((k$ Poly)) (ite
           (pervasive.set.Set.contains.? K& (pervasive.map.Map.dom.? K& V& m2@) k$)
           (pervasive.map.Map.index.? K& V& m2@ k$)
           (pervasive.map.Map.index.? K& V& self@ k$)
     ))))))
     :pattern ((pervasive.map.Map.union_prefer_right.? K& V& self@ m2@))
 ))))
 (axiom (forall ((K& Type) (V& Type) (self@ Poly) (m2@ Poly)) (!
    (=>
     (and
      (has_type self@ (TYPE%pervasive.map.Map. K& V&))
      (has_type m2@ (TYPE%pervasive.map.Map. K& V&))
     )
     (has_type (pervasive.map.Map.union_prefer_right.? K& V& self@ m2@) (TYPE%pervasive.map.Map.
       K& V&
    )))
    :pattern ((pervasive.map.Map.union_prefer_right.? K& V& self@ m2@))
 )))

 ;; Function-Axioms crate::pervasive::map::axiom_map_empty
 (declare-fun ens%pervasive.map.axiom_map_empty. (Type Type) Bool)
 (axiom (forall ((K& Type) (V& Type)) (!
    (= (ens%pervasive.map.axiom_map_empty. K& V&) (= (pervasive.map.Map.dom.? K& V& (pervasive.map.Map.empty.?
        K& V&
       )
      ) (pervasive.set.Set.empty.? K&)
    ))
    :pattern ((ens%pervasive.map.axiom_map_empty. K& V&))
 )))
 (axiom (forall ((K& Type) (V& Type)) (!
    (= (pervasive.map.Map.dom.? K& V& (pervasive.map.Map.empty.? K& V&)) (pervasive.set.Set.empty.?
      K&
    ))
    :pattern ((pervasive.map.Map.empty.? K& V&))
 )))

 ;; Function-Axioms crate::pervasive::set::Set::insert
 (axiom (forall ((A& Type) (self@ Poly) (a@ Poly)) (!
    (=>
     (and
      (has_type self@ (TYPE%pervasive.set.Set. A&))
      (has_type a@ A&)
     )
     (has_type (pervasive.set.Set.insert.? A& self@ a@) (TYPE%pervasive.set.Set. A&))
    )
    :pattern ((pervasive.set.Set.insert.? A& self@ a@))
 )))

 ;; Function-Axioms crate::pervasive::map::axiom_map_insert_domain
 (declare-fun ens%pervasive.map.axiom_map_insert_domain. (Type Type Poly Poly Poly)
  Bool
 )
 (axiom (forall ((K& Type) (V& Type) (m@ Poly) (key@ Poly) (value@ Poly)) (!
    (= (ens%pervasive.map.axiom_map_insert_domain. K& V& m@ key@ value@) (= (pervasive.map.Map.dom.?
       K& V& (pervasive.map.Map.insert.? K& V& m@ key@ value@)
      ) (pervasive.set.Set.insert.? K& (pervasive.map.Map.dom.? K& V& m@) key@)
    ))
    :pattern ((ens%pervasive.map.axiom_map_insert_domain. K& V& m@ key@ value@))
 )))
 (axiom (forall ((K& Type) (V& Type) (m$ Poly) (key$ Poly) (value$ Poly)) (!
    (=>
     (and
      (has_type m$ (TYPE%pervasive.map.Map. K& V&))
      (has_type key$ K&)
      (has_type value$ V&)
     )
     (= (pervasive.map.Map.dom.? K& V& (pervasive.map.Map.insert.? K& V& m$ key$ value$))
      (pervasive.set.Set.insert.? K& (pervasive.map.Map.dom.? K& V& m$) key$)
    ))
    :pattern ((pervasive.map.Map.dom.? K& V& (pervasive.map.Map.insert.? K& V& m$ key$ value$)))
 )))

 ;; Function-Axioms crate::pervasive::map::axiom_map_insert_same
 (declare-fun ens%pervasive.map.axiom_map_insert_same. (Type Type Poly Poly Poly) Bool)
 (axiom (forall ((K& Type) (V& Type) (m@ Poly) (key@ Poly) (value@ Poly)) (!
    (= (ens%pervasive.map.axiom_map_insert_same. K& V& m@ key@ value@) (= (pervasive.map.Map.index.?
       K& V& (pervasive.map.Map.insert.? K& V& m@ key@ value@) key@
      ) value@
    ))
    :pattern ((ens%pervasive.map.axiom_map_insert_same. K& V& m@ key@ value@))
 )))
 (axiom (forall ((K& Type) (V& Type) (m$ Poly) (key$ Poly) (value$ Poly)) (!
    (=>
     (and
      (has_type m$ (TYPE%pervasive.map.Map. K& V&))
      (has_type key$ K&)
      (has_type value$ V&)
     )
     (= (pervasive.map.Map.index.? K& V& (pervasive.map.Map.insert.? K& V& m$ key$ value$)
       key$
      ) value$
    ))
    :pattern ((pervasive.map.Map.index.? K& V& (pervasive.map.Map.insert.? K& V& m$ key$
       value$
      ) key$
 )))))

 ;; Function-Axioms crate::pervasive::map::axiom_map_insert_different
 (declare-fun req%pervasive.map.axiom_map_insert_different. (Type Type Poly Poly Poly
   Poly
  ) Bool
 )
 (axiom (forall ((K& Type) (V& Type) (m@ Poly) (key1@ Poly) (key2@ Poly) (value@ Poly))
   (!
    (= (req%pervasive.map.axiom_map_insert_different. K& V& m@ key1@ key2@ value@) (and
      (axiom_location ("failed precondition") (pervasive.set.Set.contains.? K& (pervasive.map.Map.dom.?
         K& V& m@
        ) key1@
      ))
      (axiom_location ("failed precondition") (not (= key1@ key2@)))
    ))
    :pattern ((req%pervasive.map.axiom_map_insert_different. K& V& m@ key1@ key2@ value@))
 )))
 (declare-fun ens%pervasive.map.axiom_map_insert_different. (Type Type Poly Poly Poly
   Poly
  ) Bool
 )
 (axiom (forall ((K& Type) (V& Type) (m@ Poly) (key1@ Poly) (key2@ Poly) (value@ Poly))
   (!
    (= (ens%pervasive.map.axiom_map_insert_different. K& V& m@ key1@ key2@ value@) (= (
       pervasive.map.Map.index.? K& V& (pervasive.map.Map.insert.? K& V& m@ key2@ value@)
       key1@
      ) (pervasive.map.Map.index.? K& V& m@ key1@)
    ))
    :pattern ((ens%pervasive.map.axiom_map_insert_different. K& V& m@ key1@ key2@ value@))
 )))
 (axiom (forall ((K& Type) (V& Type) (m$ Poly) (key1$ Poly) (key2$ Poly) (value$ Poly))
   (!
    (=>
     (and
      (has_type m$ (TYPE%pervasive.map.Map. K& V&))
      (has_type key1$ K&)
      (has_type key2$ K&)
      (has_type value$ V&)
     )
     (=>
      (and
       (pervasive.set.Set.contains.? K& (pervasive.map.Map.dom.? K& V& m$) key1$)
       (not (= key1$ key2$))
      )
      (= (pervasive.map.Map.index.? K& V& (pervasive.map.Map.insert.? K& V& m$ key2$ value$)
        key1$
       ) (pervasive.map.Map.index.? K& V& m$ key1$)
    )))
    :pattern ((pervasive.map.Map.index.? K& V& (pervasive.map.Map.insert.? K& V& m$ key2$
       value$
      ) key1$
 )))))

 ;; Function-Axioms crate::pervasive::set::Set::remove
 (axiom (forall ((A& Type) (self@ Poly) (a@ Poly)) (!
    (=>
     (and
      (has_type self@ (TYPE%pervasive.set.Set. A&))
      (has_type a@ A&)
     )
     (has_type (pervasive.set.Set.remove.? A& self@ a@) (TYPE%pervasive.set.Set. A&))
    )
    :pattern ((pervasive.set.Set.remove.? A& self@ a@))
 )))

 ;; Function-Axioms crate::pervasive::map::axiom_map_remove_domain
 (declare-fun ens%pervasive.map.axiom_map_remove_domain. (Type Type Poly Poly) Bool)
 (axiom (forall ((K& Type) (V& Type) (m@ Poly) (key@ Poly)) (!
    (= (ens%pervasive.map.axiom_map_remove_domain. K& V& m@ key@) (= (pervasive.map.Map.dom.?
       K& V& (pervasive.map.Map.remove.? K& V& m@ key@)
      ) (pervasive.set.Set.remove.? K& (pervasive.map.Map.dom.? K& V& m@) key@)
    ))
    :pattern ((ens%pervasive.map.axiom_map_remove_domain. K& V& m@ key@))
 )))
 (axiom (forall ((K& Type) (V& Type) (m$ Poly) (key$ Poly)) (!
    (=>
     (and
      (has_type m$ (TYPE%pervasive.map.Map. K& V&))
      (has_type key$ K&)
     )
     (= (pervasive.map.Map.dom.? K& V& (pervasive.map.Map.remove.? K& V& m$ key$)) (pervasive.set.Set.remove.?
       K& (pervasive.map.Map.dom.? K& V& m$) key$
    )))
    :pattern ((pervasive.map.Map.dom.? K& V& (pervasive.map.Map.remove.? K& V& m$ key$)))
 )))

 ;; Function-Axioms crate::pervasive::map::axiom_map_remove_different
 (declare-fun req%pervasive.map.axiom_map_remove_different. (Type Type Poly Poly Poly)
  Bool
 )
 (axiom (forall ((K& Type) (V& Type) (m@ Poly) (key1@ Poly) (key2@ Poly)) (!
    (= (req%pervasive.map.axiom_map_remove_different. K& V& m@ key1@ key2@) (and
      (axiom_location ("failed precondition") (pervasive.set.Set.contains.? K& (pervasive.map.Map.dom.?
         K& V& m@
        ) key1@
      ))
      (axiom_location ("failed precondition") (not (= key1@ key2@)))
    ))
    :pattern ((req%pervasive.map.axiom_map_remove_different. K& V& m@ key1@ key2@))
 )))
 (declare-fun ens%pervasive.map.axiom_map_remove_different. (Type Type Poly Poly Poly)
  Bool
 )
 (axiom (forall ((K& Type) (V& Type) (m@ Poly) (key1@ Poly) (key2@ Poly)) (!
    (= (ens%pervasive.map.axiom_map_remove_different. K& V& m@ key1@ key2@) (= (pervasive.map.Map.index.?
       K& V& (pervasive.map.Map.remove.? K& V& m@ key2@) key1@
      ) (pervasive.map.Map.index.? K& V& m@ key1@)
    ))
    :pattern ((ens%pervasive.map.axiom_map_remove_different. K& V& m@ key1@ key2@))
 )))
 (axiom (forall ((K& Type) (V& Type) (m$ Poly) (key1$ Poly) (key2$ Poly)) (!
    (=>
     (and
      (has_type m$ (TYPE%pervasive.map.Map. K& V&))
      (has_type key1$ K&)
      (has_type key2$ K&)
     )
     (=>
      (and
       (pervasive.set.Set.contains.? K& (pervasive.map.Map.dom.? K& V& m$) key1$)
       (not (= key1$ key2$))
      )
      (= (pervasive.map.Map.index.? K& V& (pervasive.map.Map.remove.? K& V& m$ key2$) key1$)
       (pervasive.map.Map.index.? K& V& m$ key1$)
    )))
    :pattern ((pervasive.map.Map.index.? K& V& (pervasive.map.Map.remove.? K& V& m$ key2$)
      key1$
 )))))

 ;; Function-Axioms crate::pervasive::map::axiom_map_ext_equal
 (declare-fun ens%pervasive.map.axiom_map_ext_equal. (Type Type Poly Poly) Bool)
 (axiom (forall ((K& Type) (V& Type) (m1@ Poly) (m2@ Poly)) (!
    (= (ens%pervasive.map.axiom_map_ext_equal. K& V& m1@ m2@) (= (pervasive.map.Map.ext_equal.?
       K& V& m1@ m2@
      ) (= m1@ m2@)
    ))
    :pattern ((ens%pervasive.map.axiom_map_ext_equal. K& V& m1@ m2@))
 )))
 (axiom (forall ((K& Type) (V& Type) (m1$ Poly) (m2$ Poly)) (!
    (=>
     (and
      (has_type m1$ (TYPE%pervasive.map.Map. K& V&))
      (has_type m2$ (TYPE%pervasive.map.Map. K& V&))
     )
     (= (pervasive.map.Map.ext_equal.? K& V& m1$ m2$) (= m1$ m2$))
    )
    :pattern ((pervasive.map.Map.ext_equal.? K& V& m1$ m2$))
 )))

 ;; Function-Axioms crate::pervasive::seq::Seq::len
 (axiom (forall ((A& Type) (self@ Poly)) (!
    (=>
     (has_type self@ (TYPE%pervasive.seq.Seq. A&))
     (<= 0 (pervasive.seq.Seq.len.? A& self@))
    )
    :pattern ((pervasive.seq.Seq.len.? A& self@))
 )))

 ;; Function-Axioms crate::pervasive::seq::Seq::index
 (declare-fun req%pervasive.seq.Seq.index. (Type Poly Poly) Bool)
 (axiom (forall ((A& Type) (self@ Poly) (i@ Poly)) (!
    (= (req%pervasive.seq.Seq.index. A& self@ i@) (and
      (axiom_location ("recommendation not met") (<= 0 (%I i@)))
      (axiom_location ("recommendation not met") (< (%I i@) (pervasive.seq.Seq.len.? A& self@)))
    ))
    :pattern ((req%pervasive.seq.Seq.index. A& self@ i@))
 )))
 (axiom (forall ((A& Type) (self@ Poly) (i@ Poly)) (!
    (=>
     (and
      (has_type self@ (TYPE%pervasive.seq.Seq. A&))
      (has_type i@ INT)
     )
     (has_type (pervasive.seq.Seq.index.? A& self@ i@) A&)
    )
    :pattern ((pervasive.seq.Seq.index.? A& self@ i@))
 )))

 ;; Function-Axioms crate::pervasive::seq::Seq::update
 (declare-fun req%pervasive.seq.Seq.update. (Type Poly Poly Poly) Bool)
 (axiom (forall ((A& Type) (self@ Poly) (i@ Poly) (a@ Poly)) (!
    (= (req%pervasive.seq.Seq.update. A& self@ i@ a@) (and
      (axiom_location ("recommendation not met") (<= 0 (%I i@)))
      (axiom_location ("recommendation not met") (< (%I i@) (pervasive.seq.Seq.len.? A& self@)))
    ))
    :pattern ((req%pervasive.seq.Seq.update. A& self@ i@ a@))
 )))
 (axiom (forall ((A& Type) (self@ Poly) (i@ Poly) (a@ Poly)) (!
    (=>
     (and
      (has_type self@ (TYPE%pervasive.seq.Seq. A&))
      (has_type i@ INT)
      (has_type a@ A&)
     )
     (has_type (pervasive.seq.Seq.update.? A& self@ i@ a@) (TYPE%pervasive.seq.Seq. A&))
    )
    :pattern ((pervasive.seq.Seq.update.? A& self@ i@ a@))
 )))

 ;; Function-Axioms crate::pervasive::seq::Seq::empty
 (axiom (forall ((A& Type)) (!
    (has_type (pervasive.seq.Seq.empty.? A&) (TYPE%pervasive.seq.Seq. A&))
    :pattern ((pervasive.seq.Seq.empty.? A&))
 )))

 ;; Function-Axioms crate::pervasive::seq::Seq::new
 (axiom (forall ((A& Type) (len@ Poly) (f@ Poly)) (!
    (=>
     (and
      (has_type len@ NAT)
      (has_type f@ (TYPE%fun%1. INT A&))
     )
     (has_type (pervasive.seq.Seq.new.? A& len@ f@) (TYPE%pervasive.seq.Seq. A&))
    )
    :pattern ((pervasive.seq.Seq.new.? A& len@ f@))
 )))

 ;; Function-Axioms crate::pervasive::seq::Seq::push
 (axiom (forall ((A& Type) (self@ Poly) (a@ Poly)) (!
    (=>
     (and
      (has_type self@ (TYPE%pervasive.seq.Seq. A&))
      (has_type a@ A&)
     )
     (has_type (pervasive.seq.Seq.push.? A& self@ a@) (TYPE%pervasive.seq.Seq. A&))
    )
    :pattern ((pervasive.seq.Seq.push.? A& self@ a@))
 )))

 ;; Function-Axioms crate::pervasive::seq::Seq::ext_equal
 (axiom (fuel_bool_default fuel%pervasive.seq.Seq.ext_equal.))
 (axiom (=>
   (fuel_bool fuel%pervasive.seq.Seq.ext_equal.)
   (forall ((A& Type) (self@ Poly) (s2@ Poly)) (!
     (= (pervasive.seq.Seq.ext_equal.? A& self@ s2@) (and
       (= (pervasive.seq.Seq.len.? A& self@) (pervasive.seq.Seq.len.? A& s2@))
       (forall ((i$ Poly)) (!
         (=>
          (has_type i$ INT)
          (=>
           (and
            (<= 0 (%I i$))
            (< (%I i$) (pervasive.seq.Seq.len.? A& self@))
           )
           (= (pervasive.seq.Seq.index.? A& self@ i$) (pervasive.seq.Seq.index.? A& s2@ i$))
         ))
         :pattern ((pervasive.seq.Seq.index.? A& self@ i$))
         :pattern ((pervasive.seq.Seq.index.? A& s2@ i$))
     ))))
     :pattern ((pervasive.seq.Seq.ext_equal.? A& self@ s2@))
 ))))

 ;; Function-Axioms crate::pervasive::seq::Seq::subrange
 (declare-fun req%pervasive.seq.Seq.subrange. (Type Poly Poly Poly) Bool)
 (axiom (forall ((A& Type) (self@ Poly) (start_inclusive@ Poly) (end_exclusive@ Poly))
   (!
    (= (req%pervasive.seq.Seq.subrange. A& self@ start_inclusive@ end_exclusive@) (and
      (axiom_location ("recommendation not met") (<= 0 (%I start_inclusive@)))
      (axiom_location ("recommendation not met") (<= (%I start_inclusive@) (%I end_exclusive@)))
      (axiom_location ("recommendation not met") (< (%I end_exclusive@) (pervasive.seq.Seq.len.?
         A& self@
    )))))
    :pattern ((req%pervasive.seq.Seq.subrange. A& self@ start_inclusive@ end_exclusive@))
 )))
 (axiom (forall ((A& Type) (self@ Poly) (start_inclusive@ Poly) (end_exclusive@ Poly))
   (!
    (=>
     (and
      (has_type self@ (TYPE%pervasive.seq.Seq. A&))
      (has_type start_inclusive@ INT)
      (has_type end_exclusive@ INT)
     )
     (has_type (pervasive.seq.Seq.subrange.? A& self@ start_inclusive@ end_exclusive@)
      (TYPE%pervasive.seq.Seq. A&)
    ))
    :pattern ((pervasive.seq.Seq.subrange.? A& self@ start_inclusive@ end_exclusive@))
 )))

 ;; Function-Axioms crate::pervasive::seq::Seq::add
 (axiom (forall ((A& Type) (self@ Poly) (rhs@ Poly)) (!
    (=>
     (and
      (has_type self@ (TYPE%pervasive.seq.Seq. A&))
      (has_type rhs@ (TYPE%pervasive.seq.Seq. A&))
     )
     (has_type (pervasive.seq.Seq.add.? A& self@ rhs@) (TYPE%pervasive.seq.Seq. A&))
    )
    :pattern ((pervasive.seq.Seq.add.? A& self@ rhs@))
 )))

 ;; Function-Axioms crate::pervasive::seq::axiom_seq_empty
 (declare-fun ens%pervasive.seq.axiom_seq_empty. (Type) Bool)
 (axiom (forall ((A& Type)) (!
    (= (ens%pervasive.seq.axiom_seq_empty. A&) (= (pervasive.seq.Seq.len.? A& (pervasive.seq.Seq.empty.?
        A&
       )
      ) 0
    ))
    :pattern ((ens%pervasive.seq.axiom_seq_empty. A&))
 )))
 (axiom (forall ((A& Type)) (!
    (= (pervasive.seq.Seq.len.? A& (pervasive.seq.Seq.empty.? A&)) 0)
    :pattern ((pervasive.seq.Seq.len.? A& (pervasive.seq.Seq.empty.? A&)))
 )))

 ;; Function-Axioms crate::pervasive::seq::axiom_seq_new_len
 (declare-fun ens%pervasive.seq.axiom_seq_new_len. (Type Int Fun) Bool)
 (axiom (forall ((A& Type) (len@ Int) (f@ Fun)) (!
    (= (ens%pervasive.seq.axiom_seq_new_len. A& len@ f@) (= (pervasive.seq.Seq.len.? A&
       (pervasive.seq.Seq.new.? A& (I len@) (Poly%fun%1. f@))
      ) len@
    ))
    :pattern ((ens%pervasive.seq.axiom_seq_new_len. A& len@ f@))
 )))
 (axiom (forall ((A& Type) (len$ Int) (f$ Fun)) (!
    (=>
     (and
      (<= 0 len$)
      (has_type (Poly%fun%1. f$) (TYPE%fun%1. INT A&))
     )
     (= (pervasive.seq.Seq.len.? A& (pervasive.seq.Seq.new.? A& (I len$) (Poly%fun%1. f$)))
      len$
    ))
    :pattern ((pervasive.seq.Seq.len.? A& (pervasive.seq.Seq.new.? A& (I len$) (Poly%fun%1.
        f$
 )))))))

 ;; Function-Axioms crate::pervasive::seq::axiom_seq_new_index
 (declare-fun req%pervasive.seq.axiom_seq_new_index. (Type Int Fun Int) Bool)
 (axiom (forall ((A& Type) (len@ Int) (f@ Fun) (i@ Int)) (!
    (= (req%pervasive.seq.axiom_seq_new_index. A& len@ f@ i@) (and
      (axiom_location ("failed precondition") (<= 0 i@))
      (axiom_location ("failed precondition") (< i@ len@))
    ))
    :pattern ((req%pervasive.seq.axiom_seq_new_index. A& len@ f@ i@))
 )))
 (declare-fun ens%pervasive.seq.axiom_seq_new_index. (Type Int Fun Int) Bool)
 (axiom (forall ((A& Type) (len@ Int) (f@ Fun) (i@ Int)) (!
    (= (ens%pervasive.seq.axiom_seq_new_index. A& len@ f@ i@) (= (pervasive.seq.Seq.index.?
       A& (pervasive.seq.Seq.new.? A& (I len@) (Poly%fun%1. f@)) (I i@)
      ) (apply Poly f@ (I i@))
    ))
    :pattern ((ens%pervasive.seq.axiom_seq_new_index. A& len@ f@ i@))
 )))
 (axiom (forall ((A& Type) (len$ Int) (f$ Fun) (i$ Int)) (!
    (=>
     (and
      (<= 0 len$)
      (has_type (Poly%fun%1. f$) (TYPE%fun%1. INT A&))
     )
     (=>
      (and
       (<= 0 i$)
       (< i$ len$)
      )
      (= (pervasive.seq.Seq.index.? A& (pervasive.seq.Seq.new.? A& (I len$) (Poly%fun%1. f$))
        (I i$)
       ) (apply Poly f$ (I i$))
    )))
    :pattern ((pervasive.seq.Seq.index.? A& (pervasive.seq.Seq.new.? A& (I len$) (Poly%fun%1.
        f$
       )
      ) (I i$)
 )))))

 ;; Function-Axioms crate::pervasive::seq::axiom_seq_push_len
 (declare-fun ens%pervasive.seq.axiom_seq_push_len. (Type Poly Poly) Bool)
 (axiom (forall ((A& Type) (s@ Poly) (a@ Poly)) (!
    (= (ens%pervasive.seq.axiom_seq_push_len. A& s@ a@) (= (pervasive.seq.Seq.len.? A& (
        pervasive.seq.Seq.push.? A& s@ a@
       )
      ) (nClip (+ (pervasive.seq.Seq.len.? A& s@) 1))
    ))
    :pattern ((ens%pervasive.seq.axiom_seq_push_len. A& s@ a@))
 )))
 (axiom (forall ((A& Type) (s$ Poly) (a$ Poly)) (!
    (=>
     (and
      (has_type s$ (TYPE%pervasive.seq.Seq. A&))
      (has_type a$ A&)
     )
     (= (pervasive.seq.Seq.len.? A& (pervasive.seq.Seq.push.? A& s$ a$)) (nClip (+ (pervasive.seq.Seq.len.?
         A& s$
        ) 1
    ))))
    :pattern ((pervasive.seq.Seq.len.? A& (pervasive.seq.Seq.push.? A& s$ a$)))
 )))

 ;; Function-Axioms crate::pervasive::seq::axiom_seq_push_index_same
 (declare-fun ens%pervasive.seq.axiom_seq_push_index_same. (Type Poly Poly) Bool)
 (axiom (forall ((A& Type) (s@ Poly) (a@ Poly)) (!
    (= (ens%pervasive.seq.axiom_seq_push_index_same. A& s@ a@) (= (pervasive.seq.Seq.index.?
       A& (pervasive.seq.Seq.push.? A& s@ a@) (I (pervasive.seq.Seq.len.? A& s@))
      ) a@
    ))
    :pattern ((ens%pervasive.seq.axiom_seq_push_index_same. A& s@ a@))
 )))
 (axiom (forall ((A& Type) (s$ Poly) (a$ Poly)) (!
    (=>
     (and
      (has_type s$ (TYPE%pervasive.seq.Seq. A&))
      (has_type a$ A&)
     )
     (= (pervasive.seq.Seq.index.? A& (pervasive.seq.Seq.push.? A& s$ a$) (I (pervasive.seq.Seq.len.?
         A& s$
       ))
      ) a$
    ))
    :pattern ((pervasive.seq.Seq.index.? A& (pervasive.seq.Seq.push.? A& s$ a$) (I (pervasive.seq.Seq.len.?
        A& s$
 )))))))

 ;; Function-Axioms crate::pervasive::seq::axiom_seq_push_index_different
 (declare-fun req%pervasive.seq.axiom_seq_push_index_different. (Type Poly Poly Int)
  Bool
 )
 (axiom (forall ((A& Type) (s@ Poly) (a@ Poly) (i@ Int)) (!
    (= (req%pervasive.seq.axiom_seq_push_index_different. A& s@ a@ i@) (and
      (axiom_location ("failed precondition") (<= 0 i@))
      (axiom_location ("failed precondition") (< i@ (pervasive.seq.Seq.len.? A& s@)))
    ))
    :pattern ((req%pervasive.seq.axiom_seq_push_index_different. A& s@ a@ i@))
 )))
 (declare-fun ens%pervasive.seq.axiom_seq_push_index_different. (Type Poly Poly Int)
  Bool
 )
 (axiom (forall ((A& Type) (s@ Poly) (a@ Poly) (i@ Int)) (!
    (= (ens%pervasive.seq.axiom_seq_push_index_different. A& s@ a@ i@) (= (pervasive.seq.Seq.index.?
       A& (pervasive.seq.Seq.push.? A& s@ a@) (I i@)
      ) (pervasive.seq.Seq.index.? A& s@ (I i@))
    ))
    :pattern ((ens%pervasive.seq.axiom_seq_push_index_different. A& s@ a@ i@))
 )))
 (axiom (forall ((A& Type) (s$ Poly) (a$ Poly) (i$ Int)) (!
    (=>
     (and
      (has_type s$ (TYPE%pervasive.seq.Seq. A&))
      (has_type a$ A&)
     )
     (=>
      (and
       (<= 0 i$)
       (< i$ (pervasive.seq.Seq.len.? A& s$))
      )
      (= (pervasive.seq.Seq.index.? A& (pervasive.seq.Seq.push.? A& s$ a$) (I i$)) (pervasive.seq.Seq.index.?
        A& s$ (I i$)
    ))))
    :pattern ((pervasive.seq.Seq.index.? A& (pervasive.seq.Seq.push.? A& s$ a$) (I i$)))
 )))

 ;; Function-Axioms crate::pervasive::seq::axiom_seq_update_len
 (declare-fun req%pervasive.seq.axiom_seq_update_len. (Type Poly Int Poly) Bool)
 (axiom (forall ((A& Type) (s@ Poly) (i@ Int) (a@ Poly)) (!
    (= (req%pervasive.seq.axiom_seq_update_len. A& s@ i@ a@) (and
      (axiom_location ("failed precondition") (<= 0 i@))
      (axiom_location ("failed precondition") (< i@ (pervasive.seq.Seq.len.? A& s@)))
    ))
    :pattern ((req%pervasive.seq.axiom_seq_update_len. A& s@ i@ a@))
 )))
 (declare-fun ens%pervasive.seq.axiom_seq_update_len. (Type Poly Int Poly) Bool)
 (axiom (forall ((A& Type) (s@ Poly) (i@ Int) (a@ Poly)) (!
    (= (ens%pervasive.seq.axiom_seq_update_len. A& s@ i@ a@) (= (pervasive.seq.Seq.len.?
       A& (pervasive.seq.Seq.update.? A& s@ (I i@) a@)
      ) (pervasive.seq.Seq.len.? A& s@)
    ))
    :pattern ((ens%pervasive.seq.axiom_seq_update_len. A& s@ i@ a@))
 )))
 (axiom (forall ((A& Type) (s$ Poly) (i$ Int) (a$ Poly)) (!
    (=>
     (and
      (has_type s$ (TYPE%pervasive.seq.Seq. A&))
      (has_type a$ A&)
     )
     (=>
      (and
       (<= 0 i$)
       (< i$ (pervasive.seq.Seq.len.? A& s$))
      )
      (= (pervasive.seq.Seq.len.? A& (pervasive.seq.Seq.update.? A& s$ (I i$) a$)) (pervasive.seq.Seq.len.?
        A& s$
    ))))
    :pattern ((pervasive.seq.Seq.len.? A& (pervasive.seq.Seq.update.? A& s$ (I i$) a$)))
 )))

 ;; Function-Axioms crate::pervasive::seq::axiom_seq_update_same
 (declare-fun req%pervasive.seq.axiom_seq_update_same. (Type Poly Int Poly) Bool)
 (axiom (forall ((A& Type) (s@ Poly) (i@ Int) (a@ Poly)) (!
    (= (req%pervasive.seq.axiom_seq_update_same. A& s@ i@ a@) (and
      (axiom_location ("failed precondition") (<= 0 i@))
      (axiom_location ("failed precondition") (< i@ (pervasive.seq.Seq.len.? A& s@)))
    ))
    :pattern ((req%pervasive.seq.axiom_seq_update_same. A& s@ i@ a@))
 )))
 (declare-fun ens%pervasive.seq.axiom_seq_update_same. (Type Poly Int Poly) Bool)
 (axiom (forall ((A& Type) (s@ Poly) (i@ Int) (a@ Poly)) (!
    (= (ens%pervasive.seq.axiom_seq_update_same. A& s@ i@ a@) (= (pervasive.seq.Seq.index.?
       A& (pervasive.seq.Seq.update.? A& s@ (I i@) a@) (I i@)
      ) a@
    ))
    :pattern ((ens%pervasive.seq.axiom_seq_update_same. A& s@ i@ a@))
 )))
 (axiom (forall ((A& Type) (s$ Poly) (i$ Int) (a$ Poly)) (!
    (=>
     (and
      (has_type s$ (TYPE%pervasive.seq.Seq. A&))
      (has_type a$ A&)
     )
     (=>
      (and
       (<= 0 i$)
       (< i$ (pervasive.seq.Seq.len.? A& s$))
      )
      (= (pervasive.seq.Seq.index.? A& (pervasive.seq.Seq.update.? A& s$ (I i$) a$) (I i$))
       a$
    )))
    :pattern ((pervasive.seq.Seq.index.? A& (pervasive.seq.Seq.update.? A& s$ (I i$) a$)
      (I i$)
 )))))

 ;; Function-Axioms crate::pervasive::seq::axiom_seq_update_different
 (declare-fun req%pervasive.seq.axiom_seq_update_different. (Type Poly Int Int Poly)
  Bool
 )
 (axiom (forall ((A& Type) (s@ Poly) (i1@ Int) (i2@ Int) (a@ Poly)) (!
    (= (req%pervasive.seq.axiom_seq_update_different. A& s@ i1@ i2@ a@) (and
      (axiom_location ("failed precondition") (<= 0 i1@))
      (axiom_location ("failed precondition") (< i1@ (pervasive.seq.Seq.len.? A& s@)))
      (axiom_location ("failed precondition") (<= 0 i2@))
      (axiom_location ("failed precondition") (< i2@ (pervasive.seq.Seq.len.? A& s@)))
      (axiom_location ("failed precondition") (not (= i1@ i2@)))
    ))
    :pattern ((req%pervasive.seq.axiom_seq_update_different. A& s@ i1@ i2@ a@))
 )))
 (declare-fun ens%pervasive.seq.axiom_seq_update_different. (Type Poly Int Int Poly)
  Bool
 )
 (axiom (forall ((A& Type) (s@ Poly) (i1@ Int) (i2@ Int) (a@ Poly)) (!
    (= (ens%pervasive.seq.axiom_seq_update_different. A& s@ i1@ i2@ a@) (= (pervasive.seq.Seq.index.?
       A& (pervasive.seq.Seq.update.? A& s@ (I i2@) a@) (I i1@)
      ) (pervasive.seq.Seq.index.? A& s@ (I i1@))
    ))
    :pattern ((ens%pervasive.seq.axiom_seq_update_different. A& s@ i1@ i2@ a@))
 )))
 (axiom (forall ((A& Type) (s$ Poly) (i1$ Int) (i2$ Int) (a$ Poly)) (!
    (=>
     (and
      (has_type s$ (TYPE%pervasive.seq.Seq. A&))
      (has_type a$ A&)
     )
     (=>
      (and
       (and
        (and
         (and
          (<= 0 i1$)
          (< i1$ (pervasive.seq.Seq.len.? A& s$))
         )
         (<= 0 i2$)
        )
        (< i2$ (pervasive.seq.Seq.len.? A& s$))
       )
       (not (= i1$ i2$))
      )
      (= (pervasive.seq.Seq.index.? A& (pervasive.seq.Seq.update.? A& s$ (I i2$) a$) (I i1$))
       (pervasive.seq.Seq.index.? A& s$ (I i1$))
    )))
    :pattern ((pervasive.seq.Seq.index.? A& (pervasive.seq.Seq.update.? A& s$ (I i2$) a$)
      (I i1$)
 )))))

 ;; Function-Axioms crate::pervasive::seq::axiom_seq_ext_equal
 (declare-fun ens%pervasive.seq.axiom_seq_ext_equal. (Type Poly Poly) Bool)
 (axiom (forall ((A& Type) (s1@ Poly) (s2@ Poly)) (!
    (= (ens%pervasive.seq.axiom_seq_ext_equal. A& s1@ s2@) (= (pervasive.seq.Seq.ext_equal.?
       A& s1@ s2@
      ) (= s1@ s2@)
    ))
    :pattern ((ens%pervasive.seq.axiom_seq_ext_equal. A& s1@ s2@))
 )))
 (axiom (forall ((A& Type) (s1$ Poly) (s2$ Poly)) (!
    (=>
     (and
      (has_type s1$ (TYPE%pervasive.seq.Seq. A&))
      (has_type s2$ (TYPE%pervasive.seq.Seq. A&))
     )
     (= (pervasive.seq.Seq.ext_equal.? A& s1$ s2$) (= s1$ s2$))
    )
    :pattern ((pervasive.seq.Seq.ext_equal.? A& s1$ s2$))
 )))

 ;; Function-Axioms crate::pervasive::seq::axiom_seq_subrange_len
 (declare-fun req%pervasive.seq.axiom_seq_subrange_len. (Type Poly Int Int) Bool)
 (axiom (forall ((A& Type) (s@ Poly) (j@ Int) (k@ Int)) (!
    (= (req%pervasive.seq.axiom_seq_subrange_len. A& s@ j@ k@) (and
      (axiom_location ("failed precondition") (<= 0 j@))
      (axiom_location ("failed precondition") (<= j@ k@))
      (axiom_location ("failed precondition") (<= k@ (pervasive.seq.Seq.len.? A& s@)))
    ))
    :pattern ((req%pervasive.seq.axiom_seq_subrange_len. A& s@ j@ k@))
 )))
 (declare-fun ens%pervasive.seq.axiom_seq_subrange_len. (Type Poly Int Int) Bool)
 (axiom (forall ((A& Type) (s@ Poly) (j@ Int) (k@ Int)) (!
    (= (ens%pervasive.seq.axiom_seq_subrange_len. A& s@ j@ k@) (= (pervasive.seq.Seq.len.?
       A& (pervasive.seq.Seq.subrange.? A& s@ (I j@) (I k@))
      ) (- k@ j@)
    ))
    :pattern ((ens%pervasive.seq.axiom_seq_subrange_len. A& s@ j@ k@))
 )))
 (axiom (forall ((A& Type) (s$ Poly) (j$ Int) (k$ Int)) (!
    (=>
     (has_type s$ (TYPE%pervasive.seq.Seq. A&))
     (=>
      (and
       (and
        (<= 0 j$)
        (<= j$ k$)
       )
       (<= k$ (pervasive.seq.Seq.len.? A& s$))
      )
      (= (pervasive.seq.Seq.len.? A& (pervasive.seq.Seq.subrange.? A& s$ (I j$) (I k$)))
       (- k$ j$)
    )))
    :pattern ((pervasive.seq.Seq.len.? A& (pervasive.seq.Seq.subrange.? A& s$ (I j$) (I k$))))
 )))

 ;; Function-Axioms crate::pervasive::seq::axiom_seq_subrange_index
 (declare-fun req%pervasive.seq.axiom_seq_subrange_index. (Type Poly Int Int Int) Bool)
 (axiom (forall ((A& Type) (s@ Poly) (j@ Int) (k@ Int) (i@ Int)) (!
    (= (req%pervasive.seq.axiom_seq_subrange_index. A& s@ j@ k@ i@) (and
      (axiom_location ("failed precondition") (<= 0 j@))
      (axiom_location ("failed precondition") (<= j@ k@))
      (axiom_location ("failed precondition") (<= k@ (pervasive.seq.Seq.len.? A& s@)))
      (axiom_location ("failed precondition") (<= 0 i@))
      (axiom_location ("failed precondition") (< i@ (- k@ j@)))
    ))
    :pattern ((req%pervasive.seq.axiom_seq_subrange_index. A& s@ j@ k@ i@))
 )))
 (declare-fun ens%pervasive.seq.axiom_seq_subrange_index. (Type Poly Int Int Int) Bool)
 (axiom (forall ((A& Type) (s@ Poly) (j@ Int) (k@ Int) (i@ Int)) (!
    (= (ens%pervasive.seq.axiom_seq_subrange_index. A& s@ j@ k@ i@) (= (pervasive.seq.Seq.index.?
       A& (pervasive.seq.Seq.subrange.? A& s@ (I j@) (I k@)) (I i@)
      ) (pervasive.seq.Seq.index.? A& s@ (I (+ i@ j@)))
    ))
    :pattern ((ens%pervasive.seq.axiom_seq_subrange_index. A& s@ j@ k@ i@))
 )))
 (axiom (forall ((A& Type) (s$ Poly) (j$ Int) (k$ Int) (i$ Int)) (!
    (=>
     (has_type s$ (TYPE%pervasive.seq.Seq. A&))
     (=>
      (and
       (and
        (and
         (and
          (<= 0 j$)
          (<= j$ k$)
         )
         (<= k$ (pervasive.seq.Seq.len.? A& s$))
        )
        (<= 0 i$)
       )
       (< i$ (- k$ j$))
      )
      (= (pervasive.seq.Seq.index.? A& (pervasive.seq.Seq.subrange.? A& s$ (I j$) (I k$))
        (I i$)
       ) (pervasive.seq.Seq.index.? A& s$ (I (+ i$ j$)))
    )))
    :pattern ((pervasive.seq.Seq.index.? A& (pervasive.seq.Seq.subrange.? A& s$ (I j$) (
        I k$
       )
      ) (I i$)
 )))))

 ;; Function-Axioms crate::pervasive::seq::axiom_seq_add_len
 (declare-fun ens%pervasive.seq.axiom_seq_add_len. (Type Poly Poly) Bool)
 (axiom (forall ((A& Type) (s1@ Poly) (s2@ Poly)) (!
    (= (ens%pervasive.seq.axiom_seq_add_len. A& s1@ s2@) (= (pervasive.seq.Seq.len.? A&
       (pervasive.seq.Seq.add.? A& s1@ s2@)
      ) (nClip (+ (pervasive.seq.Seq.len.? A& s1@) (pervasive.seq.Seq.len.? A& s2@)))
    ))
    :pattern ((ens%pervasive.seq.axiom_seq_add_len. A& s1@ s2@))
 )))
 (axiom (forall ((A& Type) (s1$ Poly) (s2$ Poly)) (!
    (=>
     (and
      (has_type s1$ (TYPE%pervasive.seq.Seq. A&))
      (has_type s2$ (TYPE%pervasive.seq.Seq. A&))
     )
     (= (pervasive.seq.Seq.len.? A& (pervasive.seq.Seq.add.? A& s1$ s2$)) (nClip (+ (pervasive.seq.Seq.len.?
         A& s1$
        ) (pervasive.seq.Seq.len.? A& s2$)
    ))))
    :pattern ((pervasive.seq.Seq.len.? A& (pervasive.seq.Seq.add.? A& s1$ s2$)))
 )))

 ;; Function-Axioms crate::pervasive::seq::axiom_seq_add_index1
 (declare-fun req%pervasive.seq.axiom_seq_add_index1. (Type Poly Poly Int) Bool)
 (axiom (forall ((A& Type) (s1@ Poly) (s2@ Poly) (i@ Int)) (!
    (= (req%pervasive.seq.axiom_seq_add_index1. A& s1@ s2@ i@) (and
      (axiom_location ("failed precondition") (<= 0 i@))
      (axiom_location ("failed precondition") (< i@ (pervasive.seq.Seq.len.? A& s1@)))
    ))
    :pattern ((req%pervasive.seq.axiom_seq_add_index1. A& s1@ s2@ i@))
 )))
 (declare-fun ens%pervasive.seq.axiom_seq_add_index1. (Type Poly Poly Int) Bool)
 (axiom (forall ((A& Type) (s1@ Poly) (s2@ Poly) (i@ Int)) (!
    (= (ens%pervasive.seq.axiom_seq_add_index1. A& s1@ s2@ i@) (= (pervasive.seq.Seq.index.?
       A& (pervasive.seq.Seq.add.? A& s1@ s2@) (I i@)
      ) (pervasive.seq.Seq.index.? A& s1@ (I i@))
    ))
    :pattern ((ens%pervasive.seq.axiom_seq_add_index1. A& s1@ s2@ i@))
 )))
 (axiom (forall ((A& Type) (s1$ Poly) (s2$ Poly) (i$ Int)) (!
    (=>
     (and
      (has_type s1$ (TYPE%pervasive.seq.Seq. A&))
      (has_type s2$ (TYPE%pervasive.seq.Seq. A&))
     )
     (=>
      (and
       (<= 0 i$)
       (< i$ (pervasive.seq.Seq.len.? A& s1$))
      )
      (= (pervasive.seq.Seq.index.? A& (pervasive.seq.Seq.add.? A& s1$ s2$) (I i$)) (pervasive.seq.Seq.index.?
        A& s1$ (I i$)
    ))))
    :pattern ((pervasive.seq.Seq.index.? A& (pervasive.seq.Seq.add.? A& s1$ s2$) (I i$)))
 )))

 ;; Function-Axioms crate::pervasive::seq::axiom_seq_add_index2
 (declare-fun req%pervasive.seq.axiom_seq_add_index2. (Type Poly Poly Int) Bool)
 (axiom (forall ((A& Type) (s1@ Poly) (s2@ Poly) (i@ Int)) (!
    (= (req%pervasive.seq.axiom_seq_add_index2. A& s1@ s2@ i@) (and
      (axiom_location ("failed precondition") (<= 0 (pervasive.seq.Seq.len.? A& s1@)))
      (axiom_location ("failed precondition") (< i@ (+ (pervasive.seq.Seq.len.? A& s1@) (pervasive.seq.Seq.len.?
          A& s2@
    ))))))
    :pattern ((req%pervasive.seq.axiom_seq_add_index2. A& s1@ s2@ i@))
 )))
 (declare-fun ens%pervasive.seq.axiom_seq_add_index2. (Type Poly Poly Int) Bool)
 (axiom (forall ((A& Type) (s1@ Poly) (s2@ Poly) (i@ Int)) (!
    (= (ens%pervasive.seq.axiom_seq_add_index2. A& s1@ s2@ i@) (= (pervasive.seq.Seq.index.?
       A& (pervasive.seq.Seq.add.? A& s1@ s2@) (I i@)
      ) (pervasive.seq.Seq.index.? A& s2@ (I (- i@ (pervasive.seq.Seq.len.? A& s1@))))
    ))
    :pattern ((ens%pervasive.seq.axiom_seq_add_index2. A& s1@ s2@ i@))
 )))
 (axiom (forall ((A& Type) (s1$ Poly) (s2$ Poly) (i$ Int)) (!
    (=>
     (and
      (has_type s1$ (TYPE%pervasive.seq.Seq. A&))
      (has_type s2$ (TYPE%pervasive.seq.Seq. A&))
     )
     (=>
      (and
       (<= 0 (pervasive.seq.Seq.len.? A& s1$))
       (< i$ (+ (pervasive.seq.Seq.len.? A& s1$) (pervasive.seq.Seq.len.? A& s2$)))
      )
      (= (pervasive.seq.Seq.index.? A& (pervasive.seq.Seq.add.? A& s1$ s2$) (I i$)) (pervasive.seq.Seq.index.?
        A& s2$ (I (- i$ (pervasive.seq.Seq.len.? A& s1$)))
    ))))
    :pattern ((pervasive.seq.Seq.index.? A& (pervasive.seq.Seq.add.? A& s1$ s2$) (I i$)))
 )))

 ;; Function-Axioms crate::pervasive::set::Set::union
 (axiom (forall ((A& Type) (self@ Poly) (s2@ Poly)) (!
    (=>
     (and
      (has_type self@ (TYPE%pervasive.set.Set. A&))
      (has_type s2@ (TYPE%pervasive.set.Set. A&))
     )
     (has_type (pervasive.set.Set.union.? A& self@ s2@) (TYPE%pervasive.set.Set. A&))
    )
    :pattern ((pervasive.set.Set.union.? A& self@ s2@))
 )))

 ;; Function-Axioms crate::pervasive::set::Set::intersect
 (axiom (forall ((A& Type) (self@ Poly) (s2@ Poly)) (!
    (=>
     (and
      (has_type self@ (TYPE%pervasive.set.Set. A&))
      (has_type s2@ (TYPE%pervasive.set.Set. A&))
     )
     (has_type (pervasive.set.Set.intersect.? A& self@ s2@) (TYPE%pervasive.set.Set. A&))
    )
    :pattern ((pervasive.set.Set.intersect.? A& self@ s2@))
 )))

 ;; Function-Axioms crate::pervasive::set::Set::difference
 (axiom (forall ((A& Type) (self@ Poly) (s2@ Poly)) (!
    (=>
     (and
      (has_type self@ (TYPE%pervasive.set.Set. A&))
      (has_type s2@ (TYPE%pervasive.set.Set. A&))
     )
     (has_type (pervasive.set.Set.difference.? A& self@ s2@) (TYPE%pervasive.set.Set. A&))
    )
    :pattern ((pervasive.set.Set.difference.? A& self@ s2@))
 )))

 ;; Function-Axioms crate::pervasive::set::Set::len
 (axiom (forall ((A& Type) (self@ Poly)) (!
    (=>
     (has_type self@ (TYPE%pervasive.set.Set. A&))
     (<= 0 (pervasive.set.Set.len.? A& self@))
    )
    :pattern ((pervasive.set.Set.len.? A& self@))
 )))

 ;; Function-Axioms crate::pervasive::set::Set::choose
 (axiom (fuel_bool_default fuel%pervasive.set.Set.choose.))
 (axiom (=>
   (fuel_bool fuel%pervasive.set.Set.choose.)
   (forall ((A& Type) (self@ Poly)) (!
     (= (pervasive.set.Set.choose.? A& self@) (as_type (choose ((a$ Poly)) (!
         (and
          (has_type a$ A&)
          (pervasive.set.Set.contains.? A& self@ a$)
         )
         :pattern ((pervasive.set.Set.contains.? A& self@ a$))
        ) a$
       ) A&
     ))
     :pattern ((pervasive.set.Set.choose.? A& self@))
 ))))
 (axiom (forall ((A& Type) (self@ Poly)) (!
    (=>
     (has_type self@ (TYPE%pervasive.set.Set. A&))
     (has_type (pervasive.set.Set.choose.? A& self@) A&)
    )
    :pattern ((pervasive.set.Set.choose.? A& self@))
 )))

 ;; Function-Axioms crate::pervasive::set::axiom_set_empty
 (declare-fun ens%pervasive.set.axiom_set_empty. (Type Poly) Bool)
 (axiom (forall ((A& Type) (a@ Poly)) (!
    (= (ens%pervasive.set.axiom_set_empty. A& a@) (not (pervasive.set.Set.contains.? A&
       (pervasive.set.Set.empty.? A&) a@
    )))
    :pattern ((ens%pervasive.set.axiom_set_empty. A& a@))
 )))
 (axiom (forall ((A& Type) (a$ Poly)) (!
    (=>
     (has_type a$ A&)
     (not (pervasive.set.Set.contains.? A& (pervasive.set.Set.empty.? A&) a$))
    )
    :pattern ((pervasive.set.Set.contains.? A& (pervasive.set.Set.empty.? A&) a$))
 )))

 ;; Function-Axioms crate::pervasive::set::axiom_set_new
 (declare-fun ens%pervasive.set.axiom_set_new. (Type Fun Poly) Bool)
 (axiom (forall ((A& Type) (f@ Fun) (a@ Poly)) (!
    (= (ens%pervasive.set.axiom_set_new. A& f@ a@) (= (pervasive.set.Set.contains.? A& (
        pervasive.set.Set.new.? A& (Poly%fun%1. f@)
       ) a@
      ) (%B (apply Poly f@ a@))
    ))
    :pattern ((ens%pervasive.set.axiom_set_new. A& f@ a@))
 )))
 (axiom (forall ((A& Type) (f$ Fun) (a$ Poly)) (!
    (=>
     (and
      (has_type (Poly%fun%1. f$) (TYPE%fun%1. A& BOOL))
      (has_type a$ A&)
     )
     (= (pervasive.set.Set.contains.? A& (pervasive.set.Set.new.? A& (Poly%fun%1. f$)) a$)
      (%B (apply Poly f$ a$))
    ))
    :pattern ((pervasive.set.Set.contains.? A& (pervasive.set.Set.new.? A& (Poly%fun%1. f$))
      a$
 )))))

 ;; Function-Axioms crate::pervasive::set::axiom_set_insert_same
 (declare-fun ens%pervasive.set.axiom_set_insert_same. (Type Poly Poly) Bool)
 (axiom (forall ((A& Type) (s@ Poly) (a@ Poly)) (!
    (= (ens%pervasive.set.axiom_set_insert_same. A& s@ a@) (pervasive.set.Set.contains.?
      A& (pervasive.set.Set.insert.? A& s@ a@) a@
    ))
    :pattern ((ens%pervasive.set.axiom_set_insert_same. A& s@ a@))
 )))
 (axiom (forall ((A& Type) (s$ Poly) (a$ Poly)) (!
    (=>
     (and
      (has_type s$ (TYPE%pervasive.set.Set. A&))
      (has_type a$ A&)
     )
     (pervasive.set.Set.contains.? A& (pervasive.set.Set.insert.? A& s$ a$) a$)
    )
    :pattern ((pervasive.set.Set.contains.? A& (pervasive.set.Set.insert.? A& s$ a$) a$))
 )))

 ;; Function-Axioms crate::pervasive::set::axiom_set_insert_different
 (declare-fun req%pervasive.set.axiom_set_insert_different. (Type Poly Poly Poly) Bool)
 (axiom (forall ((A& Type) (s@ Poly) (a1@ Poly) (a2@ Poly)) (!
    (= (req%pervasive.set.axiom_set_insert_different. A& s@ a1@ a2@) (axiom_location ("failed precondition")
      (not (= a1@ a2@))
    ))
    :pattern ((req%pervasive.set.axiom_set_insert_different. A& s@ a1@ a2@))
 )))
 (declare-fun ens%pervasive.set.axiom_set_insert_different. (Type Poly Poly Poly) Bool)
 (axiom (forall ((A& Type) (s@ Poly) (a1@ Poly) (a2@ Poly)) (!
    (= (ens%pervasive.set.axiom_set_insert_different. A& s@ a1@ a2@) (= (pervasive.set.Set.contains.?
       A& (pervasive.set.Set.insert.? A& s@ a2@) a1@
      ) (pervasive.set.Set.contains.? A& s@ a1@)
    ))
    :pattern ((ens%pervasive.set.axiom_set_insert_different. A& s@ a1@ a2@))
 )))
 (axiom (forall ((A& Type) (s$ Poly) (a1$ Poly) (a2$ Poly)) (!
    (=>
     (and
      (has_type s$ (TYPE%pervasive.set.Set. A&))
      (has_type a1$ A&)
      (has_type a2$ A&)
     )
     (=>
      (not (= a1$ a2$))
      (= (pervasive.set.Set.contains.? A& (pervasive.set.Set.insert.? A& s$ a2$) a1$) (pervasive.set.Set.contains.?
        A& s$ a1$
    ))))
    :pattern ((pervasive.set.Set.contains.? A& (pervasive.set.Set.insert.? A& s$ a2$) a1$))
 )))

 ;; Function-Axioms crate::pervasive::set::axiom_set_remove_same
 (declare-fun ens%pervasive.set.axiom_set_remove_same. (Type Poly Poly) Bool)
 (axiom (forall ((A& Type) (s@ Poly) (a@ Poly)) (!
    (= (ens%pervasive.set.axiom_set_remove_same. A& s@ a@) (not (pervasive.set.Set.contains.?
       A& (pervasive.set.Set.remove.? A& s@ a@) a@
    )))
    :pattern ((ens%pervasive.set.axiom_set_remove_same. A& s@ a@))
 )))
 (axiom (forall ((A& Type) (s$ Poly) (a$ Poly)) (!
    (=>
     (and
      (has_type s$ (TYPE%pervasive.set.Set. A&))
      (has_type a$ A&)
     )
     (not (pervasive.set.Set.contains.? A& (pervasive.set.Set.remove.? A& s$ a$) a$))
    )
    :pattern ((pervasive.set.Set.contains.? A& (pervasive.set.Set.remove.? A& s$ a$) a$))
 )))

 ;; Function-Axioms crate::pervasive::set::axiom_set_remove_different
 (declare-fun req%pervasive.set.axiom_set_remove_different. (Type Poly Poly Poly) Bool)
 (axiom (forall ((A& Type) (s@ Poly) (a1@ Poly) (a2@ Poly)) (!
    (= (req%pervasive.set.axiom_set_remove_different. A& s@ a1@ a2@) (axiom_location ("failed precondition")
      (not (= a1@ a2@))
    ))
    :pattern ((req%pervasive.set.axiom_set_remove_different. A& s@ a1@ a2@))
 )))
 (declare-fun ens%pervasive.set.axiom_set_remove_different. (Type Poly Poly Poly) Bool)
 (axiom (forall ((A& Type) (s@ Poly) (a1@ Poly) (a2@ Poly)) (!
    (= (ens%pervasive.set.axiom_set_remove_different. A& s@ a1@ a2@) (= (pervasive.set.Set.contains.?
       A& (pervasive.set.Set.remove.? A& s@ a2@) a1@
      ) (pervasive.set.Set.contains.? A& s@ a1@)
    ))
    :pattern ((ens%pervasive.set.axiom_set_remove_different. A& s@ a1@ a2@))
 )))
 (axiom (forall ((A& Type) (s$ Poly) (a1$ Poly) (a2$ Poly)) (!
    (=>
     (and
      (has_type s$ (TYPE%pervasive.set.Set. A&))
      (has_type a1$ A&)
      (has_type a2$ A&)
     )
     (=>
      (not (= a1$ a2$))
      (= (pervasive.set.Set.contains.? A& (pervasive.set.Set.remove.? A& s$ a2$) a1$) (pervasive.set.Set.contains.?
        A& s$ a1$
    ))))
    :pattern ((pervasive.set.Set.contains.? A& (pervasive.set.Set.remove.? A& s$ a2$) a1$))
 )))

 ;; Function-Axioms crate::pervasive::set::axiom_set_union
 (declare-fun ens%pervasive.set.axiom_set_union. (Type Poly Poly Poly) Bool)
 (axiom (forall ((A& Type) (s1@ Poly) (s2@ Poly) (a@ Poly)) (!
    (= (ens%pervasive.set.axiom_set_union. A& s1@ s2@ a@) (= (pervasive.set.Set.contains.?
       A& (pervasive.set.Set.union.? A& s1@ s2@) a@
      ) (or
       (pervasive.set.Set.contains.? A& s1@ a@)
       (pervasive.set.Set.contains.? A& s2@ a@)
    )))
    :pattern ((ens%pervasive.set.axiom_set_union. A& s1@ s2@ a@))
 )))
 (axiom (forall ((A& Type) (s1$ Poly) (s2$ Poly) (a$ Poly)) (!
    (=>
     (and
      (has_type s1$ (TYPE%pervasive.set.Set. A&))
      (has_type s2$ (TYPE%pervasive.set.Set. A&))
      (has_type a$ A&)
     )
     (= (pervasive.set.Set.contains.? A& (pervasive.set.Set.union.? A& s1$ s2$) a$) (or
       (pervasive.set.Set.contains.? A& s1$ a$)
       (pervasive.set.Set.contains.? A& s2$ a$)
    )))
    :pattern ((pervasive.set.Set.contains.? A& (pervasive.set.Set.union.? A& s1$ s2$) a$))
 )))

 ;; Function-Axioms crate::pervasive::set::axiom_set_intersect
 (declare-fun ens%pervasive.set.axiom_set_intersect. (Type Poly Poly Poly) Bool)
 (axiom (forall ((A& Type) (s1@ Poly) (s2@ Poly) (a@ Poly)) (!
    (= (ens%pervasive.set.axiom_set_intersect. A& s1@ s2@ a@) (= (pervasive.set.Set.contains.?
       A& (pervasive.set.Set.intersect.? A& s1@ s2@) a@
      ) (and
       (pervasive.set.Set.contains.? A& s1@ a@)
       (pervasive.set.Set.contains.? A& s2@ a@)
    )))
    :pattern ((ens%pervasive.set.axiom_set_intersect. A& s1@ s2@ a@))
 )))
 (axiom (forall ((A& Type) (s1$ Poly) (s2$ Poly) (a$ Poly)) (!
    (=>
     (and
      (has_type s1$ (TYPE%pervasive.set.Set. A&))
      (has_type s2$ (TYPE%pervasive.set.Set. A&))
      (has_type a$ A&)
     )
     (= (pervasive.set.Set.contains.? A& (pervasive.set.Set.intersect.? A& s1$ s2$) a$)
      (and
       (pervasive.set.Set.contains.? A& s1$ a$)
       (pervasive.set.Set.contains.? A& s2$ a$)
    )))
    :pattern ((pervasive.set.Set.contains.? A& (pervasive.set.Set.intersect.? A& s1$ s2$)
      a$
 )))))

 ;; Function-Axioms crate::pervasive::set::axiom_set_difference
 (declare-fun ens%pervasive.set.axiom_set_difference. (Type Poly Poly Poly) Bool)
 (axiom (forall ((A& Type) (s1@ Poly) (s2@ Poly) (a@ Poly)) (!
    (= (ens%pervasive.set.axiom_set_difference. A& s1@ s2@ a@) (= (pervasive.set.Set.contains.?
       A& (pervasive.set.Set.difference.? A& s1@ s2@) a@
      ) (and
       (pervasive.set.Set.contains.? A& s1@ a@)
       (not (pervasive.set.Set.contains.? A& s2@ a@))
    )))
    :pattern ((ens%pervasive.set.axiom_set_difference. A& s1@ s2@ a@))
 )))
 (axiom (forall ((A& Type) (s1$ Poly) (s2$ Poly) (a$ Poly)) (!
    (=>
     (and
      (has_type s1$ (TYPE%pervasive.set.Set. A&))
      (has_type s2$ (TYPE%pervasive.set.Set. A&))
      (has_type a$ A&)
     )
     (= (pervasive.set.Set.contains.? A& (pervasive.set.Set.difference.? A& s1$ s2$) a$)
      (and
       (pervasive.set.Set.contains.? A& s1$ a$)
       (not (pervasive.set.Set.contains.? A& s2$ a$))
    )))
    :pattern ((pervasive.set.Set.contains.? A& (pervasive.set.Set.difference.? A& s1$ s2$)
      a$
 )))))

 ;; Function-Axioms crate::pervasive::set::axiom_set_complement
 (declare-fun ens%pervasive.set.axiom_set_complement. (Type Poly Poly) Bool)
 (axiom (forall ((A& Type) (s@ Poly) (a@ Poly)) (!
    (= (ens%pervasive.set.axiom_set_complement. A& s@ a@) (= (pervasive.set.Set.contains.?
       A& (pervasive.set.Set.complement.? A& s@) a@
      ) (not (pervasive.set.Set.contains.? A& s@ a@))
    ))
    :pattern ((ens%pervasive.set.axiom_set_complement. A& s@ a@))
 )))
 (axiom (forall ((A& Type) (s$ Poly) (a$ Poly)) (!
    (=>
     (and
      (has_type s$ (TYPE%pervasive.set.Set. A&))
      (has_type a$ A&)
     )
     (= (pervasive.set.Set.contains.? A& (pervasive.set.Set.complement.? A& s$) a$) (not
       (pervasive.set.Set.contains.? A& s$ a$)
    )))
    :pattern ((pervasive.set.Set.contains.? A& (pervasive.set.Set.complement.? A& s$) a$))
 )))

 ;; Function-Axioms crate::pervasive::set::axiom_set_ext_equal
 (declare-fun ens%pervasive.set.axiom_set_ext_equal. (Type Poly Poly) Bool)
 (axiom (forall ((A& Type) (s1@ Poly) (s2@ Poly)) (!
    (= (ens%pervasive.set.axiom_set_ext_equal. A& s1@ s2@) (= (pervasive.set.Set.ext_equal.?
       A& s1@ s2@
      ) (= s1@ s2@)
    ))
    :pattern ((ens%pervasive.set.axiom_set_ext_equal. A& s1@ s2@))
 )))
 (axiom (forall ((A& Type) (s1$ Poly) (s2$ Poly)) (!
    (=>
     (and
      (has_type s1$ (TYPE%pervasive.set.Set. A&))
      (has_type s2$ (TYPE%pervasive.set.Set. A&))
     )
     (= (pervasive.set.Set.ext_equal.? A& s1$ s2$) (= s1$ s2$))
    )
    :pattern ((pervasive.set.Set.ext_equal.? A& s1$ s2$))
 )))

 ;; Function-Axioms crate::pervasive::set::axiom_mk_map_domain
 (declare-fun ens%pervasive.set.axiom_mk_map_domain. (Type Type Poly Fun) Bool)
 (axiom (forall ((K& Type) (V& Type) (s@ Poly) (f@ Fun)) (!
    (= (ens%pervasive.set.axiom_mk_map_domain. K& V& s@ f@) (= (pervasive.map.Map.dom.?
       K& V& (pervasive.set.Set.mk_map.? K& V& s@ (Poly%fun%1. f@))
      ) s@
    ))
    :pattern ((ens%pervasive.set.axiom_mk_map_domain. K& V& s@ f@))
 )))
 (axiom (forall ((K& Type) (V& Type) (s$ Poly) (f$ Fun)) (!
    (=>
     (and
      (has_type s$ (TYPE%pervasive.set.Set. K&))
      (has_type (Poly%fun%1. f$) (TYPE%fun%1. K& V&))
     )
     (= (pervasive.map.Map.dom.? K& V& (pervasive.set.Set.mk_map.? K& V& s$ (Poly%fun%1. f$)))
      s$
    ))
    :pattern ((pervasive.map.Map.dom.? K& V& (pervasive.set.Set.mk_map.? K& V& s$ (Poly%fun%1.
        f$
 )))))))

 ;; Function-Axioms crate::pervasive::set::axiom_mk_map_index
 (declare-fun req%pervasive.set.axiom_mk_map_index. (Type Type Poly Fun Poly) Bool)
 (axiom (forall ((K& Type) (V& Type) (s@ Poly) (f@ Fun) (key@ Poly)) (!
    (= (req%pervasive.set.axiom_mk_map_index. K& V& s@ f@ key@) (axiom_location ("failed precondition")
      (pervasive.set.Set.contains.? K& s@ key@)
    ))
    :pattern ((req%pervasive.set.axiom_mk_map_index. K& V& s@ f@ key@))
 )))
 (declare-fun ens%pervasive.set.axiom_mk_map_index. (Type Type Poly Fun Poly) Bool)
 (axiom (forall ((K& Type) (V& Type) (s@ Poly) (f@ Fun) (key@ Poly)) (!
    (= (ens%pervasive.set.axiom_mk_map_index. K& V& s@ f@ key@) (= (pervasive.map.Map.index.?
       K& V& (pervasive.set.Set.mk_map.? K& V& s@ (Poly%fun%1. f@)) key@
      ) (apply Poly f@ key@)
    ))
    :pattern ((ens%pervasive.set.axiom_mk_map_index. K& V& s@ f@ key@))
 )))
 (axiom (forall ((K& Type) (V& Type) (s$ Poly) (f$ Fun) (key$ Poly)) (!
    (=>
     (and
      (has_type s$ (TYPE%pervasive.set.Set. K&))
      (has_type (Poly%fun%1. f$) (TYPE%fun%1. K& V&))
      (has_type key$ K&)
     )
     (=>
      (pervasive.set.Set.contains.? K& s$ key$)
      (= (pervasive.map.Map.index.? K& V& (pervasive.set.Set.mk_map.? K& V& s$ (Poly%fun%1.
          f$
         )
        ) key$
       ) (apply Poly f$ key$)
    )))
    :pattern ((pervasive.map.Map.index.? K& V& (pervasive.set.Set.mk_map.? K& V& s$ (Poly%fun%1.
        f$
       )
      ) key$
 )))))

 ;; Function-Axioms crate::pervasive::set::axiom_set_empty_finite
 (declare-fun ens%pervasive.set.axiom_set_empty_finite. (Type) Bool)
 (axiom (forall ((A& Type)) (!
    (= (ens%pervasive.set.axiom_set_empty_finite. A&) (pervasive.set.Set.finite.? A& (pervasive.set.Set.empty.?
       A&
    )))
    :pattern ((ens%pervasive.set.axiom_set_empty_finite. A&))
 )))
 (axiom (forall ((A& Type)) (!
    (pervasive.set.Set.finite.? A& (pervasive.set.Set.empty.? A&))
    :pattern ((pervasive.set.Set.finite.? A& (pervasive.set.Set.empty.? A&)))
 )))

 ;; Function-Axioms crate::pervasive::set::axiom_set_insert_finite
 (declare-fun req%pervasive.set.axiom_set_insert_finite. (Type Poly Poly) Bool)
 (axiom (forall ((A& Type) (s@ Poly) (a@ Poly)) (!
    (= (req%pervasive.set.axiom_set_insert_finite. A& s@ a@) (axiom_location ("failed precondition")
      (pervasive.set.Set.finite.? A& s@)
    ))
    :pattern ((req%pervasive.set.axiom_set_insert_finite. A& s@ a@))
 )))
 (declare-fun ens%pervasive.set.axiom_set_insert_finite. (Type Poly Poly) Bool)
 (axiom (forall ((A& Type) (s@ Poly) (a@ Poly)) (!
    (= (ens%pervasive.set.axiom_set_insert_finite. A& s@ a@) (pervasive.set.Set.finite.?
      A& (pervasive.set.Set.insert.? A& s@ a@)
    ))
    :pattern ((ens%pervasive.set.axiom_set_insert_finite. A& s@ a@))
 )))
 (axiom (forall ((A& Type) (s$ Poly) (a$ Poly)) (!
    (=>
     (and
      (has_type s$ (TYPE%pervasive.set.Set. A&))
      (has_type a$ A&)
     )
     (=>
      (pervasive.set.Set.finite.? A& s$)
      (pervasive.set.Set.finite.? A& (pervasive.set.Set.insert.? A& s$ a$))
    ))
    :pattern ((pervasive.set.Set.finite.? A& (pervasive.set.Set.insert.? A& s$ a$)))
 )))

 ;; Function-Axioms crate::pervasive::set::axiom_set_remove_finite
 (declare-fun req%pervasive.set.axiom_set_remove_finite. (Type Poly Poly) Bool)
 (axiom (forall ((A& Type) (s@ Poly) (a@ Poly)) (!
    (= (req%pervasive.set.axiom_set_remove_finite. A& s@ a@) (axiom_location ("failed precondition")
      (pervasive.set.Set.finite.? A& s@)
    ))
    :pattern ((req%pervasive.set.axiom_set_remove_finite. A& s@ a@))
 )))
 (declare-fun ens%pervasive.set.axiom_set_remove_finite. (Type Poly Poly) Bool)
 (axiom (forall ((A& Type) (s@ Poly) (a@ Poly)) (!
    (= (ens%pervasive.set.axiom_set_remove_finite. A& s@ a@) (pervasive.set.Set.finite.?
      A& (pervasive.set.Set.remove.? A& s@ a@)
    ))
    :pattern ((ens%pervasive.set.axiom_set_remove_finite. A& s@ a@))
 )))
 (axiom (forall ((A& Type) (s$ Poly) (a$ Poly)) (!
    (=>
     (and
      (has_type s$ (TYPE%pervasive.set.Set. A&))
      (has_type a$ A&)
     )
     (=>
      (pervasive.set.Set.finite.? A& s$)
      (pervasive.set.Set.finite.? A& (pervasive.set.Set.remove.? A& s$ a$))
    ))
    :pattern ((pervasive.set.Set.finite.? A& (pervasive.set.Set.remove.? A& s$ a$)))
 )))

 ;; Function-Axioms crate::pervasive::set::axiom_set_union_finite
 (declare-fun req%pervasive.set.axiom_set_union_finite. (Type Poly Poly) Bool)
 (axiom (forall ((A& Type) (s1@ Poly) (s2@ Poly)) (!
    (= (req%pervasive.set.axiom_set_union_finite. A& s1@ s2@) (and
      (axiom_location ("failed precondition") (pervasive.set.Set.finite.? A& s1@))
      (axiom_location ("failed precondition") (pervasive.set.Set.finite.? A& s2@))
    ))
    :pattern ((req%pervasive.set.axiom_set_union_finite. A& s1@ s2@))
 )))
 (declare-fun ens%pervasive.set.axiom_set_union_finite. (Type Poly Poly) Bool)
 (axiom (forall ((A& Type) (s1@ Poly) (s2@ Poly)) (!
    (= (ens%pervasive.set.axiom_set_union_finite. A& s1@ s2@) (pervasive.set.Set.finite.?
      A& (pervasive.set.Set.union.? A& s1@ s2@)
    ))
    :pattern ((ens%pervasive.set.axiom_set_union_finite. A& s1@ s2@))
 )))
 (axiom (forall ((A& Type) (s1$ Poly) (s2$ Poly)) (!
    (=>
     (and
      (has_type s1$ (TYPE%pervasive.set.Set. A&))
      (has_type s2$ (TYPE%pervasive.set.Set. A&))
     )
     (=>
      (and
       (pervasive.set.Set.finite.? A& s1$)
       (pervasive.set.Set.finite.? A& s2$)
      )
      (pervasive.set.Set.finite.? A& (pervasive.set.Set.union.? A& s1$ s2$))
    ))
    :pattern ((pervasive.set.Set.finite.? A& (pervasive.set.Set.union.? A& s1$ s2$)))
 )))

 ;; Function-Axioms crate::pervasive::set::axiom_set_intersect_finite
 (declare-fun req%pervasive.set.axiom_set_intersect_finite. (Type Poly Poly) Bool)
 (axiom (forall ((A& Type) (s1@ Poly) (s2@ Poly)) (!
    (= (req%pervasive.set.axiom_set_intersect_finite. A& s1@ s2@) (axiom_location ("failed precondition")
      (or
       (pervasive.set.Set.finite.? A& s1@)
       (pervasive.set.Set.finite.? A& s2@)
    )))
    :pattern ((req%pervasive.set.axiom_set_intersect_finite. A& s1@ s2@))
 )))
 (declare-fun ens%pervasive.set.axiom_set_intersect_finite. (Type Poly Poly) Bool)
 (axiom (forall ((A& Type) (s1@ Poly) (s2@ Poly)) (!
    (= (ens%pervasive.set.axiom_set_intersect_finite. A& s1@ s2@) (pervasive.set.Set.finite.?
      A& (pervasive.set.Set.intersect.? A& s1@ s2@)
    ))
    :pattern ((ens%pervasive.set.axiom_set_intersect_finite. A& s1@ s2@))
 )))
 (axiom (forall ((A& Type) (s1$ Poly) (s2$ Poly)) (!
    (=>
     (and
      (has_type s1$ (TYPE%pervasive.set.Set. A&))
      (has_type s2$ (TYPE%pervasive.set.Set. A&))
     )
     (=>
      (or
       (pervasive.set.Set.finite.? A& s1$)
       (pervasive.set.Set.finite.? A& s2$)
      )
      (pervasive.set.Set.finite.? A& (pervasive.set.Set.intersect.? A& s1$ s2$))
    ))
    :pattern ((pervasive.set.Set.finite.? A& (pervasive.set.Set.intersect.? A& s1$ s2$)))
 )))

 ;; Function-Axioms crate::pervasive::set::axiom_set_difference_finite
 (declare-fun req%pervasive.set.axiom_set_difference_finite. (Type Poly Poly) Bool)
 (axiom (forall ((A& Type) (s1@ Poly) (s2@ Poly)) (!
    (= (req%pervasive.set.axiom_set_difference_finite. A& s1@ s2@) (axiom_location ("failed precondition")
      (pervasive.set.Set.finite.? A& s1@)
    ))
    :pattern ((req%pervasive.set.axiom_set_difference_finite. A& s1@ s2@))
 )))
 (declare-fun ens%pervasive.set.axiom_set_difference_finite. (Type Poly Poly) Bool)
 (axiom (forall ((A& Type) (s1@ Poly) (s2@ Poly)) (!
    (= (ens%pervasive.set.axiom_set_difference_finite. A& s1@ s2@) (pervasive.set.Set.finite.?
      A& (pervasive.set.Set.difference.? A& s1@ s2@)
    ))
    :pattern ((ens%pervasive.set.axiom_set_difference_finite. A& s1@ s2@))
 )))
 (axiom (forall ((A& Type) (s1$ Poly) (s2$ Poly)) (!
    (=>
     (and
      (has_type s1$ (TYPE%pervasive.set.Set. A&))
      (has_type s2$ (TYPE%pervasive.set.Set. A&))
     )
     (=>
      (pervasive.set.Set.finite.? A& s1$)
      (pervasive.set.Set.finite.? A& (pervasive.set.Set.difference.? A& s1$ s2$))
    ))
    :pattern ((pervasive.set.Set.finite.? A& (pervasive.set.Set.difference.? A& s1$ s2$)))
 )))

 ;; Function-Axioms crate::pervasive::set::axiom_set_choose_finite
 (declare-fun req%pervasive.set.axiom_set_choose_finite. (Type Poly) Bool)
 (axiom (forall ((A& Type) (s@ Poly)) (!
    (= (req%pervasive.set.axiom_set_choose_finite. A& s@) (axiom_location ("failed precondition")
      (not (pervasive.set.Set.finite.? A& s@))
    ))
    :pattern ((req%pervasive.set.axiom_set_choose_finite. A& s@))
 )))
 (declare-fun ens%pervasive.set.axiom_set_choose_finite. (Type Poly) Bool)
 (axiom (forall ((A& Type) (s@ Poly)) (!
    (= (ens%pervasive.set.axiom_set_choose_finite. A& s@) (pervasive.set.Set.contains.?
      A& s@ (pervasive.set.Set.choose.? A& s@)
    ))
    :pattern ((ens%pervasive.set.axiom_set_choose_finite. A& s@))
 )))
 (axiom (forall ((A& Type) (s$ Poly)) (!
    (=>
     (has_type s$ (TYPE%pervasive.set.Set. A&))
     (=>
      (not (pervasive.set.Set.finite.? A& s$))
      (pervasive.set.Set.contains.? A& s$ (pervasive.set.Set.choose.? A& s$))
    ))
    :pattern ((pervasive.set.Set.contains.? A& s$ (pervasive.set.Set.choose.? A& s$)))
 )))

 ;; Function-Axioms crate::pervasive::set::axiom_set_empty_len
 (declare-fun ens%pervasive.set.axiom_set_empty_len. (Type) Bool)
 (axiom (forall ((A& Type)) (!
    (= (ens%pervasive.set.axiom_set_empty_len. A&) (= (pervasive.set.Set.len.? A& (pervasive.set.Set.empty.?
        A&
       )
      ) 0
    ))
    :pattern ((ens%pervasive.set.axiom_set_empty_len. A&))
 )))
 (axiom (forall ((A& Type)) (!
    (= (pervasive.set.Set.len.? A& (pervasive.set.Set.empty.? A&)) 0)
    :pattern ((pervasive.set.Set.len.? A& (pervasive.set.Set.empty.? A&)))
 )))

 ;; Function-Axioms crate::pervasive::set::axiom_set_insert_len
 (declare-fun req%pervasive.set.axiom_set_insert_len. (Type Poly Poly) Bool)
 (axiom (forall ((A& Type) (s@ Poly) (a@ Poly)) (!
    (= (req%pervasive.set.axiom_set_insert_len. A& s@ a@) (axiom_location ("failed precondition")
      (pervasive.set.Set.finite.? A& s@)
    ))
    :pattern ((req%pervasive.set.axiom_set_insert_len. A& s@ a@))
 )))
 (declare-fun ens%pervasive.set.axiom_set_insert_len. (Type Poly Poly) Bool)
 (axiom (forall ((A& Type) (s@ Poly) (a@ Poly)) (!
    (= (ens%pervasive.set.axiom_set_insert_len. A& s@ a@) (= (pervasive.set.Set.len.? A&
       (pervasive.set.Set.insert.? A& s@ a@)
      ) (nClip (+ (pervasive.set.Set.len.? A& s@) (ite
         (pervasive.set.Set.contains.? A& s@ a@)
         0
         1
    )))))
    :pattern ((ens%pervasive.set.axiom_set_insert_len. A& s@ a@))
 )))
 (axiom (forall ((A& Type) (s$ Poly) (a$ Poly)) (!
    (=>
     (and
      (has_type s$ (TYPE%pervasive.set.Set. A&))
      (has_type a$ A&)
     )
     (=>
      (pervasive.set.Set.finite.? A& s$)
      (= (pervasive.set.Set.len.? A& (pervasive.set.Set.insert.? A& s$ a$)) (nClip (+ (pervasive.set.Set.len.?
          A& s$
         ) (ite
          (pervasive.set.Set.contains.? A& s$ a$)
          0
          1
    ))))))
    :pattern ((pervasive.set.Set.len.? A& (pervasive.set.Set.insert.? A& s$ a$)))
 )))

 ;; Function-Axioms crate::pervasive::set::axiom_set_remove_len
 (declare-fun req%pervasive.set.axiom_set_remove_len. (Type Poly Poly) Bool)
 (axiom (forall ((A& Type) (s@ Poly) (a@ Poly)) (!
    (= (req%pervasive.set.axiom_set_remove_len. A& s@ a@) (axiom_location ("failed precondition")
      (pervasive.set.Set.finite.? A& s@)
    ))
    :pattern ((req%pervasive.set.axiom_set_remove_len. A& s@ a@))
 )))
 (declare-fun ens%pervasive.set.axiom_set_remove_len. (Type Poly Poly) Bool)
 (axiom (forall ((A& Type) (s@ Poly) (a@ Poly)) (!
    (= (ens%pervasive.set.axiom_set_remove_len. A& s@ a@) (= (pervasive.set.Set.len.? A&
       s@
      ) (nClip (+ (pervasive.set.Set.len.? A& (pervasive.set.Set.remove.? A& s@ a@)) (ite
         (pervasive.set.Set.contains.? A& s@ a@)
         1
         0
    )))))
    :pattern ((ens%pervasive.set.axiom_set_remove_len. A& s@ a@))
 )))
 (axiom (forall ((A& Type) (s$ Poly) (a$ Poly)) (!
    (=>
     (and
      (has_type s$ (TYPE%pervasive.set.Set. A&))
      (has_type a$ A&)
     )
     (=>
      (pervasive.set.Set.finite.? A& s$)
      (= (pervasive.set.Set.len.? A& s$) (nClip (+ (pervasive.set.Set.len.? A& (pervasive.set.Set.remove.?
           A& s$ a$
          )
         ) (ite
          (pervasive.set.Set.contains.? A& s$ a$)
          1
          0
    ))))))
    :pattern ((pervasive.set.Set.len.? A& (pervasive.set.Set.remove.? A& s$ a$)))
 )))

 ;; Function-Axioms crate::pervasive::set::axiom_set_choose_len
 (declare-fun req%pervasive.set.axiom_set_choose_len. (Type Poly) Bool)
 (axiom (forall ((A& Type) (s@ Poly)) (!
    (= (req%pervasive.set.axiom_set_choose_len. A& s@) (and
      (axiom_location ("failed precondition") (pervasive.set.Set.finite.? A& s@))
      (axiom_location ("failed precondition") (not (= (pervasive.set.Set.len.? A& s@) 0)))
    ))
    :pattern ((req%pervasive.set.axiom_set_choose_len. A& s@))
 )))
 (declare-fun ens%pervasive.set.axiom_set_choose_len. (Type Poly) Bool)
 (axiom (forall ((A& Type) (s@ Poly)) (!
    (= (ens%pervasive.set.axiom_set_choose_len. A& s@) (pervasive.set.Set.contains.? A&
      s@ (pervasive.set.Set.choose.? A& s@)
    ))
    :pattern ((ens%pervasive.set.axiom_set_choose_len. A& s@))
 )))
 (axiom (forall ((A& Type) (s$ Poly)) (!
    (=>
     (has_type s$ (TYPE%pervasive.set.Set. A&))
     (=>
      (and
       (pervasive.set.Set.finite.? A& s$)
       (not (= (pervasive.set.Set.len.? A& s$) 0))
      )
      (pervasive.set.Set.contains.? A& s$ (pervasive.set.Set.choose.? A& s$))
    ))
    :pattern ((pervasive.set.Set.len.? A& s$) (pervasive.set.Set.contains.? A& s$ (pervasive.set.Set.choose.?
       A& s$
 ))))))

 ;; Function-Axioms crate::pervasive::arbitrary
 (axiom (forall ((A& Type)) (!
    (has_type (pervasive.arbitrary.? A&) A&)
    :pattern ((pervasive.arbitrary.? A&))
 )))

 ;; Function-Axioms crate::pervasive::assert
 (declare-fun req%pervasive.assert. (Bool) Bool)
 (axiom (forall ((b@ Bool)) (!
    (= (req%pervasive.assert. b@) b@)
    :pattern ((req%pervasive.assert. b@))
 )))
 (declare-fun ens%pervasive.assert. (Bool) Bool)
 (axiom (forall ((b@ Bool)) (!
    (= (ens%pervasive.assert. b@) b@)
    :pattern ((ens%pervasive.assert. b@))
 )))

 ;; Function-Axioms crate::pervasive::assume
 (declare-fun ens%pervasive.assume. (Bool) Bool)
 (axiom (forall ((b@ Bool)) (!
    (= (ens%pervasive.assume. b@) b@)
    :pattern ((ens%pervasive.assume. b@))
 )))

 ;; Function-Axioms crate::spec::strictly_decreasing
 (axiom (fuel_bool_default fuel%spec.strictly_decreasing.))
 (axiom (=>
   (fuel_bool fuel%spec.strictly_decreasing.)
   (forall ((s@ Poly)) (!
     (= (spec.strictly_decreasing.? s@) (forall ((i$ Poly) (j$ Poly)) (!
        (=>
         (and
          (has_type i$ NAT)
          (has_type j$ NAT)
         )
         (=>
          (and
           (< (%I i$) (%I j$))
           (< (%I j$) (pervasive.seq.Seq.len.? NAT s@))
          )
          (> (%I (pervasive.seq.Seq.index.? NAT s@ i$)) (%I (pervasive.seq.Seq.index.? NAT s@
             j$
        )))))
        :pattern ((pervasive.seq.Seq.index.? NAT s@ i$) (pervasive.seq.Seq.index.? NAT s@ j$))
     )))
     :pattern ((spec.strictly_decreasing.? s@))
 ))))

 ;; Function-Axioms crate::spec::Arch::inv
 (axiom (fuel_bool_default fuel%spec.Arch.inv.))
 (axiom (=>
   (fuel_bool fuel%spec.Arch.inv.)
   (forall ((self@ Poly)) (!
     (= (spec.Arch.inv.? self@) (forall ((i$ Poly)) (!
        (=>
         (has_type i$ NAT)
         (=>
          (< (%I i$) (pervasive.seq.Seq.len.? TYPE%spec.ArchLayer. (Poly%pervasive.seq.Seq<spec.ArchLayer.>.
             (spec.Arch./Arch/layers (%Poly%spec.Arch. self@))
          )))
          (and
           (and
            (> (spec.ArchLayer./ArchLayer/entry_size (%Poly%spec.ArchLayer. (pervasive.seq.Seq.index.?
                TYPE%spec.ArchLayer. (Poly%pervasive.seq.Seq<spec.ArchLayer.>. (spec.Arch./Arch/layers
                  (%Poly%spec.Arch. self@)
                 )
                ) i$
              ))
             ) 0
            )
            (> (spec.ArchLayer./ArchLayer/num_entries (%Poly%spec.ArchLayer. (pervasive.seq.Seq.index.?
                TYPE%spec.ArchLayer. (Poly%pervasive.seq.Seq<spec.ArchLayer.>. (spec.Arch./Arch/layers
                  (%Poly%spec.Arch. self@)
                 )
                ) i$
              ))
             ) 0
           ))
           (=>
            (< (nClip (+ (%I i$) 1)) (pervasive.seq.Seq.len.? TYPE%spec.ArchLayer. (Poly%pervasive.seq.Seq<spec.ArchLayer.>.
               (spec.Arch./Arch/layers (%Poly%spec.Arch. self@))
            )))
            (= (spec.ArchLayer./ArchLayer/entry_size (%Poly%spec.ArchLayer. (pervasive.seq.Seq.index.?
                TYPE%spec.ArchLayer. (Poly%pervasive.seq.Seq<spec.ArchLayer.>. (spec.Arch./Arch/layers
                  (%Poly%spec.Arch. self@)
                 )
                ) i$
              ))
             ) (nClip (* (spec.ArchLayer./ArchLayer/entry_size (%Poly%spec.ArchLayer. (pervasive.seq.Seq.index.?
                  TYPE%spec.ArchLayer. (Poly%pervasive.seq.Seq<spec.ArchLayer.>. (spec.Arch./Arch/layers
                    (%Poly%spec.Arch. self@)
                   )
                  ) (I (+ (%I i$) 1))
                ))
               ) (spec.ArchLayer./ArchLayer/num_entries (%Poly%spec.ArchLayer. (pervasive.seq.Seq.index.?
                  TYPE%spec.ArchLayer. (Poly%pervasive.seq.Seq<spec.ArchLayer.>. (spec.Arch./Arch/layers
                    (%Poly%spec.Arch. self@)
                   )
                  ) (I (+ (%I i$) 1))
        ))))))))))
        :pattern ((spec.ArchLayer./ArchLayer/entry_size (%Poly%spec.ArchLayer. (pervasive.seq.Seq.index.?
            TYPE%spec.ArchLayer. (Poly%pervasive.seq.Seq<spec.ArchLayer.>. (spec.Arch./Arch/layers
              (%Poly%spec.Arch. self@)
             )
            ) i$
        ))))
        :pattern ((spec.ArchLayer./ArchLayer/num_entries (%Poly%spec.ArchLayer. (pervasive.seq.Seq.index.?
            TYPE%spec.ArchLayer. (Poly%pervasive.seq.Seq<spec.ArchLayer.>. (spec.Arch./Arch/layers
              (%Poly%spec.Arch. self@)
             )
            ) i$
     )))))))
     :pattern ((spec.Arch.inv.? self@))
 ))))

 ;; Function-Axioms crate::spec::Arch::contains_entry_size
 (axiom (fuel_bool_default fuel%spec.Arch.contains_entry_size.))
 (axiom (=>
   (fuel_bool fuel%spec.Arch.contains_entry_size.)
   (forall ((self@ Poly) (entry_size@ Poly)) (!
     (= (spec.Arch.contains_entry_size.? self@ entry_size@) (exists ((i$ Poly)) (!
        (and
         (has_type i$ NAT)
         (= (spec.ArchLayer./ArchLayer/entry_size (%Poly%spec.ArchLayer. (pervasive.seq.Seq.index.?
             TYPE%spec.ArchLayer. (Poly%pervasive.seq.Seq<spec.ArchLayer.>. (spec.Arch./Arch/layers
               (%Poly%spec.Arch. self@)
              )
             ) i$
           ))
          ) (%I entry_size@)
        ))
        :pattern ((spec.ArchLayer./ArchLayer/entry_size (%Poly%spec.ArchLayer. (pervasive.seq.Seq.index.?
            TYPE%spec.ArchLayer. (Poly%pervasive.seq.Seq<spec.ArchLayer.>. (spec.Arch./Arch/layers
              (%Poly%spec.Arch. self@)
             )
            ) i$
     )))))))
     :pattern ((spec.Arch.contains_entry_size.? self@ entry_size@))
 ))))

 ;; Function-Axioms crate::spec::aligned
 (axiom (fuel_bool_default fuel%spec.aligned.))
 (axiom (=>
   (fuel_bool fuel%spec.aligned.)
   (forall ((addr@ Poly) (size@ Poly)) (!
     (= (spec.aligned.? addr@ size@) (= (mod (%I addr@) (%I size@)) 0))
     :pattern ((spec.aligned.? addr@ size@))
 ))))

 ;; Function-Axioms crate::spec::overlap
 (axiom (fuel_bool_default fuel%spec.overlap.))
 (axiom (=>
   (fuel_bool fuel%spec.overlap.)
   (forall ((region1@ Poly) (region2@ Poly)) (!
     (= (spec.overlap.? region1@ region2@) (ite
       (<= (spec.MemRegion./MemRegion/base (%Poly%spec.MemRegion. region1@)) (spec.MemRegion./MemRegion/base
         (%Poly%spec.MemRegion. region2@)
       ))
       (< (spec.MemRegion./MemRegion/base (%Poly%spec.MemRegion. region2@)) (nClip (+ (spec.MemRegion./MemRegion/base
           (%Poly%spec.MemRegion. region1@)
          ) (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. region1@))
       )))
       (< (spec.MemRegion./MemRegion/base (%Poly%spec.MemRegion. region1@)) (nClip (+ (spec.MemRegion./MemRegion/base
           (%Poly%spec.MemRegion. region2@)
          ) (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. region2@))
     )))))
     :pattern ((spec.overlap.? region1@ region2@))
 ))))

 ;; Function-Axioms crate::spec::PageTableContents::ext_equal
 (axiom (fuel_bool_default fuel%spec.PageTableContents.ext_equal.))
 (axiom (=>
   (fuel_bool fuel%spec.PageTableContents.ext_equal.)
   (forall ((self@ Poly) (pt2@ Poly)) (!
     (= (spec.PageTableContents.ext_equal.? self@ pt2@) (pervasive.map.Map.ext_equal.? NAT
       TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
         (%Poly%spec.PageTableContents. self@)
        )
       ) (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
         (%Poly%spec.PageTableContents. pt2@)
     ))))
     :pattern ((spec.PageTableContents.ext_equal.? self@ pt2@))
 ))))

 ;; Function-Axioms crate::spec::PageTableContents::inv
 (axiom (fuel_bool_default fuel%spec.PageTableContents.inv.))
 (axiom (=>
   (fuel_bool fuel%spec.PageTableContents.inv.)
   (forall ((self@ Poly)) (!
     (= (spec.PageTableContents.inv.? self@) (and
       (and
        (spec.Arch.inv.? (Poly%spec.Arch. (spec.PageTableContents./PageTableContents/arch (%Poly%spec.PageTableContents.
            self@
        ))))
        (forall ((va$ Poly)) (!
          (=>
           (has_type va$ NAT)
           (=>
            (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
              (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
                (%Poly%spec.PageTableContents. self@)
              ))
             ) va$
            )
            (and
             (spec.aligned.? va$ (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
                  NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
                    (%Poly%spec.PageTableContents. self@)
                   )
                  ) va$
             )))))
             (spec.aligned.? (I (spec.MemRegion./MemRegion/base (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
                  NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
                    (%Poly%spec.PageTableContents. self@)
                   )
                  ) va$
               )))
              ) (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
                  NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
                    (%Poly%spec.PageTableContents. self@)
                   )
                  ) va$
          ))))))))
          :pattern ((spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
              NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
                (%Poly%spec.PageTableContents. self@)
               )
              ) va$
          ))))
          :pattern ((spec.MemRegion./MemRegion/base (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
              NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
                (%Poly%spec.PageTableContents. self@)
               )
              ) va$
       )))))))
       (forall ((b1$ Poly) (b2$ Poly)) (!
         (=>
          (and
           (has_type b1$ NAT)
           (has_type b2$ NAT)
          )
          (=>
           (and
            (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
              (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
                (%Poly%spec.PageTableContents. self@)
              ))
             ) b1$
            )
            (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
              (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
                (%Poly%spec.PageTableContents. self@)
              ))
             ) b2$
           ))
           (or
            (= b1$ b2$)
            (not (spec.overlap.? (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I b1$) (%I (I (
                   spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (pervasive.map.Map.index.? NAT
                     TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
                       (%Poly%spec.PageTableContents. self@)
                      )
                     ) b1$
               ))))))
              ) (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I b2$) (%I (I (spec.MemRegion./MemRegion/size
                   (%Poly%spec.MemRegion. (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
                      (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. self@))
                     ) b2$
         ))))))))))))
         :pattern ((pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
            (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. self@))
           ) b1$
          ) (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
            (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. self@))
           ) b2$
         ))
         :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
            (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
              (%Poly%spec.PageTableContents. self@)
            ))
           ) b1$
          ) (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
            (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
              (%Poly%spec.PageTableContents. self@)
            ))
           ) b2$
     ))))))
     :pattern ((spec.PageTableContents.inv.? self@))
 ))))

 ;; Function-Axioms crate::spec::PageTableContents::accepted_mapping
 (axiom (fuel_bool_default fuel%spec.PageTableContents.accepted_mapping.))
 (axiom (=>
   (fuel_bool fuel%spec.PageTableContents.accepted_mapping.)
   (forall ((self@ Poly) (base@ Poly) (frame@ Poly)) (!
     (= (spec.PageTableContents.accepted_mapping.? self@ base@ frame@) (and
       (and
        (spec.aligned.? base@ (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. frame@))))
        (spec.aligned.? (I (spec.MemRegion./MemRegion/base (%Poly%spec.MemRegion. frame@)))
         (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. frame@)))
       ))
       (spec.Arch.contains_entry_size.? (Poly%spec.Arch. (spec.PageTableContents./PageTableContents/arch
          (%Poly%spec.PageTableContents. self@)
         )
        ) (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. frame@)))
     )))
     :pattern ((spec.PageTableContents.accepted_mapping.? self@ base@ frame@))
 ))))

 ;; Function-Axioms crate::spec::PageTableContents::valid_mapping
 (axiom (fuel_bool_default fuel%spec.PageTableContents.valid_mapping.))
 (axiom (=>
   (fuel_bool fuel%spec.PageTableContents.valid_mapping.)
   (forall ((self@ Poly) (base@ Poly) (frame@ Poly)) (!
     (= (spec.PageTableContents.valid_mapping.? self@ base@ frame@) (forall ((b$ Poly))
       (!
        (=>
         (has_type b$ NAT)
         (=>
          (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
            (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
              (%Poly%spec.PageTableContents. self@)
            ))
           ) b$
          )
          (not (spec.overlap.? (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I base@) (%I (
                I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. frame@))
             )))
            ) (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I b$) (%I (I (spec.MemRegion./MemRegion/size
                 (%Poly%spec.MemRegion. (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
                    (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. self@))
                   ) b$
        )))))))))))
        :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
           (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
             (%Poly%spec.PageTableContents. self@)
           ))
          ) b$
     )))))
     :pattern ((spec.PageTableContents.valid_mapping.? self@ base@ frame@))
 ))))

 ;; Function-Axioms crate::spec::PageTableContents::map_frame
 (axiom (fuel_bool_default fuel%spec.PageTableContents.map_frame.))
 (axiom (=>
   (fuel_bool fuel%spec.PageTableContents.map_frame.)
   (forall ((self@ Poly) (base@ Poly) (frame@ Poly)) (!
     (= (spec.PageTableContents.map_frame.? self@ base@ frame@) (ite
       (spec.PageTableContents.accepted_mapping.? self@ base@ frame@)
       (ite
        (spec.PageTableContents.valid_mapping.? self@ base@ frame@)
        (pervasive.result.Result./Ok (Poly%spec.PageTableContents. (spec.PageTableContents./PageTableContents
           (%Poly%pervasive.map.Map<nat./spec.MemRegion.>. (pervasive.map.Map.insert.? NAT TYPE%spec.MemRegion.
             (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
               (%Poly%spec.PageTableContents. self@)
              )
             ) base@ frame@
            )
           ) (%Poly%spec.Arch. (Poly%spec.Arch. (spec.PageTableContents./PageTableContents/arch
              (%Poly%spec.PageTableContents. self@)
        ))))))
        (pervasive.result.Result./Err (Poly%tuple%0. (tuple%0./tuple%0)))
       )
       (%Poly%pervasive.result.Result. (pervasive.arbitrary.? (TYPE%pervasive.result.Result.
          TYPE%spec.PageTableContents. TYPE%tuple%0.
     )))))
     :pattern ((spec.PageTableContents.map_frame.? self@ base@ frame@))
 ))))
 (axiom (forall ((self@ Poly) (base@ Poly) (frame@ Poly)) (!
    (=>
     (and
      (has_type self@ TYPE%spec.PageTableContents.)
      (has_type base@ NAT)
      (has_type frame@ TYPE%spec.MemRegion.)
     )
     (has_type (Poly%pervasive.result.Result. (spec.PageTableContents.map_frame.? self@ base@
        frame@
       )
      ) (TYPE%pervasive.result.Result. TYPE%spec.PageTableContents. TYPE%tuple%0.)
    ))
    :pattern ((spec.PageTableContents.map_frame.? self@ base@ frame@))
 )))

 ;; Function-Axioms crate::spec::PageTableContents::map_frame_maps_valid
 (declare-fun req%spec.PageTableContents.map_frame_maps_valid. (spec.PageTableContents.
   Int spec.MemRegion.
  ) Bool
 )
 (axiom (forall ((self@ spec.PageTableContents.) (base@ Int) (frame@ spec.MemRegion.))
   (!
    (= (req%spec.PageTableContents.map_frame_maps_valid. self@ base@ frame@) (and
      (axiom_location ("failed precondition") (spec.PageTableContents.inv.? (Poly%spec.PageTableContents.
         self@
      )))
      (axiom_location ("failed precondition") (spec.PageTableContents.accepted_mapping.?
        (Poly%spec.PageTableContents. self@) (I base@) (Poly%spec.MemRegion. frame@)
      ))
      (axiom_location ("failed precondition") (spec.PageTableContents.valid_mapping.? (Poly%spec.PageTableContents.
         self@
        ) (I base@) (Poly%spec.MemRegion. frame@)
    ))))
    :pattern ((req%spec.PageTableContents.map_frame_maps_valid. self@ base@ frame@))
 )))
 (declare-fun ens%spec.PageTableContents.map_frame_maps_valid. (spec.PageTableContents.
   Int spec.MemRegion.
  ) Bool
 )
 (axiom (forall ((self@ spec.PageTableContents.) (base@ Int) (frame@ spec.MemRegion.))
   (!
    (= (ens%spec.PageTableContents.map_frame_maps_valid. self@ base@ frame@) (is-pervasive.result.Result./Ok
      (spec.PageTableContents.map_frame.? (Poly%spec.PageTableContents. self@) (I base@)
       (Poly%spec.MemRegion. frame@)
    )))
    :pattern ((ens%spec.PageTableContents.map_frame_maps_valid. self@ base@ frame@))
 )))

 ;; Function-Axioms crate::spec::PageTableContents::map_frame_preserves_inv
 (declare-fun req%spec.PageTableContents.map_frame_preserves_inv. (spec.PageTableContents.
   Int spec.MemRegion.
  ) Bool
 )
 (axiom (forall ((self@ spec.PageTableContents.) (base@ Int) (frame@ spec.MemRegion.))
   (!
    (= (req%spec.PageTableContents.map_frame_preserves_inv. self@ base@ frame@) (and
      (axiom_location ("failed precondition") (spec.PageTableContents.inv.? (Poly%spec.PageTableContents.
         self@
      )))
      (axiom_location ("failed precondition") (spec.PageTableContents.accepted_mapping.?
        (Poly%spec.PageTableContents. self@) (I base@) (Poly%spec.MemRegion. frame@)
      ))
      (axiom_location ("failed precondition") (is-pervasive.result.Result./Ok (spec.PageTableContents.map_frame.?
         (Poly%spec.PageTableContents. self@) (I base@) (Poly%spec.MemRegion. frame@)
    )))))
    :pattern ((req%spec.PageTableContents.map_frame_preserves_inv. self@ base@ frame@))
 )))
 (declare-fun ens%spec.PageTableContents.map_frame_preserves_inv. (spec.PageTableContents.
   Int spec.MemRegion.
  ) Bool
 )
 (axiom (forall ((self@ spec.PageTableContents.) (base@ Int) (frame@ spec.MemRegion.))
   (!
    (= (ens%spec.PageTableContents.map_frame_preserves_inv. self@ base@ frame@) (spec.PageTableContents.inv.?
      (pervasive.result.Result./Ok/_0 (%Poly%pervasive.result.Result. (Poly%pervasive.result.Result.
         (spec.PageTableContents.map_frame.? (Poly%spec.PageTableContents. self@) (I base@)
          (Poly%spec.MemRegion. frame@)
    ))))))
    :pattern ((ens%spec.PageTableContents.map_frame_preserves_inv. self@ base@ frame@))
 )))

 ;; Function-Axioms crate::spec::PageTableContents::lemma_overlap_IMP_equal_base
 (declare-fun req%spec.PageTableContents.lemma_overlap_IMP_equal_base. (spec.PageTableContents.
   Int Int Int
  ) Bool
 )
 (axiom (forall ((self@ spec.PageTableContents.) (va1@ Int) (base@ Int) (size@ Int))
   (!
    (= (req%spec.PageTableContents.lemma_overlap_IMP_equal_base. self@ va1@ base@ size@)
     (and
      (axiom_location ("failed precondition") (spec.PageTableContents.inv.? (Poly%spec.PageTableContents.
         self@
      )))
      (axiom_location ("failed precondition") (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.?
         NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
           (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. self@))
         ))
        ) (I va1@)
      ))
      (axiom_location ("failed precondition") (spec.aligned.? (I base@) (I size@)))
      (axiom_location ("failed precondition") (= size@ (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion.
          (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
            (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
               self@
            )))
           ) (I va1@)
      )))))
      (axiom_location ("failed precondition") (> size@ 0))
      (axiom_location ("failed precondition") (spec.overlap.? (Poly%spec.MemRegion. (spec.MemRegion./MemRegion
          (%I (I va1@)) (%I (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
               NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
                 (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. self@))
                )
               ) (I va1@)
         ))))))
        ) (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I base@)) (%I (I size@))))
    ))))
    :pattern ((req%spec.PageTableContents.lemma_overlap_IMP_equal_base. self@ va1@ base@
      size@
 )))))
 (declare-fun ens%spec.PageTableContents.lemma_overlap_IMP_equal_base. (spec.PageTableContents.
   Int Int Int
  ) Bool
 )
 (axiom (forall ((self@ spec.PageTableContents.) (va1@ Int) (base@ Int) (size@ Int))
   (!
    (= (ens%spec.PageTableContents.lemma_overlap_IMP_equal_base. self@ va1@ base@ size@)
     (= va1@ base@)
    )
    :pattern ((ens%spec.PageTableContents.lemma_overlap_IMP_equal_base. self@ va1@ base@
      size@
 )))))

 ;; Function-Axioms crate::spec::PageTableContents::resolve
 (axiom (fuel_bool_default fuel%spec.PageTableContents.resolve.))
 (axiom (=>
   (fuel_bool fuel%spec.PageTableContents.resolve.)
   (forall ((self@ Poly) (vaddr@ Poly)) (!
     (= (spec.PageTableContents.resolve.? self@ vaddr@) (ite
       (exists ((n$ Poly)) (!
         (and
          (has_type n$ NAT)
          (and
           (and
            (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
              (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
                (%Poly%spec.PageTableContents. self@)
              ))
             ) n$
            )
            (<= (%I n$) (%I vaddr@))
           )
           (< (%I vaddr@) (nClip (+ (%I n$) (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion.
                (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
                  (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. self@))
                 ) n$
         ))))))))
         :pattern ((pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
            (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. self@))
           ) n$
       ))))
       (let
        ((n$ (%I (as_type (choose ((n$ Poly)) (!
              (and
               (has_type n$ NAT)
               (and
                (and
                 (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
                   (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
                     (%Poly%spec.PageTableContents. self@)
                   ))
                  ) n$
                 )
                 (<= (%I n$) (%I vaddr@))
                )
                (< (%I vaddr@) (nClip (+ (%I n$) (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion.
                     (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
                       (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. self@))
                      ) n$
              ))))))))
              :pattern ((pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
                 (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. self@))
                ) n$
              ))
             ) n$
            ) NAT
        ))))
        (let
         ((offset$ (nClip (- (%I vaddr@) n$))))
         (nClip (+ (spec.MemRegion./MemRegion/base (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
              NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
                (%Poly%spec.PageTableContents. self@)
               )
              ) (I n$)
            ))
           ) offset$
       ))))
       (%I (pervasive.arbitrary.? NAT))
     ))
     :pattern ((spec.PageTableContents.resolve.? self@ vaddr@))
 ))))
 (axiom (forall ((self@ Poly) (vaddr@ Poly)) (!
    (=>
     (and
      (has_type self@ TYPE%spec.PageTableContents.)
      (has_type vaddr@ NAT)
     )
     (<= 0 (spec.PageTableContents.resolve.? self@ vaddr@))
    )
    :pattern ((spec.PageTableContents.resolve.? self@ vaddr@))
 )))

 ;; Function-Axioms crate::spec::PageTableContents::unmap
 (axiom (fuel_bool_default fuel%spec.PageTableContents.unmap.))
 (axiom (=>
   (fuel_bool fuel%spec.PageTableContents.unmap.)
   (forall ((self@ Poly) (base@ Poly)) (!
     (= (spec.PageTableContents.unmap.? self@ base@) (ite
       (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
         (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
           (%Poly%spec.PageTableContents. self@)
         ))
        ) base@
       )
       (spec.PageTableContents./PageTableContents (%Poly%pervasive.map.Map<nat./spec.MemRegion.>.
         (pervasive.map.Map.remove.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
           (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. self@))
          ) base@
         )
        ) (%Poly%spec.Arch. (Poly%spec.Arch. (spec.PageTableContents./PageTableContents/arch
           (%Poly%spec.PageTableContents. self@)
       ))))
       (%Poly%spec.PageTableContents. (pervasive.arbitrary.? TYPE%spec.PageTableContents.))
     ))
     :pattern ((spec.PageTableContents.unmap.? self@ base@))
 ))))

 ;; Function-Axioms crate::spec::PageTableContents::unmap_preserves_inv
 (declare-fun req%spec.PageTableContents.unmap_preserves_inv. (spec.PageTableContents.
   Int
  ) Bool
 )
 (axiom (forall ((self@ spec.PageTableContents.) (base@ Int)) (!
    (= (req%spec.PageTableContents.unmap_preserves_inv. self@ base@) (and
      (axiom_location ("failed precondition") (spec.PageTableContents.inv.? (Poly%spec.PageTableContents.
         self@
      )))
      (axiom_location ("failed precondition") (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.?
         NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
           (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. self@))
         ))
        ) (I base@)
    ))))
    :pattern ((req%spec.PageTableContents.unmap_preserves_inv. self@ base@))
 )))
 (declare-fun ens%spec.PageTableContents.unmap_preserves_inv. (spec.PageTableContents.
   Int
  ) Bool
 )
 (axiom (forall ((self@ spec.PageTableContents.) (base@ Int)) (!
    (= (ens%spec.PageTableContents.unmap_preserves_inv. self@ base@) (spec.PageTableContents.inv.?
      (Poly%spec.PageTableContents. (spec.PageTableContents.unmap.? (Poly%spec.PageTableContents.
         self@
        ) (I base@)
    ))))
    :pattern ((ens%spec.PageTableContents.unmap_preserves_inv. self@ base@))
 )))

 ;; Function-Axioms crate::spec::Directory::entry_size
 (declare-fun req%spec.Directory.entry_size. (Poly) Bool)
 (axiom (forall ((self@ Poly)) (!
    (= (req%spec.Directory.entry_size. self@) (axiom_location ("recommendation not met")
      (< (spec.Directory./Directory/layer (%Poly%spec.Directory. self@)) (pervasive.seq.Seq.len.?
        TYPE%spec.ArchLayer. (Poly%pervasive.seq.Seq<spec.ArchLayer.>. (spec.Arch./Arch/layers
          (%Poly%spec.Arch. (Poly%spec.Arch. (spec.Directory./Directory/arch (%Poly%spec.Directory.
              self@
    ))))))))))
    :pattern ((req%spec.Directory.entry_size. self@))
 )))
 (axiom (fuel_bool_default fuel%spec.Directory.entry_size.))
 (axiom (=>
   (fuel_bool fuel%spec.Directory.entry_size.)
   (forall ((self@ Poly)) (!
     (= (spec.Directory.entry_size.? self@) (spec.ArchLayer./ArchLayer/entry_size (%Poly%spec.ArchLayer.
        (pervasive.seq.Seq.index.? TYPE%spec.ArchLayer. (Poly%pervasive.seq.Seq<spec.ArchLayer.>.
          (spec.Arch./Arch/layers (%Poly%spec.Arch. (Poly%spec.Arch. (spec.Directory./Directory/arch
              (%Poly%spec.Directory. self@)
          ))))
         ) (I (spec.Directory./Directory/layer (%Poly%spec.Directory. self@)))
     ))))
     :pattern ((spec.Directory.entry_size.? self@))
 ))))
 (axiom (forall ((self@ Poly)) (!
    (=>
     (has_type self@ TYPE%spec.Directory.)
     (<= 0 (spec.Directory.entry_size.? self@))
    )
    :pattern ((spec.Directory.entry_size.? self@))
 )))

 ;; Function-Axioms crate::spec::Directory::num_entries
 (declare-fun req%spec.Directory.num_entries. (Poly) Bool)
 (axiom (forall ((self@ Poly)) (!
    (= (req%spec.Directory.num_entries. self@) (axiom_location ("recommendation not met")
      (< (spec.Directory./Directory/layer (%Poly%spec.Directory. self@)) (pervasive.seq.Seq.len.?
        TYPE%spec.ArchLayer. (Poly%pervasive.seq.Seq<spec.ArchLayer.>. (spec.Arch./Arch/layers
          (%Poly%spec.Arch. (Poly%spec.Arch. (spec.Directory./Directory/arch (%Poly%spec.Directory.
              self@
    ))))))))))
    :pattern ((req%spec.Directory.num_entries. self@))
 )))
 (axiom (fuel_bool_default fuel%spec.Directory.num_entries.))
 (axiom (=>
   (fuel_bool fuel%spec.Directory.num_entries.)
   (forall ((self@ Poly)) (!
     (= (spec.Directory.num_entries.? self@) (spec.ArchLayer./ArchLayer/num_entries (%Poly%spec.ArchLayer.
        (pervasive.seq.Seq.index.? TYPE%spec.ArchLayer. (Poly%pervasive.seq.Seq<spec.ArchLayer.>.
          (spec.Arch./Arch/layers (%Poly%spec.Arch. (Poly%spec.Arch. (spec.Directory./Directory/arch
              (%Poly%spec.Directory. self@)
          ))))
         ) (I (spec.Directory./Directory/layer (%Poly%spec.Directory. self@)))
     ))))
     :pattern ((spec.Directory.num_entries.? self@))
 ))))
 (axiom (forall ((self@ Poly)) (!
    (=>
     (has_type self@ TYPE%spec.Directory.)
     (<= 0 (spec.Directory.num_entries.? self@))
    )
    :pattern ((spec.Directory.num_entries.? self@))
 )))

 ;; Function-Axioms crate::spec::Directory::well_formed
 (axiom (fuel_bool_default fuel%spec.Directory.well_formed.))
 (axiom (=>
   (fuel_bool fuel%spec.Directory.well_formed.)
   (forall ((self@ Poly)) (!
     (= (spec.Directory.well_formed.? self@) (and
       (and
        (and
         (spec.Arch.inv.? (Poly%spec.Arch. (spec.Directory./Directory/arch (%Poly%spec.Directory.
             self@
         ))))
         (spec.aligned.? (I (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. self@)))
          (I (nClip (* (spec.Directory.entry_size.? self@) (spec.Directory.num_entries.? self@))))
        ))
        (< (spec.Directory./Directory/layer (%Poly%spec.Directory. self@)) (pervasive.seq.Seq.len.?
          TYPE%spec.ArchLayer. (Poly%pervasive.seq.Seq<spec.ArchLayer.>. (spec.Arch./Arch/layers
            (%Poly%spec.Arch. (Poly%spec.Arch. (spec.Directory./Directory/arch (%Poly%spec.Directory.
                self@
       )))))))))
       (= (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
          (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
         )
        ) (spec.Directory.num_entries.? self@)
     )))
     :pattern ((spec.Directory.well_formed.? self@))
 ))))

 ;; Function-Axioms crate::spec::Directory::arch_layer
 (declare-fun req%spec.Directory.arch_layer. (Poly) Bool)
 (axiom (forall ((self@ Poly)) (!
    (= (req%spec.Directory.arch_layer. self@) (axiom_location ("recommendation not met")
      (spec.Directory.well_formed.? self@)
    ))
    :pattern ((req%spec.Directory.arch_layer. self@))
 )))
 (axiom (fuel_bool_default fuel%spec.Directory.arch_layer.))
 (axiom (=>
   (fuel_bool fuel%spec.Directory.arch_layer.)
   (forall ((self@ Poly)) (!
     (= (spec.Directory.arch_layer.? self@) (%Poly%spec.ArchLayer. (pervasive.seq.Seq.index.?
        TYPE%spec.ArchLayer. (Poly%pervasive.seq.Seq<spec.ArchLayer.>. (spec.Arch./Arch/layers
          (%Poly%spec.Arch. (Poly%spec.Arch. (spec.Directory./Directory/arch (%Poly%spec.Directory.
              self@
         )))))
        ) (I (spec.Directory./Directory/layer (%Poly%spec.Directory. self@)))
     )))
     :pattern ((spec.Directory.arch_layer.? self@))
 ))))
 (axiom (forall ((self@ Poly)) (!
    (=>
     (has_type self@ TYPE%spec.Directory.)
     (has_type (Poly%spec.ArchLayer. (spec.Directory.arch_layer.? self@)) TYPE%spec.ArchLayer.)
    )
    :pattern ((spec.Directory.arch_layer.? self@))
 )))

 ;; Function-Axioms crate::spec::Directory::pages_match_entry_size
 (declare-fun req%spec.Directory.pages_match_entry_size. (Poly) Bool)
 (axiom (forall ((self@ Poly)) (!
    (= (req%spec.Directory.pages_match_entry_size. self@) (axiom_location ("recommendation not met")
      (spec.Directory.well_formed.? self@)
    ))
    :pattern ((req%spec.Directory.pages_match_entry_size. self@))
 )))
 (axiom (fuel_bool_default fuel%spec.Directory.pages_match_entry_size.))
 (axiom (=>
   (fuel_bool fuel%spec.Directory.pages_match_entry_size.)
   (forall ((self@ Poly)) (!
     (= (spec.Directory.pages_match_entry_size.? self@) (forall ((i$ Poly)) (!
        (=>
         (has_type i$ NAT)
         (=>
          (and
           (< (%I i$) (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
              (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
           )))
           (is-spec.NodeEntry./Page (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry.
              (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries (%Poly%spec.Directory.
                 self@
               ))
              ) i$
          ))))
          (= (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (Poly%spec.MemRegion. (spec.NodeEntry./Page/_0
               (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
                  (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
                 ) i$
            )))))
           ) (spec.Directory.entry_size.? self@)
        )))
        :pattern ((pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
           (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
          ) i$
     )))))
     :pattern ((spec.Directory.pages_match_entry_size.? self@))
 ))))

 ;; Function-Axioms crate::spec::Directory::directories_are_in_next_layer
 (declare-fun req%spec.Directory.directories_are_in_next_layer. (Poly) Bool)
 (axiom (forall ((self@ Poly)) (!
    (= (req%spec.Directory.directories_are_in_next_layer. self@) (axiom_location ("recommendation not met")
      (spec.Directory.well_formed.? self@)
    ))
    :pattern ((req%spec.Directory.directories_are_in_next_layer. self@))
 )))
 (axiom (fuel_bool_default fuel%spec.Directory.directories_are_in_next_layer.))
 (axiom (=>
   (fuel_bool fuel%spec.Directory.directories_are_in_next_layer.)
   (forall ((self@ Poly)) (!
     (= (spec.Directory.directories_are_in_next_layer.? self@) (forall ((i$ Poly)) (!
        (=>
         (has_type i$ NAT)
         (=>
          (and
           (< (%I i$) (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
              (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
           )))
           (is-spec.NodeEntry./Directory (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry.
              (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries (%Poly%spec.Directory.
                 self@
               ))
              ) i$
          ))))
          (let
           ((directory$ (spec.NodeEntry./Directory/_0 (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.?
                TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries
                  (%Poly%spec.Directory. self@)
                 )
                ) i$
           )))))
           (and
            (= (spec.Directory./Directory/layer (%Poly%spec.Directory. (Poly%spec.Directory. directory$)))
             (nClip (+ (spec.Directory./Directory/layer (%Poly%spec.Directory. self@)) 1))
            )
            (= (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
                directory$
              ))
             ) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. self@)) (nClip
                (* (%I i$) (spec.Directory.entry_size.? self@))
        ))))))))
        :pattern ((pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
           (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
          ) i$
     )))))
     :pattern ((spec.Directory.directories_are_in_next_layer.? self@))
 ))))

 ;; Function-Axioms crate::spec::Directory::directories_match_arch
 (axiom (fuel_bool_default fuel%spec.Directory.directories_match_arch.))
 (axiom (=>
   (fuel_bool fuel%spec.Directory.directories_match_arch.)
   (forall ((self@ Poly)) (!
     (= (spec.Directory.directories_match_arch.? self@) (forall ((i$ Poly)) (!
        (=>
         (has_type i$ NAT)
         (=>
          (and
           (< (%I i$) (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
              (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
           )))
           (is-spec.NodeEntry./Directory (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry.
              (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries (%Poly%spec.Directory.
                 self@
               ))
              ) i$
          ))))
          (= (spec.Directory./Directory/arch (%Poly%spec.Directory. (Poly%spec.Directory. (spec.NodeEntry./Directory/_0
               (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
                  (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
                 ) i$
            )))))
           ) (spec.Directory./Directory/arch (%Poly%spec.Directory. self@))
        )))
        :pattern ((pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
           (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
          ) i$
     )))))
     :pattern ((spec.Directory.directories_match_arch.? self@))
 ))))

 ;; Function-Axioms crate::spec::Directory::frames_aligned
 (declare-fun req%spec.Directory.frames_aligned. (Poly) Bool)
 (axiom (forall ((self@ Poly)) (!
    (= (req%spec.Directory.frames_aligned. self@) (axiom_location ("recommendation not met")
      (spec.Directory.well_formed.? self@)
    ))
    :pattern ((req%spec.Directory.frames_aligned. self@))
 )))
 (axiom (fuel_bool_default fuel%spec.Directory.frames_aligned.))
 (axiom (=>
   (fuel_bool fuel%spec.Directory.frames_aligned.)
   (forall ((self@ Poly)) (!
     (= (spec.Directory.frames_aligned.? self@) (forall ((i$ Poly)) (!
        (=>
         (has_type i$ NAT)
         (=>
          (and
           (< (%I i$) (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
              (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
           )))
           (is-spec.NodeEntry./Page (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry.
              (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries (%Poly%spec.Directory.
                 self@
               ))
              ) i$
          ))))
          (spec.aligned.? (I (spec.MemRegion./MemRegion/base (%Poly%spec.MemRegion. (Poly%spec.MemRegion.
               (spec.NodeEntry./Page/_0 (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry.
                  (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries (%Poly%spec.Directory.
                     self@
                   ))
                  ) i$
            ))))))
           ) (I (spec.Directory.entry_size.? self@))
        )))
        :pattern ((pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
           (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
          ) i$
     )))))
     :pattern ((spec.Directory.frames_aligned.? self@))
 ))))

 ;; Function-Termination crate::spec::Directory::inv
 (check-valid
  (declare-const self@ Poly)
  (declare-const decrease%init0@ Int)
  (axiom fuel_defaults)
  (axiom (has_type self@ TYPE%spec.Directory.))
  (block
   (assume
    (= decrease%init0@ (nClip (- (pervasive.seq.Seq.len.? TYPE%spec.ArchLayer. (Poly%pervasive.seq.Seq<spec.ArchLayer.>.
         (spec.Arch./Arch/layers (%Poly%spec.Arch. (Poly%spec.Arch. (spec.Directory./Directory/arch
             (%Poly%spec.Directory. self@)
        )))))
       ) (spec.Directory./Directory/layer (%Poly%spec.Directory. self@))
   ))))
   (assert
    ("could not prove termination")
    (=>
     (and
      (and
       (and
        (spec.Directory.well_formed.? self@)
        (spec.Directory.pages_match_entry_size.? self@)
       )
       (spec.Directory.directories_are_in_next_layer.? self@)
      )
      (spec.Directory.directories_match_arch.? self@)
     )
     (check_decrease_int.? (let
       ((self!$ self@))
       (nClip (- (pervasive.seq.Seq.len.? TYPE%spec.ArchLayer. (Poly%pervasive.seq.Seq<spec.ArchLayer.>.
           (spec.Arch./Arch/layers (%Poly%spec.Arch. (Poly%spec.Arch. (spec.Directory./Directory/arch
               (%Poly%spec.Directory. self!$)
          )))))
         ) (spec.Directory./Directory/layer (%Poly%spec.Directory. self!$))
       ))
      ) decrease%init0@ true
 )))))

 ;; Function-Termination crate::spec::Directory::directories_obey_invariant
 (check-valid
  (declare-const self@ Poly)
  (declare-const decrease%init0@ Int)
  (declare-const decrease%init1@ Int)
  (axiom fuel_defaults)
  (axiom (has_type self@ TYPE%spec.Directory.))
  (block
   (assume
    (= decrease%init0@ (nClip (- (pervasive.seq.Seq.len.? TYPE%spec.ArchLayer. (Poly%pervasive.seq.Seq<spec.ArchLayer.>.
         (spec.Arch./Arch/layers (%Poly%spec.Arch. (Poly%spec.Arch. (spec.Directory./Directory/arch
             (%Poly%spec.Directory. self@)
        )))))
       ) (spec.Directory./Directory/layer (%Poly%spec.Directory. self@))
   ))))
   (assume
    (= decrease%init1@ 0)
   )
   (assert
    ("could not prove termination")
    (=>
     (and
      (and
       (spec.Directory.well_formed.? self@)
       (spec.Directory.directories_are_in_next_layer.? self@)
      )
      (spec.Directory.directories_match_arch.? self@)
     )
     (forall ((i$ Poly)) (!
       (=>
        (has_type i$ NAT)
        (=>
         (and
          (< (%I i$) (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
             (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
          )))
          (is-spec.NodeEntry./Directory (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry.
             (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries (%Poly%spec.Directory.
                self@
              ))
             ) i$
         ))))
         (check_decrease_int.? (let
           ((self!$ (Poly%spec.Directory. (spec.NodeEntry./Directory/_0 (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.?
                 TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries
                   (%Poly%spec.Directory. self@)
                  )
                 ) i$
           ))))))
           (nClip (- (pervasive.seq.Seq.len.? TYPE%spec.ArchLayer. (Poly%pervasive.seq.Seq<spec.ArchLayer.>.
               (spec.Arch./Arch/layers (%Poly%spec.Arch. (Poly%spec.Arch. (spec.Directory./Directory/arch
                   (%Poly%spec.Directory. self!$)
              )))))
             ) (spec.Directory./Directory/layer (%Poly%spec.Directory. self!$))
           ))
          ) decrease%init0@ false
       )))
       :pattern ((pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
          (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
         ) i$
 ))))))))

 ;; Function-Axioms crate::spec::Directory::inv
 (axiom (fuel_bool_default fuel%spec.Directory.inv.))
 (declare-const fuel_nat%spec.Directory.inv. Fuel)
 (axiom (forall ((self@ Poly) (fuel%@ Fuel)) (!
    (= (spec.Directory.rec%inv.? self@ fuel%@) (spec.Directory.rec%inv.? self@ zero))
    :pattern ((spec.Directory.rec%inv.? self@ fuel%@))
 )))
 (axiom (forall ((self@ Poly) (fuel%@ Fuel)) (!
    (= (spec.Directory.rec%inv.? self@ (succ fuel%@)) (and
      (and
       (and
        (and
         (and
          (spec.Directory.well_formed.? self@)
          (spec.Directory.pages_match_entry_size.? self@)
         )
         (spec.Directory.directories_are_in_next_layer.? self@)
        )
        (spec.Directory.directories_match_arch.? self@)
       )
       (spec.Directory.rec%directories_obey_invariant.? self@ fuel%@)
      )
      (spec.Directory.frames_aligned.? self@)
    ))
    :pattern ((spec.Directory.rec%inv.? self@ (succ fuel%@)))
 )))
 (axiom (=>
   (fuel_bool fuel%spec.Directory.inv.)
   (forall ((self@ Poly)) (!
     (= (spec.Directory.inv.? self@) (spec.Directory.rec%inv.? self@ (succ fuel_nat%spec.Directory.inv.)))
     :pattern ((spec.Directory.inv.? self@))
 ))))

 ;; Function-Axioms crate::spec::Directory::directories_obey_invariant
 (declare-fun req%spec.Directory.directories_obey_invariant. (Poly) Bool)
 (axiom (forall ((self@ Poly)) (!
    (= (req%spec.Directory.directories_obey_invariant. self@) (axiom_location ("recommendation not met")
      (and
       (and
        (spec.Directory.well_formed.? self@)
        (spec.Directory.directories_are_in_next_layer.? self@)
       )
       (spec.Directory.directories_match_arch.? self@)
    )))
    :pattern ((req%spec.Directory.directories_obey_invariant. self@))
 )))
 (axiom (fuel_bool_default fuel%spec.Directory.directories_obey_invariant.))
 (declare-const fuel_nat%spec.Directory.directories_obey_invariant. Fuel)
 (axiom (forall ((self@ Poly) (fuel%@ Fuel)) (!
    (= (spec.Directory.rec%directories_obey_invariant.? self@ fuel%@) (spec.Directory.rec%directories_obey_invariant.?
      self@ zero
    ))
    :pattern ((spec.Directory.rec%directories_obey_invariant.? self@ fuel%@))
 )))
 (axiom (forall ((self@ Poly) (fuel%@ Fuel)) (!
    (= (spec.Directory.rec%directories_obey_invariant.? self@ (succ fuel%@)) (ite
      (and
       (and
        (spec.Directory.well_formed.? self@)
        (spec.Directory.directories_are_in_next_layer.? self@)
       )
       (spec.Directory.directories_match_arch.? self@)
      )
      (forall ((i$ Poly)) (!
        (=>
         (has_type i$ NAT)
         (=>
          (and
           (< (%I i$) (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
              (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
           )))
           (is-spec.NodeEntry./Directory (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry.
              (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries (%Poly%spec.Directory.
                 self@
               ))
              ) i$
          ))))
          (spec.Directory.rec%inv.? (Poly%spec.Directory. (spec.NodeEntry./Directory/_0 (%Poly%spec.NodeEntry.
              (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
                (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
               ) i$
            )))
           ) fuel%@
        )))
        :pattern ((pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
           (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
          ) i$
      ))))
      (%B (pervasive.arbitrary.? BOOL))
    ))
    :pattern ((spec.Directory.rec%directories_obey_invariant.? self@ (succ fuel%@)))
 )))
 (axiom (=>
   (fuel_bool fuel%spec.Directory.directories_obey_invariant.)
   (forall ((self@ Poly)) (!
     (= (spec.Directory.directories_obey_invariant.? self@) (spec.Directory.rec%directories_obey_invariant.?
       self@ (succ fuel_nat%spec.Directory.directories_obey_invariant.)
     ))
     :pattern ((spec.Directory.directories_obey_invariant.? self@))
 ))))

 ;; Function-Termination crate::spec::Directory::interp_aux
 (check-valid
  (declare-const self@ Poly)
  (declare-const i@ Poly)
  (declare-const decrease%init0@ Int)
  (declare-const decrease%init1@ Int)
  (axiom fuel_defaults)
  (axiom (has_type self@ TYPE%spec.Directory.))
  (axiom (has_type i@ NAT))
  (block
   (assume
    (= decrease%init0@ (nClip (- (pervasive.seq.Seq.len.? TYPE%spec.ArchLayer. (Poly%pervasive.seq.Seq<spec.ArchLayer.>.
         (spec.Arch./Arch/layers (%Poly%spec.Arch. (Poly%spec.Arch. (spec.Directory./Directory/arch
             (%Poly%spec.Directory. self@)
        )))))
       ) (spec.Directory./Directory/layer (%Poly%spec.Directory. self@))
   ))))
   (assume
    (= decrease%init1@ (nClip (- (spec.Directory.num_entries.? self@) (%I i@))))
   )
   (assert
    ("could not prove termination")
    (=>
     (spec.Directory.inv.? self@)
     (=>
      (not (>= (%I i@) (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
          (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
      ))))
      (and
       (check_decrease_int.? (let
         ((self!$ self@) (i!$ (I (nClip (+ (%I i@) 1)))))
         (nClip (- (pervasive.seq.Seq.len.? TYPE%spec.ArchLayer. (Poly%pervasive.seq.Seq<spec.ArchLayer.>.
             (spec.Arch./Arch/layers (%Poly%spec.Arch. (Poly%spec.Arch. (spec.Directory./Directory/arch
                 (%Poly%spec.Directory. self!$)
            )))))
           ) (spec.Directory./Directory/layer (%Poly%spec.Directory. self!$))
         ))
        ) decrease%init0@ (check_decrease_int.? (let
          ((self!$ self@) (i!$ (I (nClip (+ (%I i@) 1)))))
          (nClip (- (spec.Directory.num_entries.? self!$) (%I i!$)))
         ) decrease%init1@ false
       ))
       (let
        ((rem$ (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents.
            (Poly%spec.PageTableContents. (spec.Directory.interp_aux.? self@ (I (nClip (+ (%I i@)
                 1
        )))))))))
        (let
         ((tmp%%1$ (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
              (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
             ) i@
         ))))
         (ite
          (is-spec.NodeEntry./Page tmp%%1$)
          (let
           ((p$ (spec.NodeEntry./Page/_0 (%Poly%spec.NodeEntry. (Poly%spec.NodeEntry. tmp%%1$)))))
           true
          )
          (=>
           (is-spec.NodeEntry./Directory tmp%%1$)
           (let
            ((d$ (spec.NodeEntry./Directory/_0 (%Poly%spec.NodeEntry. (Poly%spec.NodeEntry. tmp%%1$)))))
            (check_decrease_int.? (let
              ((self!$ (Poly%spec.Directory. d$)) (i!$ (I 0)))
              (nClip (- (pervasive.seq.Seq.len.? TYPE%spec.ArchLayer. (Poly%pervasive.seq.Seq<spec.ArchLayer.>.
                  (spec.Arch./Arch/layers (%Poly%spec.Arch. (Poly%spec.Arch. (spec.Directory./Directory/arch
                      (%Poly%spec.Directory. self!$)
                 )))))
                ) (spec.Directory./Directory/layer (%Poly%spec.Directory. self!$))
              ))
             ) decrease%init0@ (check_decrease_int.? (let
               ((self!$ (Poly%spec.Directory. d$)) (i!$ (I 0)))
               (nClip (- (spec.Directory.num_entries.? self!$) (%I i!$)))
              ) decrease%init1@ false
 )))))))))))))

 ;; Function-Axioms crate::spec::Directory::interp_aux
 (axiom (fuel_bool_default fuel%spec.Directory.interp_aux.))
 (declare-const fuel_nat%spec.Directory.interp_aux. Fuel)
 (axiom (forall ((self@ Poly) (i@ Poly) (fuel%@ Fuel)) (!
    (= (spec.Directory.rec%interp_aux.? self@ i@ fuel%@) (spec.Directory.rec%interp_aux.?
      self@ i@ zero
    ))
    :pattern ((spec.Directory.rec%interp_aux.? self@ i@ fuel%@))
 )))
 (axiom (forall ((self@ Poly) (i@ Poly) (fuel%@ Fuel)) (!
    (= (spec.Directory.rec%interp_aux.? self@ i@ (succ fuel%@)) (ite
      (spec.Directory.inv.? self@)
      (ite
       (>= (%I i@) (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
          (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
       )))
       (spec.PageTableContents./PageTableContents (%Poly%pervasive.map.Map<nat./spec.MemRegion.>.
         (pervasive.map.Map.empty.? NAT TYPE%spec.MemRegion.)
        ) (%Poly%spec.Arch. (Poly%spec.Arch. (spec.Directory./Directory/arch (%Poly%spec.Directory.
            self@
       )))))
       (let
        ((rem$ (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents.
            (Poly%spec.PageTableContents. (spec.Directory.rec%interp_aux.? self@ (I (nClip (+ (%I i@)
                 1
               ))
              ) fuel%@
        ))))))
        (spec.PageTableContents./PageTableContents (%Poly%pervasive.map.Map<nat./spec.MemRegion.>.
          (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (let
            ((tmp%%1$ (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
                 (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
                ) i@
            ))))
            (ite
             (is-spec.NodeEntry./Page tmp%%1$)
             (%Poly%pervasive.map.Map<nat./spec.MemRegion.>. (let
               ((p$ (spec.NodeEntry./Page/_0 (%Poly%spec.NodeEntry. (Poly%spec.NodeEntry. tmp%%1$)))))
               (pervasive.map.Map.insert.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
                 rem$
                ) (I (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. self@))
                   (nClip (* (%I i@) (spec.Directory.entry_size.? self@)))
                 ))
                ) (Poly%spec.MemRegion. p$)
             )))
             (ite
              (is-spec.NodeEntry./Directory tmp%%1$)
              (%Poly%pervasive.map.Map<nat./spec.MemRegion.>. (let
                ((d$ (spec.NodeEntry./Directory/_0 (%Poly%spec.NodeEntry. (Poly%spec.NodeEntry. tmp%%1$)))))
                (pervasive.map.Map.union_prefer_right.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
                  rem$
                 ) (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
                   (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.rec%interp_aux.?
                      (Poly%spec.Directory. d$) (I 0) fuel%@
              ))))))))
              rem$
          ))))
         ) (%Poly%spec.Arch. (Poly%spec.Arch. (spec.Directory./Directory/arch (%Poly%spec.Directory.
             self@
      )))))))
      (%Poly%spec.PageTableContents. (pervasive.arbitrary.? TYPE%spec.PageTableContents.))
    ))
    :pattern ((spec.Directory.rec%interp_aux.? self@ i@ (succ fuel%@)))
 )))
 (axiom (=>
   (fuel_bool fuel%spec.Directory.interp_aux.)
   (forall ((self@ Poly) (i@ Poly)) (!
     (= (spec.Directory.interp_aux.? self@ i@) (spec.Directory.rec%interp_aux.? self@ i@
       (succ fuel_nat%spec.Directory.interp_aux.)
     ))
     :pattern ((spec.Directory.interp_aux.? self@ i@))
 ))))

 ;; Function-Axioms crate::spec::Directory::interp
 (axiom (fuel_bool_default fuel%spec.Directory.interp.))
 (axiom (=>
   (fuel_bool fuel%spec.Directory.interp.)
   (forall ((self@ Poly)) (!
     (= (spec.Directory.interp.? self@) (spec.Directory.interp_aux.? self@ (I 0)))
     :pattern ((spec.Directory.interp.? self@))
 ))))

 ;; Function-Axioms crate::lib::mul_distributive
 (declare-fun ens%lib.mul_distributive. (Int Int) Bool)
 (axiom (forall ((a@ Int) (b@ Int)) (!
    (= (ens%lib.mul_distributive. a@ b@) (= (nClip (* (nClip (+ a@ 1)) b@)) (nClip (+ (nClip
         (* a@ b@)
        ) b@
    ))))
    :pattern ((ens%lib.mul_distributive. a@ b@))
 )))

 ;; Function-Axioms crate::spec::Directory::inv_implies_interp_aux_inv
 (declare-fun req%spec.Directory.inv_implies_interp_aux_inv. (spec.Directory. Int)
  Bool
 )
 (axiom (forall ((self@ spec.Directory.) (i@ Int)) (!
    (= (req%spec.Directory.inv_implies_interp_aux_inv. self@ i@) (axiom_location ("failed precondition")
      (spec.Directory.inv.? (Poly%spec.Directory. self@))
    ))
    :pattern ((req%spec.Directory.inv_implies_interp_aux_inv. self@ i@))
 )))
 (declare-fun ens%spec.Directory.inv_implies_interp_aux_inv. (spec.Directory. Int)
  Bool
 )
 (declare-const va$222 Poly)
 (axiom (forall ((self@ spec.Directory.) (i@ Int)) (!
    (= (ens%spec.Directory.inv_implies_interp_aux_inv. self@ i@) (and
      (spec.PageTableContents.inv.? (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
         (Poly%spec.Directory. self@) (I i@)
      )))
      ; (forall ((va$ Poly)) (!
        (=>
         ; (has_type va$222 NAT)
         true
         (=>
          ; (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
          ;   (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
          ;     (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
          ;        (Poly%spec.Directory. self@) (I i@)
          ;   )))))
          ;  ) va$222
          ; )
          true
          (>= (%I va$222) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
                self@
              ))
             ) (nClip (* i@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
        )))))

      ;   :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
      ;      (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
      ;        (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
      ;           (Poly%spec.Directory. self@) (I i@)
      ;      )))))
      ;     ) va$
      ; )))
      ; )
      (forall ((va$ Poly)) (!
        (=>
         (has_type va$ NAT)
         (=>
          (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
            (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
              (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
                 (Poly%spec.Directory. self@) (I i@)
            )))))
           ) va$
          )
          (<= (%I va$) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
                self@
              ))
             ) (nClip (* (spec.Directory.num_entries.? (Poly%spec.Directory. self@)) (spec.Directory.entry_size.?
                (Poly%spec.Directory. self@)
        ))))))))
        :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
           (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
             (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
                (Poly%spec.Directory. self@) (I i@)
           )))))
          ) va$
    ))))))
    :pattern ((ens%spec.Directory.inv_implies_interp_aux_inv. self@ i@))
 )))

 (check-valid
(assert
("not renamed here")
(forall ((self@ spec.Directory.) (i@ Int)) (!
    (=> (ens%spec.Directory.inv_implies_interp_aux_inv. self@ i@)
    (and
      (spec.PageTableContents.inv.? (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
         (Poly%spec.Directory. self@) (I i@)
      )))
      ; (forall ((va$ Poly)) (!
        (=>
         (has_type va$222 NAT)
         (=>
          (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
            (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
              (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
                 (Poly%spec.Directory. self@) (I i@)
            )))))
           ) va$222
          )
          (>= (%I va$222) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
                self@
              ))
             ) (nClip (* i@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
          )))
        ))
        ; :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
        ;    (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
        ;      (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
        ;         (Poly%spec.Directory. self@) (I i@)
        ;    )))))
        ;   ) va$
        ; ))))
      ; (forall ((va$ Poly)) (!
      ;   (=>
      ;    (has_type va$ NAT)
      ;    (=>
      ;     (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
      ;       (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
      ;         (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
      ;            (Poly%spec.Directory. self@) (I i@)
      ;       )))))
      ;      ) va$
      ;     )
      ;     (<= (%I va$) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
      ;           self@
      ;         ))
      ;        ) (nClip (* (spec.Directory.num_entries.? (Poly%spec.Directory. self@)) (spec.Directory.entry_size.?
      ;           (Poly%spec.Directory. self@)
      ;   ))))))))
      ;   :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
      ;      (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
      ;        (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
      ;           (Poly%spec.Directory. self@) (I i@)
      ;      )))))
      ;     ) va$
      ;   ))))
    ))
    :pattern ((ens%spec.Directory.inv_implies_interp_aux_inv. self@ i@))
 )))
 )

;  ; (check-valid
;  ;       (assert
;  ;        ("lemma ensures start right here")
;  ;        (forall ((self2 spec.Directory.) (i2 Int)) (!
;  ;            (= (ens%spec.Directory.inv_implies_interp_aux_inv. self2 i2) (and
;  ;              (spec.PageTableContents.inv.? (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;  ;                 (Poly%spec.Directory. self2) (I i2)
;  ;              )))
;  ;              (forall ((va$ Poly)) (!
;  ;                (=>
;  ;                 (has_type va$ NAT)
;  ;                 (=>
;  ;                  (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;  ;                    (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;  ;                      (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;  ;                         (Poly%spec.Directory. self2) (I i2)
;  ;                    )))))
;  ;                   ) va$
;  ;                  )
;  ;                  (>= (%I va$) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;  ;                        self2
;  ;                      ))
;  ;                     ) (nClip (* i2 (spec.Directory.entry_size.? (Poly%spec.Directory. self2))))
;  ;                )))))
;  ;                :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;  ;                   (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;  ;                     (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;  ;                        (Poly%spec.Directory. self2) (I i2)
;  ;                   )))))
;  ;                  ) va$
;  ;              ))))
;  ;              (forall ((va$ Poly)) (!
;  ;                (=>
;  ;                 (has_type va$ NAT)
;  ;                 (=>
;  ;                  (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;  ;                    (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;  ;                      (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;  ;                         (Poly%spec.Directory. self2) (I i2)
;  ;                    )))))
;  ;                   ) va$
;  ;                  )
;  ;                  (<= (%I va$) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;  ;                        self2
;  ;                      ))
;  ;                     ) (nClip (* (spec.Directory.num_entries.? (Poly%spec.Directory. self2)) (spec.Directory.entry_size.?
;  ;                        (Poly%spec.Directory. self2)
;  ;                ))))))))
;  ;                :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;  ;                   (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;  ;                     (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;  ;                        (Poly%spec.Directory. self2) (I i2)
;  ;                   )))))
;  ;                  ) va$
;  ;            ))))))
;  ;            :pattern ((ens%spec.Directory.inv_implies_interp_aux_inv. self2 i2))
;  ;         ))))
; 
;  ;; Function-Def crate::spec::arch_inv_test
;  (check-valid
;   (declare-const tmp%1@ Bool)
;   (declare-const tmp%2@ Bool)
;   (declare-const tmp%3@ Bool)
;   (declare-const x86@ spec.Arch.)
;   (axiom fuel_defaults)
;   (block
;    (assume
;     (= x86@ (spec.Arch./Arch (%Poly%pervasive.seq.Seq<spec.ArchLayer.>. (pervasive.seq.Seq.push.?
;         TYPE%spec.ArchLayer. (pervasive.seq.Seq.push.? TYPE%spec.ArchLayer. (pervasive.seq.Seq.push.?
;           TYPE%spec.ArchLayer. (pervasive.seq.Seq.push.? TYPE%spec.ArchLayer. (pervasive.seq.Seq.empty.?
;             TYPE%spec.ArchLayer.
;            ) (Poly%spec.ArchLayer. (spec.ArchLayer./ArchLayer (%I (I (nClip (* (nClip (* (nClip (* 512
;                      1024
;                     )
;                    ) 1024
;                   )
;                  ) 1024
;               )))
;              ) (%I (I 512))
;            ))
;           ) (Poly%spec.ArchLayer. (spec.ArchLayer./ArchLayer (%I (I (nClip (* (nClip (* (nClip (* 1 1024))
;                   1024
;                  )
;                 ) 1024
;              )))
;             ) (%I (I 512))
;           ))
;          ) (Poly%spec.ArchLayer. (spec.ArchLayer./ArchLayer (%I (I (nClip (* (nClip (* 2 1024))
;                1024
;             )))
;            ) (%I (I 512))
;          ))
;         ) (Poly%spec.ArchLayer. (spec.ArchLayer./ArchLayer (%I (I (nClip (* 4 1024)))) (%I (
;             I 512
;    )))))))))
;    (assume
;     (= tmp%1@ (spec.Arch.inv.? (Poly%spec.Arch. x86@)))
;    )
;    (block
;     (assert
;      ("assertion failure")
;      (req%pervasive.assert. tmp%1@)
;     )
;     (assume
;      (ens%pervasive.assert. tmp%1@)
;    ))
;    (assume
;     (= tmp%2@ (= (spec.ArchLayer./ArchLayer/entry_size (%Poly%spec.ArchLayer. (pervasive.seq.Seq.index.?
;          TYPE%spec.ArchLayer. (Poly%pervasive.seq.Seq<spec.ArchLayer.>. (spec.Arch./Arch/layers
;            (%Poly%spec.Arch. (Poly%spec.Arch. x86@))
;           )
;          ) (I 3)
;        ))
;       ) 4096
;    )))
;    (block
;     (assert
;      ("assertion failure")
;      (req%pervasive.assert. tmp%2@)
;     )
;     (assume
;      (ens%pervasive.assert. tmp%2@)
;    ))
;    (assume
;     (= tmp%3@ (spec.Arch.contains_entry_size.? (Poly%spec.Arch. x86@) (I 4096)))
;    )
;    (block
;     (assert
;      ("assertion failure")
;      (req%pervasive.assert. tmp%3@)
;     )
;     (assume
;      (ens%pervasive.assert. tmp%3@)
;  ))))
; 
;  ;; Function-Def crate::spec::overlap_sanity_check
;  (check-valid
;   (declare-const tmp%1@ Bool)
;   (declare-const tmp%2@ Bool)
;   (declare-const tmp%3@ Bool)
;   (declare-const tmp%4@ Bool)
;   (declare-const tmp%5@ Bool)
;   (declare-const tmp%6@ Bool)
;   (axiom fuel_defaults)
;   (block
;    (assume
;     (= tmp%1@ (spec.overlap.? (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I 0))
;         (%I (I 4096))
;        )
;       ) (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I 0)) (%I (I 4096))))
;    )))
;    (block
;     (assert
;      ("assertion failure")
;      (req%pervasive.assert. tmp%1@)
;     )
;     (assume
;      (ens%pervasive.assert. tmp%1@)
;    ))
;    (assume
;     (= tmp%2@ (spec.overlap.? (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I 0))
;         (%I (I 8192))
;        )
;       ) (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I 0)) (%I (I 4096))))
;    )))
;    (block
;     (assert
;      ("assertion failure")
;      (req%pervasive.assert. tmp%2@)
;     )
;     (assume
;      (ens%pervasive.assert. tmp%2@)
;    ))
;    (assume
;     (= tmp%3@ (spec.overlap.? (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I 0))
;         (%I (I 4096))
;        )
;       ) (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I 0)) (%I (I 8192))))
;    )))
;    (block
;     (assert
;      ("assertion failure")
;      (req%pervasive.assert. tmp%3@)
;     )
;     (assume
;      (ens%pervasive.assert. tmp%3@)
;    ))
;    (assume
;     (= tmp%4@ (spec.overlap.? (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I 0))
;         (%I (I 8192))
;        )
;       ) (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I 4096)) (%I (I 4096))))
;    )))
;    (block
;     (assert
;      ("assertion failure")
;      (req%pervasive.assert. tmp%4@)
;     )
;     (assume
;      (ens%pervasive.assert. tmp%4@)
;    ))
;    (assume
;     (= tmp%5@ (not (spec.overlap.? (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I 4096))
;          (%I (I 8192))
;         )
;        ) (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I 0)) (%I (I 4096))))
;    ))))
;    (block
;     (assert
;      ("assertion failure")
;      (req%pervasive.assert. tmp%5@)
;     )
;     (assume
;      (ens%pervasive.assert. tmp%5@)
;    ))
;    (assume
;     (= tmp%6@ (not (spec.overlap.? (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I 0))
;          (%I (I 4096))
;         )
;        ) (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I 8192)) (%I (I 16384))))
;    ))))
;    (block
;     (assert
;      ("assertion failure")
;      (req%pervasive.assert. tmp%6@)
;     )
;     (assume
;      (ens%pervasive.assert. tmp%6@)
;  ))))
; 
;  ;; Function-Def crate::spec::PageTableContents::map_frame_maps_valid
;  (check-valid
;   (declare-const self@ spec.PageTableContents.)
;   (declare-const base@ Int)
;   (declare-const frame@ spec.MemRegion.)
;   (axiom fuel_defaults)
;   (axiom (<= 0 base@))
;   (axiom (has_type (Poly%spec.MemRegion. frame@) TYPE%spec.MemRegion.))
;   (axiom (spec.PageTableContents.inv.? (Poly%spec.PageTableContents. self@)))
;   (axiom (spec.PageTableContents.accepted_mapping.? (Poly%spec.PageTableContents. self@)
;     (I base@) (Poly%spec.MemRegion. frame@)
;   ))
;   (axiom (spec.PageTableContents.valid_mapping.? (Poly%spec.PageTableContents. self@)
;     (I base@) (Poly%spec.MemRegion. frame@)
;   ))
;   (assert
;    ("postcondition not satisfied" "at the end of the function body" "failed this postcondition")
;    (is-pervasive.result.Result./Ok (spec.PageTableContents.map_frame.? (Poly%spec.PageTableContents.
;       self@
;      ) (I base@) (Poly%spec.MemRegion. frame@)
;  ))))
; 
;  ;; Function-Def crate::spec::PageTableContents::map_frame_preserves_inv
;  (check-valid
;   (declare-const self@ spec.PageTableContents.)
;   (declare-const base@ Int)
;   (declare-const frame@ spec.MemRegion.)
;   (axiom fuel_defaults)
;   (axiom (<= 0 base@))
;   (axiom (has_type (Poly%spec.MemRegion. frame@) TYPE%spec.MemRegion.))
;   (axiom (spec.PageTableContents.inv.? (Poly%spec.PageTableContents. self@)))
;   (axiom (spec.PageTableContents.accepted_mapping.? (Poly%spec.PageTableContents. self@)
;     (I base@) (Poly%spec.MemRegion. frame@)
;   ))
;   (axiom (is-pervasive.result.Result./Ok (spec.PageTableContents.map_frame.? (Poly%spec.PageTableContents.
;       self@
;      ) (I base@) (Poly%spec.MemRegion. frame@)
;   )))
;   (assert
;    ("postcondition not satisfied" "at the end of the function body" "failed this postcondition")
;    (spec.PageTableContents.inv.? (pervasive.result.Result./Ok/_0 (%Poly%pervasive.result.Result.
;       (Poly%pervasive.result.Result. (spec.PageTableContents.map_frame.? (Poly%spec.PageTableContents.
;          self@
;         ) (I base@) (Poly%spec.MemRegion. frame@)
;  )))))))
; 
;  ;; Function-Def crate::spec::PageTableContents::lemma_overlap_IMP_equal_base
;  (check-valid
;   (declare-const self@ spec.PageTableContents.)
;   (declare-const va1@ Int)
;   (declare-const base@ Int)
;   (declare-const size@ Int)
;   (declare-const tmp%1@ Bool)
;   (declare-const tmp%2@ Bool)
;   (declare-const tmp%3@ Bool)
;   (declare-const tmp%4@ Bool)
;   (declare-const tmp%5@ Bool)
;   (declare-const tmp%6@ Bool)
;   (declare-const tmp%7@ Bool)
;   (declare-const tmp%8@ Bool)
;   (declare-const tmp%9@ Bool)
;   (declare-const tmp%10@ Bool)
;   (axiom fuel_defaults)
;   (axiom (<= 0 va1@))
;   (axiom (<= 0 base@))
;   (axiom (<= 0 size@))
;   (axiom (spec.PageTableContents.inv.? (Poly%spec.PageTableContents. self@)))
;   (axiom (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;      (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;        (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. self@))
;      ))
;     ) (I va1@)
;   ))
;   (axiom (spec.aligned.? (I base@) (I size@)))
;   (axiom (= size@ (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
;        NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;          (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. self@))
;         )
;        ) (I va1@)
;   )))))
;   (axiom (> size@ 0))
;   (axiom (spec.overlap.? (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I va1@))
;       (%I (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
;            NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;              (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. self@))
;             )
;            ) (I va1@)
;      ))))))
;     ) (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I base@)) (%I (I size@))))
;   ))
;   (block
;    (switch
;     (block
;      (assume
;       (<= va1@ base@)
;      )
;      (switch
;       (block
;        (assume
;         (< va1@ base@)
;        )
;        (assume
;         (= tmp%1@ (< va1@ base@))
;        )
;        (block
;         (assert
;          ("assertion failure")
;          (req%pervasive.assert. tmp%1@)
;         )
;         (assume
;          (ens%pervasive.assert. tmp%1@)
;        ))
;        (assume
;         (= tmp%2@ (< base@ (nClip (+ va1@ size@))))
;        )
;        (block
;         (assert
;          ("assertion failure")
;          (req%pervasive.assert. tmp%2@)
;         )
;         (assume
;          (ens%pervasive.assert. tmp%2@)
;        ))
;        (assume
;         (= tmp%3@ (= (mod base@ size@) 0))
;        )
;        (block
;         (assert
;          ("assertion failure")
;          (req%pervasive.assert. tmp%3@)
;         )
;         (assume
;          (ens%pervasive.assert. tmp%3@)
;        ))
;        (assume
;         (= tmp%4@ (= (mod va1@ size@) 0))
;        )
;        (block
;         (assert
;          ("assertion failure")
;          (req%pervasive.assert. tmp%4@)
;         )
;         (assume
;          (ens%pervasive.assert. tmp%4@)
;        ))
;        (block
;         (assume
;          (ens%pervasive.assume. false)
;        ))
;        (assume
;         (= tmp%5@ (= va1@ base@))
;        )
;        (block
;         (assert
;          ("assertion failure")
;          (req%pervasive.assert. tmp%5@)
;         )
;         (assume
;          (ens%pervasive.assert. tmp%5@)
;       )))
;       (block
;        (assume
;         (not (< va1@ base@))
;     ))))
;     (block
;      (assume
;       (not (<= va1@ base@))
;      )
;      (assume
;       (= tmp%6@ (< base@ va1@))
;      )
;      (block
;       (assert
;        ("assertion failure")
;        (req%pervasive.assert. tmp%6@)
;       )
;       (assume
;        (ens%pervasive.assert. tmp%6@)
;      ))
;      (assume
;       (= tmp%7@ (< va1@ (nClip (+ base@ size@))))
;      )
;      (block
;       (assert
;        ("assertion failure")
;        (req%pervasive.assert. tmp%7@)
;       )
;       (assume
;        (ens%pervasive.assert. tmp%7@)
;      ))
;      (assume
;       (= tmp%8@ (= (mod va1@ size@) 0))
;      )
;      (block
;       (assert
;        ("assertion failure")
;        (req%pervasive.assert. tmp%8@)
;       )
;       (assume
;        (ens%pervasive.assert. tmp%8@)
;      ))
;      (assume
;       (= tmp%9@ (= (mod base@ size@) 0))
;      )
;      (block
;       (assert
;        ("assertion failure")
;        (req%pervasive.assert. tmp%9@)
;       )
;       (assume
;        (ens%pervasive.assert. tmp%9@)
;      ))
;      (block
;       (assume
;        (ens%pervasive.assume. false)
;      ))
;      (assume
;       (= tmp%10@ (= va1@ base@))
;      )
;      (block
;       (assert
;        ("assertion failure")
;        (req%pervasive.assert. tmp%10@)
;       )
;       (assume
;        (ens%pervasive.assert. tmp%10@)
;    ))))
;    (assert
;     ("postcondition not satisfied" "at the end of the function body" "failed this postcondition")
;     (= va1@ base@)
;  )))
; 
;  ;; Function-Def crate::spec::PageTableContents::unmap_preserves_inv
;  (check-valid
;   (declare-const self@ spec.PageTableContents.)
;   (declare-const base@ Int)
;   (axiom fuel_defaults)
;   (axiom (<= 0 base@))
;   (axiom (spec.PageTableContents.inv.? (Poly%spec.PageTableContents. self@)))
;   (axiom (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;      (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;        (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. self@))
;      ))
;     ) (I base@)
;   ))
;   (assert
;    ("postcondition not satisfied" "at the end of the function body" "failed this postcondition")
;    (spec.PageTableContents.inv.? (Poly%spec.PageTableContents. (spec.PageTableContents.unmap.?
;       (Poly%spec.PageTableContents. self@) (I base@)
;  )))))
; 
;  ;; Function-Check-Recommends crate::spec::Directory::pages_match_entry_size
;  (check-valid
;   (declare-const %return@ Bool)
;   (declare-const self@ Poly)
;   (declare-const i@ Poly)
;   (declare-const tmp%1@ Poly)
;   (declare-const tmp%2@ Poly)
;   (declare-const tmp%3@ Bool)
;   (declare-const tmp%4@ Poly)
;   (declare-const tmp%5@ Poly)
;   (declare-const tmp%6@ Int)
;   (declare-const tmp%7@ Bool)
;   (axiom fuel_defaults)
;   (axiom (has_type self@ TYPE%spec.Directory.))
;   (block
;    (assume
;     (spec.Directory.well_formed.? self@)
;    )
;    (assume
;     (has_type i@ NAT)
;    )
;    (switch
;     (block
;      (assume
;       (< (%I i@) (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;          (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;      ))))
;      (assume
;       (= tmp%2@ (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries
;          (%Poly%spec.Directory. self@)
;      ))))
;      (block
;       (assert
;        ("recommendation not met")
;        (req%pervasive.seq.Seq.index. TYPE%spec.NodeEntry. tmp%2@ i@)
;      ))
;      (assume
;       (= tmp%1@ (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;          (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;         ) i@
;      )))
;      (assume
;       (= tmp%3@ (is-spec.NodeEntry./Page (%Poly%spec.NodeEntry. tmp%1@)))
;     ))
;     (block
;      (assume
;       (not (< (%I i@) (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;           (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;      )))))
;      (assume
;       (= tmp%3@ false)
;    )))
;    (switch
;     (block
;      (assume
;       tmp%3@
;      )
;      (assume
;       (= tmp%5@ (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries
;          (%Poly%spec.Directory. self@)
;      ))))
;      (block
;       (assert
;        ("recommendation not met")
;        (req%pervasive.seq.Seq.index. TYPE%spec.NodeEntry. tmp%5@ i@)
;      ))
;      (assume
;       (= tmp%4@ (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;          (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;         ) i@
;      )))
;      (block
;       (assert
;        ("recommendation not met")
;        (req%spec.Directory.entry_size. self@)
;      ))
;      (assume
;       (= tmp%6@ (spec.Directory.entry_size.? self@))
;      )
;      (assume
;       (= tmp%7@ (= (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (Poly%spec.MemRegion.
;            (spec.NodeEntry./Page/_0 (%Poly%spec.NodeEntry. tmp%4@))
;          ))
;         ) tmp%6@
;     ))))
;     (block
;      (assume
;       (not tmp%3@)
;      )
;      (assume
;       (= tmp%7@ true)
;    )))
;    (assume
;     (= %return@ (forall ((i$ Poly)) (!
;        (=>
;         (has_type i$ NAT)
;         (=>
;          (and
;           (< (%I i$) (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;              (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;           )))
;           (is-spec.NodeEntry./Page (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry.
;              (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries (%Poly%spec.Directory.
;                 self@
;               ))
;              ) i$
;          ))))
;          (= (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (Poly%spec.MemRegion. (spec.NodeEntry./Page/_0
;               (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;                  (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;                 ) i$
;            )))))
;           ) (spec.Directory.entry_size.? self@)
;        )))
;        :pattern ((pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;           (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;          ) i$
;  ))))))))
; 
;  ;; Function-Check-Recommends crate::spec::Directory::directories_are_in_next_layer
;  (check-valid
;   (declare-const %return@ Bool)
;   (declare-const self@ Poly)
;   (declare-const i@ Poly)
;   (declare-const tmp%1@ Poly)
;   (declare-const tmp%2@ Poly)
;   (declare-const tmp%3@ Bool)
;   (declare-const tmp%4@ Poly)
;   (declare-const tmp%5@ Poly)
;   (declare-const tmp%6@ Int)
;   (declare-const tmp%7@ Bool)
;   (declare-const directory@ spec.Directory.)
;   (declare-const tmp%8@ Bool)
;   (axiom fuel_defaults)
;   (axiom (has_type self@ TYPE%spec.Directory.))
;   (block
;    (assume
;     (spec.Directory.well_formed.? self@)
;    )
;    (assume
;     (has_type i@ NAT)
;    )
;    (switch
;     (block
;      (assume
;       (< (%I i@) (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;          (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;      ))))
;      (assume
;       (= tmp%2@ (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries
;          (%Poly%spec.Directory. self@)
;      ))))
;      (block
;       (assert
;        ("recommendation not met")
;        (req%pervasive.seq.Seq.index. TYPE%spec.NodeEntry. tmp%2@ i@)
;      ))
;      (assume
;       (= tmp%1@ (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;          (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;         ) i@
;      )))
;      (assume
;       (= tmp%3@ (is-spec.NodeEntry./Directory (%Poly%spec.NodeEntry. tmp%1@)))
;     ))
;     (block
;      (assume
;       (not (< (%I i@) (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;           (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;      )))))
;      (assume
;       (= tmp%3@ false)
;    )))
;    (switch
;     (block
;      (assume
;       tmp%3@
;      )
;      (assume
;       (= tmp%5@ (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries
;          (%Poly%spec.Directory. self@)
;      ))))
;      (block
;       (assert
;        ("recommendation not met")
;        (req%pervasive.seq.Seq.index. TYPE%spec.NodeEntry. tmp%5@ i@)
;      ))
;      (assume
;       (= tmp%4@ (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;          (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;         ) i@
;      )))
;      (assume
;       (= directory@ (spec.NodeEntry./Directory/_0 (%Poly%spec.NodeEntry. tmp%4@)))
;      )
;      (switch
;       (block
;        (assume
;         (= (spec.Directory./Directory/layer (%Poly%spec.Directory. (Poly%spec.Directory. directory@)))
;          (nClip (+ (spec.Directory./Directory/layer (%Poly%spec.Directory. self@)) 1))
;        ))
;        (block
;         (assert
;          ("recommendation not met")
;          (req%spec.Directory.entry_size. self@)
;        ))
;        (assume
;         (= tmp%6@ (spec.Directory.entry_size.? self@))
;        )
;        (assume
;         (= tmp%7@ (= (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;              directory@
;            ))
;           ) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. self@)) (nClip
;              (* (%I i@) tmp%6@)
;       )))))))
;       (block
;        (assume
;         (not (= (spec.Directory./Directory/layer (%Poly%spec.Directory. (Poly%spec.Directory.
;              directory@
;            ))
;           ) (nClip (+ (spec.Directory./Directory/layer (%Poly%spec.Directory. self@)) 1))
;        )))
;        (assume
;         (= tmp%7@ false)
;      )))
;      (assume
;       (= tmp%8@ tmp%7@)
;     ))
;     (block
;      (assume
;       (not tmp%3@)
;      )
;      (assume
;       (= tmp%8@ true)
;    )))
;    (assume
;     (= %return@ (forall ((i$ Poly)) (!
;        (=>
;         (has_type i$ NAT)
;         (=>
;          (and
;           (< (%I i$) (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;              (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;           )))
;           (is-spec.NodeEntry./Directory (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry.
;              (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries (%Poly%spec.Directory.
;                 self@
;               ))
;              ) i$
;          ))))
;          (let
;           ((directory$ (spec.NodeEntry./Directory/_0 (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.?
;                TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries
;                  (%Poly%spec.Directory. self@)
;                 )
;                ) i$
;           )))))
;           (and
;            (= (spec.Directory./Directory/layer (%Poly%spec.Directory. (Poly%spec.Directory. directory$)))
;             (nClip (+ (spec.Directory./Directory/layer (%Poly%spec.Directory. self@)) 1))
;            )
;            (= (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                directory$
;              ))
;             ) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. self@)) (nClip
;                (* (%I i$) (spec.Directory.entry_size.? self@))
;        ))))))))
;        :pattern ((pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;           (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;          ) i$
;  ))))))))
; 
;  ;; Function-Check-Recommends crate::spec::Directory::directories_obey_invariant
;  (check-valid
;   (declare-const %return@ Bool)
;   (declare-const self@ Poly)
;   (declare-const tmp%1@ Bool)
;   (declare-const tmp%2@ Bool)
;   (declare-const tmp%3@ Bool)
;   (declare-const tmp%4@ Bool)
;   (declare-const i@ Poly)
;   (declare-const tmp%5@ Poly)
;   (declare-const tmp%6@ Poly)
;   (declare-const tmp%7@ Bool)
;   (declare-const tmp%8@ Poly)
;   (declare-const tmp%9@ Poly)
;   (declare-const tmp%10@ Bool)
;   (declare-const tmp%11@ Bool)
;   (axiom fuel_defaults)
;   (axiom (has_type self@ TYPE%spec.Directory.))
;   (block
;    (switch
;     (block
;      (assume
;       (spec.Directory.well_formed.? self@)
;      )
;      (block
;       (assert
;        ("recommendation not met")
;        (req%spec.Directory.directories_are_in_next_layer. self@)
;      ))
;      (assume
;       (= tmp%1@ (spec.Directory.directories_are_in_next_layer.? self@))
;      )
;      (assume
;       (= tmp%2@ tmp%1@)
;     ))
;     (block
;      (assume
;       (not (spec.Directory.well_formed.? self@))
;      )
;      (assume
;       (= tmp%2@ false)
;    )))
;    (assume
;     (and
;      (and
;       (spec.Directory.well_formed.? self@)
;       (spec.Directory.directories_are_in_next_layer.? self@)
;      )
;      (spec.Directory.directories_match_arch.? self@)
;    ))
;    (switch
;     (block
;      (assume
;       (spec.Directory.well_formed.? self@)
;      )
;      (block
;       (assert
;        ("recommendation not met")
;        (req%spec.Directory.directories_are_in_next_layer. self@)
;      ))
;      (assume
;       (= tmp%3@ (spec.Directory.directories_are_in_next_layer.? self@))
;      )
;      (assume
;       (= tmp%4@ tmp%3@)
;     ))
;     (block
;      (assume
;       (not (spec.Directory.well_formed.? self@))
;      )
;      (assume
;       (= tmp%4@ false)
;    )))
;    (switch
;     (block
;      (assume
;       (and
;        tmp%4@
;        (spec.Directory.directories_match_arch.? self@)
;      ))
;      (assume
;       (has_type i@ NAT)
;      )
;      (switch
;       (block
;        (assume
;         (< (%I i@) (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;            (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;        ))))
;        (assume
;         (= tmp%6@ (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries
;            (%Poly%spec.Directory. self@)
;        ))))
;        (block
;         (assert
;          ("recommendation not met")
;          (req%pervasive.seq.Seq.index. TYPE%spec.NodeEntry. tmp%6@ i@)
;        ))
;        (assume
;         (= tmp%5@ (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;            (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;           ) i@
;        )))
;        (assume
;         (= tmp%7@ (is-spec.NodeEntry./Directory (%Poly%spec.NodeEntry. tmp%5@)))
;       ))
;       (block
;        (assume
;         (not (< (%I i@) (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;             (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;        )))))
;        (assume
;         (= tmp%7@ false)
;      )))
;      (switch
;       (block
;        (assume
;         tmp%7@
;        )
;        (assume
;         (= tmp%9@ (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries
;            (%Poly%spec.Directory. self@)
;        ))))
;        (block
;         (assert
;          ("recommendation not met")
;          (req%pervasive.seq.Seq.index. TYPE%spec.NodeEntry. tmp%9@ i@)
;        ))
;        (assume
;         (= tmp%8@ (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;            (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;           ) i@
;        )))
;        (assume
;         (= tmp%10@ (spec.Directory.inv.? (Poly%spec.Directory. (spec.NodeEntry./Directory/_0
;             (%Poly%spec.NodeEntry. tmp%8@)
;       ))))))
;       (block
;        (assume
;         (not tmp%7@)
;        )
;        (assume
;         (= tmp%10@ true)
;      )))
;      (assume
;       (= tmp%11@ (forall ((i$ Poly)) (!
;          (=>
;           (has_type i$ NAT)
;           (=>
;            (and
;             (< (%I i$) (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;                (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;             )))
;             (is-spec.NodeEntry./Directory (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry.
;                (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries (%Poly%spec.Directory.
;                   self@
;                 ))
;                ) i$
;            ))))
;            (spec.Directory.inv.? (Poly%spec.Directory. (spec.NodeEntry./Directory/_0 (%Poly%spec.NodeEntry.
;                (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;                  (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;                 ) i$
;          )))))))
;          :pattern ((pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;             (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;            ) i$
;     )))))))
;     (block
;      (assume
;       (not (and
;         tmp%4@
;         (spec.Directory.directories_match_arch.? self@)
;      )))
;      (assume
;       (= tmp%11@ (%B (pervasive.arbitrary.? BOOL)))
;    )))
;    (assume
;     (= %return@ tmp%11@)
;  )))
; 
;  ;; Function-Check-Recommends crate::spec::Directory::directories_match_arch
;  (check-valid
;   (declare-const %return@ Bool)
;   (declare-const self@ Poly)
;   (declare-const i@ Poly)
;   (declare-const tmp%1@ Poly)
;   (declare-const tmp%2@ Poly)
;   (declare-const tmp%3@ Bool)
;   (declare-const tmp%4@ Poly)
;   (declare-const tmp%5@ Poly)
;   (declare-const tmp%6@ Bool)
;   (axiom fuel_defaults)
;   (axiom (has_type self@ TYPE%spec.Directory.))
;   (block
;    (assume
;     (has_type i@ NAT)
;    )
;    (switch
;     (block
;      (assume
;       (< (%I i@) (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;          (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;      ))))
;      (assume
;       (= tmp%2@ (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries
;          (%Poly%spec.Directory. self@)
;      ))))
;      (block
;       (assert
;        ("recommendation not met")
;        (req%pervasive.seq.Seq.index. TYPE%spec.NodeEntry. tmp%2@ i@)
;      ))
;      (assume
;       (= tmp%1@ (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;          (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;         ) i@
;      )))
;      (assume
;       (= tmp%3@ (is-spec.NodeEntry./Directory (%Poly%spec.NodeEntry. tmp%1@)))
;     ))
;     (block
;      (assume
;       (not (< (%I i@) (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;           (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;      )))))
;      (assume
;       (= tmp%3@ false)
;    )))
;    (switch
;     (block
;      (assume
;       tmp%3@
;      )
;      (assume
;       (= tmp%5@ (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries
;          (%Poly%spec.Directory. self@)
;      ))))
;      (block
;       (assert
;        ("recommendation not met")
;        (req%pervasive.seq.Seq.index. TYPE%spec.NodeEntry. tmp%5@ i@)
;      ))
;      (assume
;       (= tmp%4@ (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;          (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;         ) i@
;      )))
;      (assume
;       (= tmp%6@ (= (spec.Directory./Directory/arch (%Poly%spec.Directory. (Poly%spec.Directory.
;            (spec.NodeEntry./Directory/_0 (%Poly%spec.NodeEntry. tmp%4@))
;          ))
;         ) (spec.Directory./Directory/arch (%Poly%spec.Directory. self@))
;     ))))
;     (block
;      (assume
;       (not tmp%3@)
;      )
;      (assume
;       (= tmp%6@ true)
;    )))
;    (assume
;     (= %return@ (forall ((i$ Poly)) (!
;        (=>
;         (has_type i$ NAT)
;         (=>
;          (and
;           (< (%I i$) (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;              (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;           )))
;           (is-spec.NodeEntry./Directory (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry.
;              (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries (%Poly%spec.Directory.
;                 self@
;               ))
;              ) i$
;          ))))
;          (= (spec.Directory./Directory/arch (%Poly%spec.Directory. (Poly%spec.Directory. (spec.NodeEntry./Directory/_0
;               (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;                  (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;                 ) i$
;            )))))
;           ) (spec.Directory./Directory/arch (%Poly%spec.Directory. self@))
;        )))
;        :pattern ((pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;           (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;          ) i$
;  ))))))))
; 
;  ;; Function-Check-Recommends crate::spec::Directory::frames_aligned
;  (check-valid
;   (declare-const %return@ Bool)
;   (declare-const self@ Poly)
;   (declare-const i@ Poly)
;   (declare-const tmp%1@ Poly)
;   (declare-const tmp%2@ Poly)
;   (declare-const tmp%3@ Bool)
;   (declare-const tmp%4@ Poly)
;   (declare-const tmp%5@ Poly)
;   (declare-const tmp%6@ Int)
;   (declare-const tmp%7@ Bool)
;   (axiom fuel_defaults)
;   (axiom (has_type self@ TYPE%spec.Directory.))
;   (block
;    (assume
;     (spec.Directory.well_formed.? self@)
;    )
;    (assume
;     (has_type i@ NAT)
;    )
;    (switch
;     (block
;      (assume
;       (< (%I i@) (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;          (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;      ))))
;      (assume
;       (= tmp%2@ (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries
;          (%Poly%spec.Directory. self@)
;      ))))
;      (block
;       (assert
;        ("recommendation not met")
;        (req%pervasive.seq.Seq.index. TYPE%spec.NodeEntry. tmp%2@ i@)
;      ))
;      (assume
;       (= tmp%1@ (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;          (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;         ) i@
;      )))
;      (assume
;       (= tmp%3@ (is-spec.NodeEntry./Page (%Poly%spec.NodeEntry. tmp%1@)))
;     ))
;     (block
;      (assume
;       (not (< (%I i@) (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;           (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;      )))))
;      (assume
;       (= tmp%3@ false)
;    )))
;    (switch
;     (block
;      (assume
;       tmp%3@
;      )
;      (assume
;       (= tmp%5@ (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries
;          (%Poly%spec.Directory. self@)
;      ))))
;      (block
;       (assert
;        ("recommendation not met")
;        (req%pervasive.seq.Seq.index. TYPE%spec.NodeEntry. tmp%5@ i@)
;      ))
;      (assume
;       (= tmp%4@ (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;          (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;         ) i@
;      )))
;      (block
;       (assert
;        ("recommendation not met")
;        (req%spec.Directory.entry_size. self@)
;      ))
;      (assume
;       (= tmp%6@ (spec.Directory.entry_size.? self@))
;      )
;      (assume
;       (= tmp%7@ (spec.aligned.? (I (spec.MemRegion./MemRegion/base (%Poly%spec.MemRegion. (Poly%spec.MemRegion.
;             (spec.NodeEntry./Page/_0 (%Poly%spec.NodeEntry. tmp%4@))
;          )))
;         ) (I tmp%6@)
;     ))))
;     (block
;      (assume
;       (not tmp%3@)
;      )
;      (assume
;       (= tmp%7@ true)
;    )))
;    (assume
;     (= %return@ (forall ((i$ Poly)) (!
;        (=>
;         (has_type i$ NAT)
;         (=>
;          (and
;           (< (%I i$) (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;              (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;           )))
;           (is-spec.NodeEntry./Page (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry.
;              (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries (%Poly%spec.Directory.
;                 self@
;               ))
;              ) i$
;          ))))
;          (spec.aligned.? (I (spec.MemRegion./MemRegion/base (%Poly%spec.MemRegion. (Poly%spec.MemRegion.
;               (spec.NodeEntry./Page/_0 (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry.
;                  (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries (%Poly%spec.Directory.
;                     self@
;                   ))
;                  ) i$
;            ))))))
;           ) (I (spec.Directory.entry_size.? self@))
;        )))
;        :pattern ((pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;           (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;          ) i$
;  ))))))))
; 
;  ;; Function-Check-Recommends crate::spec::Directory::inv
;  (check-valid
;   (declare-const %return@ Bool)
;   (declare-const self@ Poly)
;   (declare-const tmp%1@ Bool)
;   (declare-const tmp%2@ Bool)
;   (declare-const tmp%3@ Bool)
;   (declare-const tmp%4@ Bool)
;   (declare-const tmp%5@ Bool)
;   (declare-const tmp%6@ Bool)
;   (declare-const tmp%7@ Bool)
;   (declare-const tmp%8@ Bool)
;   (axiom fuel_defaults)
;   (axiom (has_type self@ TYPE%spec.Directory.))
;   (block
;    (switch
;     (block
;      (assume
;       (spec.Directory.well_formed.? self@)
;      )
;      (block
;       (assert
;        ("recommendation not met")
;        (req%spec.Directory.pages_match_entry_size. self@)
;      ))
;      (assume
;       (= tmp%1@ (spec.Directory.pages_match_entry_size.? self@))
;      )
;      (assume
;       (= tmp%2@ tmp%1@)
;     ))
;     (block
;      (assume
;       (not (spec.Directory.well_formed.? self@))
;      )
;      (assume
;       (= tmp%2@ false)
;    )))
;    (switch
;     (block
;      (assume
;       tmp%2@
;      )
;      (block
;       (assert
;        ("recommendation not met")
;        (req%spec.Directory.directories_are_in_next_layer. self@)
;      ))
;      (assume
;       (= tmp%3@ (spec.Directory.directories_are_in_next_layer.? self@))
;      )
;      (assume
;       (= tmp%4@ tmp%3@)
;     ))
;     (block
;      (assume
;       (not tmp%2@)
;      )
;      (assume
;       (= tmp%4@ false)
;    )))
;    (switch
;     (block
;      (assume
;       (and
;        tmp%4@
;        (spec.Directory.directories_match_arch.? self@)
;      ))
;      (block
;       (assert
;        ("recommendation not met")
;        (req%spec.Directory.directories_obey_invariant. self@)
;      ))
;      (assume
;       (= tmp%5@ (spec.Directory.directories_obey_invariant.? self@))
;      )
;      (assume
;       (= tmp%6@ tmp%5@)
;     ))
;     (block
;      (assume
;       (not (and
;         tmp%4@
;         (spec.Directory.directories_match_arch.? self@)
;      )))
;      (assume
;       (= tmp%6@ false)
;    )))
;    (switch
;     (block
;      (assume
;       tmp%6@
;      )
;      (block
;       (assert
;        ("recommendation not met")
;        (req%spec.Directory.frames_aligned. self@)
;      ))
;      (assume
;       (= tmp%7@ (spec.Directory.frames_aligned.? self@))
;      )
;      (assume
;       (= tmp%8@ tmp%7@)
;     ))
;     (block
;      (assume
;       (not tmp%6@)
;      )
;      (assume
;       (= tmp%8@ false)
;    )))
;    (assume
;     (= %return@ tmp%8@)
;  )))
; 
;  ;; Function-Check-Recommends crate::spec::Directory::interp
;  (check-valid
;   (declare-const %return@ spec.PageTableContents.)
;   (declare-const self@ Poly)
;   (axiom fuel_defaults)
;   (axiom (has_type self@ TYPE%spec.Directory.))
;   (assume
;    (= %return@ (spec.Directory.interp_aux.? self@ (I 0)))
;  ))
; 
;  ;; Function-Check-Recommends crate::spec::Directory::interp_aux
;  (check-valid
;   (declare-const %return@ spec.PageTableContents.)
;   (declare-const self@ Poly)
;   (declare-const i@ Poly)
;   (declare-const tmp%1@ Poly)
;   (declare-const tmp%2@ Poly)
;   (declare-const tmp%3@ Int)
;   (declare-const p@ spec.MemRegion.)
;   (declare-const tmp%4@ pervasive.map.Map<nat./spec.MemRegion.>.)
;   (declare-const tmp%%1@ spec.NodeEntry.)
;   (declare-const rem@ pervasive.map.Map<nat./spec.MemRegion.>.)
;   (declare-const tmp%5@ spec.PageTableContents.)
;   (declare-const tmp%6@ spec.PageTableContents.)
;   (axiom fuel_defaults)
;   (axiom (has_type self@ TYPE%spec.Directory.))
;   (axiom (has_type i@ NAT))
;   (block
;    (switch
;     (block
;      (assume
;       (spec.Directory.inv.? self@)
;      )
;      (switch
;       (block
;        (assume
;         (>= (%I i@) (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;            (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;        ))))
;        (assume
;         (= tmp%5@ (spec.PageTableContents./PageTableContents (%Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;            (pervasive.map.Map.empty.? NAT TYPE%spec.MemRegion.)
;           ) (%Poly%spec.Arch. (Poly%spec.Arch. (spec.Directory./Directory/arch (%Poly%spec.Directory.
;               self@
;       ))))))))
;       (block
;        (assume
;         (not (>= (%I i@) (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;             (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;        )))))
;        (assume
;         (= rem@ (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents.
;            (Poly%spec.PageTableContents. (spec.Directory.interp_aux.? self@ (I (nClip (+ (%I i@)
;                 1
;        )))))))))
;        (assume
;         (= tmp%2@ (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries
;            (%Poly%spec.Directory. self@)
;        ))))
;        (block
;         (assert
;          ("recommendation not met")
;          (req%pervasive.seq.Seq.index. TYPE%spec.NodeEntry. tmp%2@ i@)
;        ))
;        (assume
;         (= tmp%1@ (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;            (spec.Directory./Directory/entries (%Poly%spec.Directory. self@))
;           ) i@
;        )))
;        (assume
;         (= tmp%%1@ (%Poly%spec.NodeEntry. tmp%1@))
;        )
;        (switch
;         (block
;          (assume
;           (is-spec.NodeEntry./Page tmp%%1@)
;          )
;          (assume
;           (= p@ (spec.NodeEntry./Page/_0 (%Poly%spec.NodeEntry. (Poly%spec.NodeEntry. tmp%%1@))))
;          )
;          (block
;           (assert
;            ("recommendation not met")
;            (req%spec.Directory.entry_size. self@)
;          ))
;          (assume
;           (= tmp%3@ (spec.Directory.entry_size.? self@))
;          )
;          (assume
;           (= tmp%4@ (%Poly%pervasive.map.Map<nat./spec.MemRegion.>. (pervasive.map.Map.insert.?
;              NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. rem@) (I (
;                nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. self@)) (nClip
;                  (* (%I i@) tmp%3@)
;               )))
;              ) (Poly%spec.MemRegion. p@)
;         )))))
;         (block
;          (assume
;           (not (is-spec.NodeEntry./Page tmp%%1@))
;          )
;          (assume
;           (= tmp%4@ (ite
;             (is-spec.NodeEntry./Directory tmp%%1@)
;             (%Poly%pervasive.map.Map<nat./spec.MemRegion.>. (let
;               ((d$ (spec.NodeEntry./Directory/_0 (%Poly%spec.NodeEntry. (Poly%spec.NodeEntry. tmp%%1@)))))
;               (pervasive.map.Map.union_prefer_right.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                 rem@
;                ) (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                  (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                     (Poly%spec.Directory. d$) (I 0)
;             ))))))))
;             rem@
;        )))))
;        (assume
;         (= tmp%5@ (spec.PageTableContents./PageTableContents (%Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;            (Poly%pervasive.map.Map<nat./spec.MemRegion.>. tmp%4@)
;           ) (%Poly%spec.Arch. (Poly%spec.Arch. (spec.Directory./Directory/arch (%Poly%spec.Directory.
;               self@
;      )))))))))
;      (assume
;       (= tmp%6@ tmp%5@)
;     ))
;     (block
;      (assume
;       (not (spec.Directory.inv.? self@))
;      )
;      (assume
;       (= tmp%6@ (%Poly%spec.PageTableContents. (pervasive.arbitrary.? TYPE%spec.PageTableContents.)))
;    )))
;    (assume
;     (= %return@ tmp%6@)
;  )))
; 
; 
; 
;  ;; Function-Def crate::spec::Directory::inv_implies_interp_aux_inv
;  (check-valid
;   (declare-const self@ spec.Directory.)
;   (declare-const i@ Int)
;   (declare-const tmp%1@ Bool)
;   (declare-const i$1@ Poly)
;   (declare-const tmp%2@ Bool)
;   (declare-const tmp%3@ spec.Directory.)
;   (declare-const tmp%4@ Bool)
;   (declare-const tmp%5@ Int)
;   (declare-const tmp%6@ Bool)
;   (declare-const tmp%7@ Bool)
;   (declare-const rem@ pervasive.map.Map<nat./spec.MemRegion.>.)
;   (declare-const va@ Poly)
;   (declare-const tmp%8@ Bool)
;   (declare-const tmp%9@ Bool)
;   (declare-const tmp%10@ Bool)
;   (declare-const tmp%11@ Bool)
;   (declare-const tmp%12@ Bool)
;   (declare-const tmp%13@ Bool)
;   (declare-const tmp%14@ Bool)
;   (declare-const es@ Int)
;   (declare-const tmp%15@ Bool)
;   (declare-const tmp%16@ Bool)
;   (declare-const tmp%17@ Bool)
;   (declare-const tmp%18@ Bool)
;   (declare-const tmp%19@ Bool)
;   (declare-const tmp%20@ Bool)
;   (declare-const tmp%21@ Bool)
;   (declare-const tmp%22@ Bool)
;   (declare-const tmp%23@ Bool)
;   (declare-const tmp%24@ Bool)
;   (declare-const j@ Int)
;   (declare-const b1@ Poly)
;   (declare-const b2@ Poly)
;   (declare-const tmp%25@ Int)
;   (declare-const tmp%26@ Bool)
;   (declare-const tmp%27@ Bool)
;   (declare-const tmp%28@ Bool)
;   (declare-const tmp%29@ Bool)
;   (declare-const tmp%30@ Bool)
;   (declare-const tmp%31@ Bool)
;   (declare-const tmp%32@ Bool)
;   (declare-const tmp%33@ Int)
;   (declare-const tmp%34@ Bool)
;   (declare-const tmp%35@ Bool)
;   (declare-const tmp%36@ Bool)
;   (declare-const tmp%37@ Bool)
;   (declare-const tmp%38@ Bool)
;   (declare-const tmp%39@ Bool)
;   (declare-const tmp%40@ Bool)
;   (declare-const tmp%41@ Bool)
;   (declare-const tmp%42@ Bool)
;   (declare-const new_va@ Int)
;   (declare-const p@ spec.MemRegion.)
;   (declare-const tmp%43@ Bool)
;   (declare-const tmp%44@ Bool)
;   (declare-const tmp%45@ Bool)
;   (declare-const tmp%46@ Bool)
;   (declare-const tmp%47@ Bool)
;   (declare-const tmp%48@ Bool)
;   (declare-const tmp%49@ Bool)
;   (declare-const tmp%50@ Bool)
;   (declare-const tmp%51@ Bool)
;   (declare-const tmp%52@ Bool)
;   (declare-const tmp%53@ Bool)
;   (declare-const tmp%54@ Bool)
;   (declare-const tmp%55@ Bool)
;   (declare-const i1_interp@ pervasive.set.Set<nat.>.)
;   (declare-const d_interp@ pervasive.set.Set<nat.>.)
;   (declare-const d@ spec.Directory.)
;   (declare-const tmp%%2@ spec.NodeEntry.)
;   (declare-const tmp%56@ Bool)
;   (declare-const tmp%%1@ tuple%2.)
;   (declare-const c1@ Int)
;   (declare-const c2@ Int)
;   (declare-const tmp%57@ Bool)
;   (declare-const tmp%58@ Bool)
;   (declare-const interp@ spec.PageTableContents.)
;   (declare-const decrease%init0@ Int)
;   (declare-const decrease%init1@ Int)
;   (axiom fuel_defaults)
;   (axiom (has_type (Poly%spec.Directory. self@) TYPE%spec.Directory.))
;   (axiom (<= 0 i@))
;   (axiom (spec.Directory.inv.? (Poly%spec.Directory. self@)))
;   (block
; 
;        (assert
;         ("lemma ensures start")
;         (forall ((self2 spec.Directory.) (i2 Int)) (!
;             (= (ens%spec.Directory.inv_implies_interp_aux_inv. self2 i2) (and
;               (spec.PageTableContents.inv.? (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                  (Poly%spec.Directory. self2) (I i2)
;               )))
;               (forall ((va$ Poly)) (!
;                 (=>
;                  (has_type va$ NAT)
;                  (=>
;                   (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                     (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                       (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                          (Poly%spec.Directory. self2) (I i2)
;                     )))))
;                    ) va$
;                   )
;                   (>= (%I va$) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                         self2
;                       ))
;                      ) (nClip (* i2 (spec.Directory.entry_size.? (Poly%spec.Directory. self2))))
;                 )))))
;                 :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                    (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                      (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                         (Poly%spec.Directory. self2) (I i2)
;                    )))))
;                   ) va$
;               ))))
;               (forall ((va$ Poly)) (!
;                 (=>
;                  (has_type va$ NAT)
;                  (=>
;                   (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                     (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                       (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                          (Poly%spec.Directory. self2) (I i2)
;                     )))))
;                    ) va$
;                   )
;                   (<= (%I va$) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                         self2
;                       ))
;                      ) (nClip (* (spec.Directory.num_entries.? (Poly%spec.Directory. self2)) (spec.Directory.entry_size.?
;                         (Poly%spec.Directory. self2)
;                 ))))))))
;                 :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                    (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                      (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                         (Poly%spec.Directory. self2) (I i2)
;                    )))))
;                   ) va$
;             ))))))
;             :pattern ((ens%spec.Directory.inv_implies_interp_aux_inv. self2 i2))
;          )))
; 
;    (assume
;     (= decrease%init0@ (nClip (- (pervasive.seq.Seq.len.? TYPE%spec.ArchLayer. (Poly%pervasive.seq.Seq<spec.ArchLayer.>.
;          (spec.Arch./Arch/layers (%Poly%spec.Arch. (Poly%spec.Arch. (spec.Directory./Directory/arch
;              (%Poly%spec.Directory. (Poly%spec.Directory. self@))
;         )))))
;        ) (spec.Directory./Directory/layer (%Poly%spec.Directory. (Poly%spec.Directory. self@)))
;    ))))
;    (assume
;     (= decrease%init1@ (nClip (- (spec.Directory.num_entries.? (Poly%spec.Directory. self@))
;        i@
;    ))))
;    (assume
;     (= interp@ (spec.Directory.interp_aux.? (Poly%spec.Directory. self@) (I i@)))
;    )
;    (assume
;     (= tmp%1@ (spec.Directory.directories_obey_invariant.? (Poly%spec.Directory. self@)))
;    )
;    (block
;     (assert
;      ("assertion failure")
;      (req%pervasive.assert. tmp%1@)
;     )
;     (assume
;      (ens%pervasive.assert. tmp%1@)
;    ))
;    (deadend (block
;      (assume
;       (has_type i$1@ NAT)
;      )
;      (assume
;       (and
;        (< (%I i$1@) (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;           (spec.Directory./Directory/entries (%Poly%spec.Directory. (Poly%spec.Directory. self@)))
;        )))
;        (is-spec.NodeEntry./Directory (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry.
;           (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries (%Poly%spec.Directory.
;              (Poly%spec.Directory. self@)
;            ))
;           ) i$1@
;      )))))
;      (assume
;       (= tmp%2@ (spec.Directory.inv.? (Poly%spec.Directory. (spec.NodeEntry./Directory/_0 (
;            %Poly%spec.NodeEntry. (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;              (spec.Directory./Directory/entries (%Poly%spec.Directory. (Poly%spec.Directory. self@)))
;             ) i$1@
;      )))))))
;      (block
;       (assert
;        ("assertion failure")
;        (req%pervasive.assert. tmp%2@)
;       )
;       (assume
;        (ens%pervasive.assert. tmp%2@)
;      ))
;      (assume
;       (= tmp%3@ (spec.NodeEntry./Directory/_0 (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.?
;           TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries
;             (%Poly%spec.Directory. (Poly%spec.Directory. self@))
;            )
;           ) i$1@
;      )))))
;      (assert
;       ("could not prove termination")
;       (check_decrease_int.? (let
;         ((self!$ tmp%3@) (i!$ 0))
;         (nClip (- (pervasive.seq.Seq.len.? TYPE%spec.ArchLayer. (Poly%pervasive.seq.Seq<spec.ArchLayer.>.
;             (spec.Arch./Arch/layers (%Poly%spec.Arch. (Poly%spec.Arch. (spec.Directory./Directory/arch
;                 (%Poly%spec.Directory. (Poly%spec.Directory. self!$))
;            )))))
;           ) (spec.Directory./Directory/layer (%Poly%spec.Directory. (Poly%spec.Directory. self!$)))
;         ))
;        ) decrease%init0@ (check_decrease_int.? (let
;          ((self!$ tmp%3@) (i!$ 0))
;          (nClip (- (spec.Directory.num_entries.? (Poly%spec.Directory. self!$)) i!$))
;         ) decrease%init1@ false
;      )))
;      (block
;       (assert
;        ("precondition not satisfied")
;        (req%spec.Directory.inv_implies_interp_aux_inv. tmp%3@ 0)
;       )
;       (assume
;        (ens%spec.Directory.inv_implies_interp_aux_inv. tmp%3@ 0)
;      ))
;      (assert
;       ("assertion failed" "assertion failed")
;       (spec.PageTableContents.inv.? (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;          (Poly%spec.Directory. (spec.NodeEntry./Directory/_0 (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.?
;              TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries
;                (%Poly%spec.Directory. (Poly%spec.Directory. self@))
;               )
;              ) i$1@
;           )))
;          ) (I 0)
;    ))))))
;    (assume
;     (forall ((i$ Poly)) (!
;       (=>
;        (has_type i$ NAT)
;        (=>
;         (and
;          (< (%I i$) (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;             (spec.Directory./Directory/entries (%Poly%spec.Directory. (Poly%spec.Directory. self@)))
;          )))
;          (is-spec.NodeEntry./Directory (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry.
;             (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries (%Poly%spec.Directory.
;                (Poly%spec.Directory. self@)
;              ))
;             ) i$
;         ))))
;         (spec.PageTableContents.inv.? (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;            (Poly%spec.Directory. (spec.NodeEntry./Directory/_0 (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.?
;                TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries
;                  (%Poly%spec.Directory. (Poly%spec.Directory. self@))
;                 )
;                ) i$
;             )))
;            ) (I 0)
;       )))))
;       :pattern ((pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;          (spec.Directory./Directory/entries (%Poly%spec.Directory. (Poly%spec.Directory. self@)))
;         ) i$
;    )))))
;    (assume
;     (= tmp%4@ (spec.Arch.inv.? (Poly%spec.Arch. (spec.PageTableContents./PageTableContents/arch
;         (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;    )))))
;    (block
;     (assert
;      ("assertion failure")
;      (req%pervasive.assert. tmp%4@)
;     )
;     (assume
;      (ens%pervasive.assert. tmp%4@)
;    ))
;    (switch
;     (block
;      (assume
;       (>= i@ (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;          (spec.Directory./Directory/entries (%Poly%spec.Directory. (Poly%spec.Directory. self@)))
;     )))))
;     (block
;      (assume
;       (not (>= i@ (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;           (spec.Directory./Directory/entries (%Poly%spec.Directory. (Poly%spec.Directory. self@)))
;      )))))
;      (assume
;       (= tmp%5@ (nClip (+ i@ 1)))
;      )
;      (assert
;       ("could not prove termination")
;       (check_decrease_int.? (let
;         ((self!$ self@) (i!$ tmp%5@))
;         (nClip (- (pervasive.seq.Seq.len.? TYPE%spec.ArchLayer. (Poly%pervasive.seq.Seq<spec.ArchLayer.>.
;             (spec.Arch./Arch/layers (%Poly%spec.Arch. (Poly%spec.Arch. (spec.Directory./Directory/arch
;                 (%Poly%spec.Directory. (Poly%spec.Directory. self!$))
;            )))))
;           ) (spec.Directory./Directory/layer (%Poly%spec.Directory. (Poly%spec.Directory. self!$)))
;         ))
;        ) decrease%init0@ (check_decrease_int.? (let
;          ((self!$ self@) (i!$ tmp%5@))
;          (nClip (- (spec.Directory.num_entries.? (Poly%spec.Directory. self!$)) i!$))
;         ) decrease%init1@ false
;      )))
;      (block
;       (assert
;        ("precondition not satisfied")
;        (req%spec.Directory.inv_implies_interp_aux_inv. self@ tmp%5@)
;       )
;       (assume
;        (ens%spec.Directory.inv_implies_interp_aux_inv. self@ tmp%5@)
;      ))
;      (switch
;       (block
;        (assume
;         (is-spec.NodeEntry./Page (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry.
;            (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries (%Poly%spec.Directory.
;               (Poly%spec.Directory. self@)
;             ))
;            ) (I i@)
;        ))))
;        (assume
;         (= rem@ (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents.
;            (Poly%spec.PageTableContents. (spec.Directory.interp_aux.? (Poly%spec.Directory. self@)
;              (I (nClip (+ i@ 1)))
;        ))))))
;        (assume
;         (= tmp%6@ (= (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents.
;             (Poly%spec.PageTableContents. (spec.Directory.interp_aux.? (Poly%spec.Directory. self@)
;               (I i@)
;            )))
;           ) (%Poly%pervasive.map.Map<nat./spec.MemRegion.>. (pervasive.map.Map.insert.? NAT TYPE%spec.MemRegion.
;             (Poly%pervasive.map.Map<nat./spec.MemRegion.>. rem@) (I (nClip (+ (spec.Directory./Directory/base_vaddr
;                 (%Poly%spec.Directory. (Poly%spec.Directory. self@))
;                ) (nClip (* i@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;              ))
;             ) (Poly%spec.MemRegion. (spec.NodeEntry./Page/_0 (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.?
;                 TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries
;                   (%Poly%spec.Directory. (Poly%spec.Directory. self@))
;                  )
;                 ) (I i@)
;        )))))))))
;        (block
;         (assume
;          (ens%pervasive.assume. tmp%6@)
;        ))
;        (assume
;         (= tmp%7@ (= (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;             (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                (spec.Directory.interp_aux.? (Poly%spec.Directory. self@) (I i@))
;            ))))
;           ) (pervasive.set.Set.insert.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;             (Poly%pervasive.map.Map<nat./spec.MemRegion.>. rem@)
;            ) (I (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                  self@
;                ))
;               ) (nClip (* i@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;        )))))))
;        (block
;         (assert
;          ("assertion failure")
;          (req%pervasive.assert. tmp%7@)
;         )
;         (assume
;          (ens%pervasive.assert. tmp%7@)
;       )))
;       (block
;        (assume
;         (not (is-spec.NodeEntry./Page (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry.
;             (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries (%Poly%spec.Directory.
;                (Poly%spec.Directory. self@)
;              ))
;             ) (I i@)
;    )))))))))
;    (deadend (block
;      (assume
;       (has_type va@ NAT)
;      )
;      (assume
;       (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;         (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;           (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;         ))
;        ) va@
;      ))
;      (switch
;       (block
;        (assume
;         (>= i@ (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;            (spec.Directory./Directory/entries (%Poly%spec.Directory. (Poly%spec.Directory. self@)))
;       )))))
;       (block
;        (assume
;         (not (>= i@ (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;             (spec.Directory./Directory/entries (%Poly%spec.Directory. (Poly%spec.Directory. self@)))
;        )))))
;        (assume
;         (= j@ (nClip (+ i@ 1)))
;        )
;        (assert
;         ("could not prove termination")
;         (check_decrease_int.? (let
;           ((self!$ self@) (i!$ j@))
;           (nClip (- (pervasive.seq.Seq.len.? TYPE%spec.ArchLayer. (Poly%pervasive.seq.Seq<spec.ArchLayer.>.
;               (spec.Arch./Arch/layers (%Poly%spec.Arch. (Poly%spec.Arch. (spec.Directory./Directory/arch
;                   (%Poly%spec.Directory. (Poly%spec.Directory. self!$))
;              )))))
;             ) (spec.Directory./Directory/layer (%Poly%spec.Directory. (Poly%spec.Directory. self!$)))
;           ))
;          ) decrease%init0@ (check_decrease_int.? (let
;            ((self!$ self@) (i!$ j@))
;            (nClip (- (spec.Directory.num_entries.? (Poly%spec.Directory. self!$)) i!$))
;           ) decrease%init1@ false
;        )))
;        (block
;         (assert
;          ("precondition not satisfied")
;          (req%spec.Directory.inv_implies_interp_aux_inv. self@ j@)
;         )
;         (assume
;          (ens%spec.Directory.inv_implies_interp_aux_inv. self@ j@)
;        ))
; 
;        ; ensures
;        (assert
;         ("lemma ensures")
;         (forall ((self2 spec.Directory.) (i2 Int)) (!
;             (= (ens%spec.Directory.inv_implies_interp_aux_inv. self2 i2) (and
;               (spec.PageTableContents.inv.? (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                  (Poly%spec.Directory. self2) (I i2)
;               )))
;               (forall ((va$ Poly)) (!
;                 (=>
;                  (has_type va$ NAT)
;                  (=>
;                   (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                     (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                       (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                          (Poly%spec.Directory. self2) (I i2)
;                     )))))
;                    ) va$
;                   )
;                   (>= (%I va$) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                         self2
;                       ))
;                      ) (nClip (* i2 (spec.Directory.entry_size.? (Poly%spec.Directory. self2))))
;                 )))))
;                 :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                    (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                      (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                         (Poly%spec.Directory. self2) (I i2)
;                    )))))
;                   ) va$
;               ))))
;               (forall ((va$ Poly)) (!
;                 (=>
;                  (has_type va$ NAT)
;                  (=>
;                   (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                     (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                       (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                          (Poly%spec.Directory. self2) (I i2)
;                     )))))
;                    ) va$
;                   )
;                   (<= (%I va$) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                         self2
;                       ))
;                      ) (nClip (* (spec.Directory.num_entries.? (Poly%spec.Directory. self2)) (spec.Directory.entry_size.?
;                         (Poly%spec.Directory. self2)
;                 ))))))))
;                 :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                    (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                      (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                         (Poly%spec.Directory. self2) (I i2)
;                    )))))
;                   ) va$
;             ))))))
;             :pattern ((ens%spec.Directory.inv_implies_interp_aux_inv. self2 i2))
;          )))
; 
; 
;        ; (assume
;        ;  (forall ((va$ Poly)) (!
;        ;             (=>
;        ;              (has_type va$ NAT)
;        ;              (=>
;        ;               (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;        ;                 (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;        ;                   (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;        ;                      (Poly%spec.Directory. self@) (I j@)
;        ;                 )))))
;        ;                ) va$
;        ;               )
;        ;               (>= (%I va$) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;        ;                     self@
;        ;                   ))
;        ;                  ) (nClip (* j@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;        ;             )))))
;        ;             :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;        ;                (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;        ;                  (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;        ;                     (Poly%spec.Directory. self@) (I j@)
;        ;                )))))
;        ;               ) va$
;        ;         )))))
;        (assume
;         (= tmp%8@ (forall ((va$ Poly)) (!
;            (=>
;             (has_type va$ NAT)
;             (=>
;              (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                  (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                     (Poly%spec.Directory. self@) (I j@)
;                )))))
;               ) va$
;              )
;              (>= (%I va$) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                    self@
;                  ))
;                 ) (nClip (* j@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;            )))))
;            :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;               (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                 (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                    (Poly%spec.Directory. self@) (I j@)
;               )))))
;              ) va$
;        ))))))
;        (block
;         (assert
;          ("assertion failure ASSERT")
;          (req%pervasive.assert. tmp%8@)
;         )
;         (assume
;          (ens%pervasive.assert. tmp%8@)
;        ))
;        (assume
;         (= tmp%9@ (forall ((va$ Poly)) (!
;            (=>
;             (has_type va$ NAT)
;             (=>
;              (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                  (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                     (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;                )))))
;               ) va$
;              )
;              (>= (%I va$) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                    self@
;                  ))
;                 ) (nClip (* (nClip (+ i@ 1)) (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;            )))))
;            :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;               (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                 (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                    (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;               )))))
;              ) va$
;        ))))))
;        (block
;         (assume
;          (ens%pervasive.assume. tmp%9@)
;        ))
;        (switch
;         (block
;          (assume
;           (is-spec.NodeEntry./Page (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry.
;              (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries (%Poly%spec.Directory.
;                 (Poly%spec.Directory. self@)
;               ))
;              ) (I i@)
;          ))))
;          (assume
;           (= tmp%10@ (= (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;               (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                  (spec.Directory.interp_aux.? (Poly%spec.Directory. self@) (I i@))
;              ))))
;             ) (pervasive.set.Set.insert.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;               (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                 (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                    (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;               )))))
;              ) (I (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                    self@
;                  ))
;                 ) (nClip (* i@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;          )))))))
;          (block
;           (assert
;            ("assertion failure")
;            (req%pervasive.assert. tmp%10@)
;           )
;           (assume
;            (ens%pervasive.assert. tmp%10@)
;          ))
;          (switch
;           (block
;            (assume
;             (< (%I va@) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                   self@
;                 ))
;                ) (nClip (* i@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;            ))))
;            (assume
;             (= tmp%11@ (>= (%I va@) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;                   (Poly%spec.Directory. self@)
;                  )
;                 ) (nClip (* (nClip (+ i@ 1)) (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;            )))))
;            (block
;             (assert
;              ("assertion failure")
;              (req%pervasive.assert. tmp%11@)
;             )
;             (assume
;              (ens%pervasive.assert. tmp%11@)
;            ))
;            (assume
;             (= es@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;            )
;            (block
;             (assume
;              (ens%lib.mul_distributive. i@ es@)
;            ))
;            (assume
;             (= tmp%12@ (= (nClip (* (nClip (+ i@ 1)) es@)) (nClip (+ (nClip (* i@ es@)) es@))))
;            )
;            (block
;             (assume
;              (ens%pervasive.assume. tmp%12@)
;            ))
;            (assume
;             (= tmp%13@ (= (nClip (* (nClip (+ i@ 1)) (spec.Directory.entry_size.? (Poly%spec.Directory.
;                   self@
;                )))
;               ) (nClip (+ (nClip (* i@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;                 (spec.Directory.entry_size.? (Poly%spec.Directory. self@))
;            )))))
;            (block
;             (assume
;              (ens%pervasive.assume. tmp%13@)
;            ))
;            (assume
;             (= tmp%14@ (>= (%I va@) (nClip (+ (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;                     (Poly%spec.Directory. self@)
;                    )
;                   ) (nClip (* i@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;                  )
;                 ) (spec.Directory.entry_size.? (Poly%spec.Directory. self@))
;            )))))
;            (block
;             (assert
;              ("assertion failure")
;              (req%pervasive.assert. tmp%14@)
;             )
;             (assume
;              (ens%pervasive.assert. tmp%14@)
;            ))
;            (block
;             (assert
;              ("assertion failure")
;              (req%pervasive.assert. false)
;             )
;             (assume
;              (ens%pervasive.assert. false)
;           )))
;           (block
;            (assume
;             (not (< (%I va@) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;                   (Poly%spec.Directory. self@)
;                  )
;                 ) (nClip (* i@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;            )))))
;            (switch
;             (block
;              (assume
;               (= (%I va@) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                     self@
;                   ))
;                  ) (nClip (* i@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;              ))))
;              (assume
;               (= tmp%15@ (= (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
;                    NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                      (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;                     )
;                    ) va@
;                  ))
;                 ) (spec.Directory.entry_size.? (Poly%spec.Directory. self@))
;              )))
;              (block
;               (assert
;                ("assertion failure")
;                (req%pervasive.assert. tmp%15@)
;               )
;               (assume
;                (ens%pervasive.assert. tmp%15@)
;              ))
;              (assume
;               (= tmp%16@ (spec.Directory.well_formed.? (Poly%spec.Directory. self@)))
;              )
;              (block
;               (assert
;                ("assertion failure")
;                (req%pervasive.assert. tmp%16@)
;               )
;               (assume
;                (ens%pervasive.assert. tmp%16@)
;              ))
;              (assume
;               (= tmp%17@ (spec.aligned.? (I (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;                    (Poly%spec.Directory. self@)
;                  ))
;                 ) (I (nClip (* (spec.Directory.entry_size.? (Poly%spec.Directory. self@)) (spec.Directory.num_entries.?
;                     (Poly%spec.Directory. self@)
;              )))))))
;              (block
;               (assume
;                (ens%pervasive.assume. tmp%17@)
;              ))
;              (assume
;               (= tmp%18@ (spec.aligned.? (I (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;                    (Poly%spec.Directory. self@)
;                  ))
;                 ) (I (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;              )))
;              (block
;               (assume
;                (ens%pervasive.assume. tmp%18@)
;              ))
;              (assume
;               (= tmp%19@ (= (mod (nClip (* i@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;                  (spec.Directory.entry_size.? (Poly%spec.Directory. self@))
;                 ) 0
;              )))
;              (block
;               (assume
;                (ens%pervasive.assume. tmp%19@)
;              ))
;              (assume
;               (= tmp%20@ (spec.aligned.? (I (nClip (* i@ (spec.Directory.entry_size.? (Poly%spec.Directory.
;                      self@
;                  ))))
;                 ) (I (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;              )))
;              (block
;               (assert
;                ("assertion failure")
;                (req%pervasive.assert. tmp%20@)
;               )
;               (assume
;                (ens%pervasive.assert. tmp%20@)
;              ))
;              (assume
;               (= tmp%21@ (spec.aligned.? (I (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;                      (Poly%spec.Directory. self@)
;                     )
;                    ) (nClip (* i@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;                  ))
;                 ) (I (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;              )))
;              (block
;               (assume
;                (ens%pervasive.assume. tmp%21@)
;              ))
;              (assume
;               (= tmp%22@ (spec.aligned.? va@ (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion.
;                    (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                      (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                         interp@
;                      )))
;                     ) va@
;              )))))))
;              (block
;               (assert
;                ("assertion failure")
;                (req%pervasive.assert. tmp%22@)
;               )
;               (assume
;                (ens%pervasive.assert. tmp%22@)
;             )))
;             (block
;              (assume
;               (not (= (%I va@) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;                     (Poly%spec.Directory. self@)
;                    )
;                   ) (nClip (* i@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;              )))))
;              (assume
;               (= tmp%23@ (spec.aligned.? va@ (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion.
;                    (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                      (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                         interp@
;                      )))
;                     ) va@
;              )))))))
;              (block
;               (assert
;                ("assertion failure")
;                (req%pervasive.assert. tmp%23@)
;               )
;               (assume
;                (ens%pervasive.assert. tmp%23@)
;          ))))))
;          (assume
;           (= tmp%24@ (spec.aligned.? (I (spec.MemRegion./MemRegion/base (%Poly%spec.MemRegion. (
;                 pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                  (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                     interp@
;                  )))
;                 ) va@
;              )))
;             ) (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
;                 NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                   (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;                  )
;                 ) va@
;          )))))))
;          (block
;           (assert
;            ("assertion failure")
;            (req%pervasive.assert. tmp%24@)
;           )
;           (assume
;            (ens%pervasive.assert. tmp%24@)
;         )))
;         (block
;          (assume
;           (not (is-spec.NodeEntry./Page (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry.
;               (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries (%Poly%spec.Directory.
;                  (Poly%spec.Directory. self@)
;                ))
;               ) (I i@)
;      )))))))))
;      (assert
;       ("assertion failed" "assertion failed")
;       (and
;        (spec.aligned.? va@ (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
;             NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;               (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;              )
;             ) va@
;        )))))
;        (spec.aligned.? (I (spec.MemRegion./MemRegion/base (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
;             NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;               (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;              )
;             ) va@
;          )))
;         ) (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
;             NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;               (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;              )
;             ) va@
;    )))))))))
;    (assume
;     (forall ((va$ Poly)) (!
;       (=>
;        (has_type va$ NAT)
;        (=>
;         (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;           (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;             (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;           ))
;          ) va$
;         )
;         (and
;          (spec.aligned.? va$ (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
;               NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                 (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;                )
;               ) va$
;          )))))
;          (spec.aligned.? (I (spec.MemRegion./MemRegion/base (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
;               NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                 (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;                )
;               ) va$
;            )))
;           ) (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
;               NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                 (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;                )
;               ) va$
;       ))))))))
;       :pattern ((pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;          (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;             interp@
;          )))
;         ) va$
;    )))))
;    (deadend (block
;      (assume
;       (has_type b1@ NAT)
;      )
;      (assume
;       (has_type b2@ NAT)
;      )
;      (assume
;       (and
;        (and
;         (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;           (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;             (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;           ))
;          ) b1@
;         )
;         (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;           (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;             (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;           ))
;          ) b2@
;        ))
;        (not (= b1@ b2@))
;      ))
;      (switch
;       (block
;        (assume
;         (>= i@ (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;            (spec.Directory./Directory/entries (%Poly%spec.Directory. (Poly%spec.Directory. self@)))
;       )))))
;       (block
;        (assume
;         (not (>= i@ (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;             (spec.Directory./Directory/entries (%Poly%spec.Directory. (Poly%spec.Directory. self@)))
;        )))))
;        (assume
;         (= tmp%25@ (nClip (+ i@ 1)))
;        )
;        (assert
;         ("could not prove termination")
;         (check_decrease_int.? (let
;           ((self!$ self@) (i!$ tmp%25@))
;           (nClip (- (pervasive.seq.Seq.len.? TYPE%spec.ArchLayer. (Poly%pervasive.seq.Seq<spec.ArchLayer.>.
;               (spec.Arch./Arch/layers (%Poly%spec.Arch. (Poly%spec.Arch. (spec.Directory./Directory/arch
;                   (%Poly%spec.Directory. (Poly%spec.Directory. self!$))
;              )))))
;             ) (spec.Directory./Directory/layer (%Poly%spec.Directory. (Poly%spec.Directory. self!$)))
;           ))
;          ) decrease%init0@ (check_decrease_int.? (let
;            ((self!$ self@) (i!$ tmp%25@))
;            (nClip (- (spec.Directory.num_entries.? (Poly%spec.Directory. self!$)) i!$))
;           ) decrease%init1@ false
;        )))
;        (block
;         (assert
;          ("precondition not satisfied")
;          (req%spec.Directory.inv_implies_interp_aux_inv. self@ tmp%25@)
;         )
;         (assume
;          (ens%spec.Directory.inv_implies_interp_aux_inv. self@ tmp%25@)
;        ))
;        (assume
;         (= tmp%26@ (forall ((va$ Poly)) (!
;            (=>
;             (has_type va$ NAT)
;             (=>
;              (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                  (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                     (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;                )))))
;               ) va$
;              )
;              (>= (%I va$) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                    self@
;                  ))
;                 ) (nClip (* (nClip (+ i@ 1)) (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;            )))))
;            :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;               (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                 (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                    (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;               )))))
;              ) va$
;        ))))))
;        (block
;         (assume
;          (ens%pervasive.assume. tmp%26@)
;        ))
;        (assume
;         (= tmp%27@ (forall ((va$ Poly)) (!
;            (=>
;             (has_type va$ NAT)
;             (=>
;              (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                  (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                     (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;                )))))
;               ) va$
;              )
;              (<= (%I va$) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                    self@
;                  ))
;                 ) (nClip (* (spec.Directory.num_entries.? (Poly%spec.Directory. self@)) (spec.Directory.entry_size.?
;                    (Poly%spec.Directory. self@)
;            ))))))))
;            :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;               (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                 (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                    (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;               )))))
;              ) va$
;        ))))))
;        (block
;         (assume
;          (ens%pervasive.assume. tmp%27@)
;        ))
;        (assume
;         (= tmp%%1@ (ite
;           (< (%I b1@) (%I b2@))
;           (tuple%2./tuple%2 b1@ b2@)
;           (tuple%2./tuple%2 b2@ b1@)
;        )))
;        (assume
;         (= c1@ (%I (tuple%2./tuple%2/field%0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%1@)))))
;        )
;        (assume
;         (= c2@ (%I (tuple%2./tuple%2/field%1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%1@)))))
;        )
;        (assume
;         (= tmp%28@ (< c1@ c2@))
;        )
;        (block
;         (assert
;          ("assertion failure")
;          (req%pervasive.assert. tmp%28@)
;         )
;         (assume
;          (ens%pervasive.assert. tmp%28@)
;        ))
;        (assume
;         (= tmp%%2@ (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;             (spec.Directory./Directory/entries (%Poly%spec.Directory. (Poly%spec.Directory. self@)))
;            ) (I i@)
;        ))))
;        (switch
;         (block
;          (assume
;           (is-spec.NodeEntry./Page tmp%%2@)
;          )
;          (assume
;           (= p@ (spec.NodeEntry./Page/_0 (%Poly%spec.NodeEntry. (Poly%spec.NodeEntry. tmp%%2@))))
;          )
;          (assume
;           (= new_va@ (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                 self@
;               ))
;              ) (nClip (* i@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;          ))))
;          (deadend (block
;            (assume
;             true
;            )
;            (switch
;             (block
;              (assume
;               (and
;                (not (= c1@ new_va@))
;                (not (= c2@ new_va@))
;              ))
;              (assume
;               (= tmp%29@ (not (spec.overlap.? (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I
;                      c1@
;                     )
;                    ) (%I (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
;                         NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                           (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;                          )
;                         ) (I c1@)
;                   ))))))
;                  ) (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I c2@)) (%I (I (spec.MemRegion./MemRegion/size
;                       (%Poly%spec.MemRegion. (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                          (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                             interp@
;                          )))
;                         ) (I c2@)
;              )))))))))))
;              (block
;               (assert
;                ("assertion failure")
;                (req%pervasive.assert. tmp%29@)
;               )
;               (assume
;                (ens%pervasive.assert. tmp%29@)
;             )))
;             (block
;              (assume
;               (not (and
;                 (not (= c1@ new_va@))
;                 (not (= c2@ new_va@))
;              )))
;              (switch
;               (block
;                (assume
;                 (= c1@ new_va@)
;                )
;                (assume
;                 (= tmp%30@ (= (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                     (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                        (spec.Directory.interp_aux.? (Poly%spec.Directory. self@) (I i@))
;                    ))))
;                   ) (pervasive.set.Set.insert.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                     (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                       (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                          (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;                     )))))
;                    ) (I new_va@)
;                ))))
;                (block
;                 (assert
;                  ("assertion failure")
;                  (req%pervasive.assert. tmp%30@)
;                 )
;                 (assume
;                  (ens%pervasive.assert. tmp%30@)
;                ))
;                (assume
;                 (= tmp%31@ (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                    (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                      (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                         (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;                    )))))
;                   ) (I c2@)
;                )))
;                (block
;                 (assert
;                  ("assertion failure")
;                  (req%pervasive.assert. tmp%31@)
;                 )
;                 (assume
;                  (ens%pervasive.assert. tmp%31@)
;                ))
;                (assume
;                 (= tmp%32@ (>= c2@ (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;                       (Poly%spec.Directory. self@)
;                      )
;                     ) (nClip (* (nClip (+ i@ 1)) (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;                )))))
;                (block
;                 (assert
;                  ("assertion failure")
;                  (req%pervasive.assert. tmp%32@)
;                 )
;                 (assume
;                  (ens%pervasive.assert. tmp%32@)
;                ))
;                (assume
;                 (= tmp%33@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;                )
;                (block
;                 (assume
;                  (ens%lib.mul_distributive. i@ tmp%33@)
;                ))
;                (assume
;                 (= tmp%34@ (= (nClip (+ (nClip (* i@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;                     (spec.Directory.entry_size.? (Poly%spec.Directory. self@))
;                    )
;                   ) (nClip (* (nClip (+ i@ 1)) (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;                )))
;                (block
;                 (assume
;                  (ens%pervasive.assume. tmp%34@)
;                ))
;                (assume
;                 (= tmp%35@ (= (nClip (+ (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;                         (Poly%spec.Directory. self@)
;                        )
;                       ) (nClip (* i@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;                      )
;                     ) (spec.Directory.entry_size.? (Poly%spec.Directory. self@))
;                    )
;                   ) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                        self@
;                      ))
;                     ) (nClip (* (nClip (+ i@ 1)) (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;                )))))
;                (block
;                 (assert
;                  ("assertion failure")
;                  (req%pervasive.assert. tmp%35@)
;                 )
;                 (assume
;                  (ens%pervasive.assert. tmp%35@)
;                ))
;                (assume
;                 (= tmp%36@ (= (nClip (+ c1@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;                   (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                        self@
;                      ))
;                     ) (nClip (* (nClip (+ i@ 1)) (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;                )))))
;                (block
;                 (assert
;                  ("assertion failure")
;                  (req%pervasive.assert. tmp%36@)
;                 )
;                 (assume
;                  (ens%pervasive.assert. tmp%36@)
;                ))
;                (assume
;                 (= tmp%37@ (not (spec.overlap.? (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I
;                        c1@
;                       )
;                      ) (%I (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
;                           NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                             (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;                            )
;                           ) (I c1@)
;                     ))))))
;                    ) (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I c2@)) (%I (I (spec.MemRegion./MemRegion/size
;                         (%Poly%spec.MemRegion. (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                            (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                               interp@
;                            )))
;                           ) (I c2@)
;                )))))))))))
;                (block
;                 (assert
;                  ("assertion failure")
;                  (req%pervasive.assert. tmp%37@)
;                 )
;                 (assume
;                  (ens%pervasive.assert. tmp%37@)
;               )))
;               (block
;                (assume
;                 (not (= c1@ new_va@))
;                )
;                (assume
;                 (= tmp%38@ (= c2@ new_va@))
;                )
;                (block
;                 (assert
;                  ("assertion failure")
;                  (req%pervasive.assert. tmp%38@)
;                 )
;                 (assume
;                  (ens%pervasive.assert. tmp%38@)
;                ))
;                (assume
;                 (= tmp%39@ (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                    (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                      (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                         (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;                    )))))
;                   ) (I c1@)
;                )))
;                (block
;                 (assert
;                  ("assertion failure")
;                  (req%pervasive.assert. tmp%39@)
;                 )
;                 (assume
;                  (ens%pervasive.assert. tmp%39@)
;                ))
;                (assume
;                 (= tmp%40@ (>= c1@ (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;                       (Poly%spec.Directory. self@)
;                      )
;                     ) (nClip (* (nClip (+ i@ 1)) (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;                )))))
;                (block
;                 (assert
;                  ("assertion failure")
;                  (req%pervasive.assert. tmp%40@)
;                 )
;                 (assume
;                  (ens%pervasive.assert. tmp%40@)
;                ))
;                (assume
;                 (= tmp%41@ (= c2@ (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;                       (Poly%spec.Directory. self@)
;                      )
;                     ) (nClip (* i@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;                )))))
;                (block
;                 (assert
;                  ("assertion failure")
;                  (req%pervasive.assert. tmp%41@)
;                 )
;                 (assume
;                  (ens%pervasive.assert. tmp%41@)
;                ))
;                (assume
;                 (= tmp%42@ (>= c1@ c2@))
;                )
;                (block
;                 (assume
;                  (ens%pervasive.assume. tmp%42@)
;                ))
;                (block
;                 (assert
;                  ("assertion failure")
;                  (req%pervasive.assert. false)
;                 )
;                 (assume
;                  (ens%pervasive.assert. false)
;            ))))))
;            (assert
;             ("assertion failed" "assertion failed")
;             (not (spec.overlap.? (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I c1@)) (%I
;                  (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
;                      NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                        (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;                       )
;                      ) (I c1@)
;                ))))))
;               ) (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I c2@)) (%I (I (spec.MemRegion./MemRegion/size
;                    (%Poly%spec.MemRegion. (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                       (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                          interp@
;                       )))
;                      ) (I c2@)
;          ))))))))))))
;          (assume
;           (not (spec.overlap.? (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I c1@)) (%I
;                (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
;                    NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                      (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;                     )
;                    ) (I c1@)
;              ))))))
;             ) (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I c2@)) (%I (I (spec.MemRegion./MemRegion/size
;                  (%Poly%spec.MemRegion. (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                     (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                        interp@
;                     )))
;                    ) (I c2@)
;         )))))))))))
;         (block
;          (assume
;           (not (is-spec.NodeEntry./Page tmp%%2@))
;          )
;          (switch
;           (block
;            (assume
;             (is-spec.NodeEntry./Directory tmp%%2@)
;            )
;            (assume
;             (= d@ (spec.NodeEntry./Directory/_0 (%Poly%spec.NodeEntry. (Poly%spec.NodeEntry. tmp%%2@))))
;            )
;            (deadend (block
;              (assume
;               true
;              )
;              (assert
;               ("could not prove termination")
;               (check_decrease_int.? (let
;                 ((self!$ d@) (i!$ 0))
;                 (nClip (- (pervasive.seq.Seq.len.? TYPE%spec.ArchLayer. (Poly%pervasive.seq.Seq<spec.ArchLayer.>.
;                     (spec.Arch./Arch/layers (%Poly%spec.Arch. (Poly%spec.Arch. (spec.Directory./Directory/arch
;                         (%Poly%spec.Directory. (Poly%spec.Directory. self!$))
;                    )))))
;                   ) (spec.Directory./Directory/layer (%Poly%spec.Directory. (Poly%spec.Directory. self!$)))
;                 ))
;                ) decrease%init0@ (check_decrease_int.? (let
;                  ((self!$ d@) (i!$ 0))
;                  (nClip (- (spec.Directory.num_entries.? (Poly%spec.Directory. self!$)) i!$))
;                 ) decrease%init1@ false
;              )))
;              (block
;               (assert
;                ("precondition not satisfied")
;                (req%spec.Directory.inv_implies_interp_aux_inv. d@ 0)
;               )
;               (assume
;                (ens%spec.Directory.inv_implies_interp_aux_inv. d@ 0)
;              ))
;              (assume
;               (= tmp%43@ (forall ((va$ Poly)) (!
;                  (=>
;                   (has_type va$ NAT)
;                   (=>
;                    (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                      (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                        (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                           (Poly%spec.Directory. d@) (I 0)
;                      )))))
;                     ) va$
;                    )
;                    (<= (%I va$) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                          d@
;                        ))
;                       ) (nClip (* (spec.Directory.num_entries.? (Poly%spec.Directory. d@)) (spec.Directory.entry_size.?
;                          (Poly%spec.Directory. d@)
;                  ))))))))
;                  :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                     (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                       (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                          (Poly%spec.Directory. d@) (I 0)
;                     )))))
;                    ) va$
;              ))))))
;              (block
;               (assume
;                (ens%pervasive.assume. tmp%43@)
;              ))
;              (assume
;               (= tmp%44@ (forall ((va$ Poly)) (!
;                  (=>
;                   (has_type va$ NAT)
;                   (=>
;                    (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                      (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                        (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                           (Poly%spec.Directory. d@) (I 0)
;                      )))))
;                     ) va$
;                    )
;                    (>= (%I va$) (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                        d@
;                  ))))))
;                  :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                     (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                       (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                          (Poly%spec.Directory. d@) (I 0)
;                     )))))
;                    ) va$
;              ))))))
;              (block
;               (assert
;                ("assertion failure")
;                (req%pervasive.assert. tmp%44@)
;               )
;               (assume
;                (ens%pervasive.assert. tmp%44@)
;              ))
;              (assume
;               (= tmp%45@ (forall ((va$ Poly)) (!
;                  (=>
;                   (has_type va$ NAT)
;                   (=>
;                    (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                      (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                        (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                           (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;                      )))))
;                     ) va$
;                    )
;                    (>= (%I va$) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                          self@
;                        ))
;                       ) (nClip (* (nClip (+ i@ 1)) (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;                  )))))
;                  :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                     (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                       (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                          (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;                     )))))
;                    ) va$
;              ))))))
;              (block
;               (assert
;                ("assertion failure")
;                (req%pervasive.assert. tmp%45@)
;               )
;               (assume
;                (ens%pervasive.assert. tmp%45@)
;              ))
;              (assume
;               (= tmp%46@ (forall ((va$ Poly)) (!
;                  (=>
;                   (has_type va$ NAT)
;                   (=>
;                    (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                      (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                        (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                           (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;                      )))))
;                     ) va$
;                    )
;                    (<= (%I va$) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                          self@
;                        ))
;                       ) (nClip (* (spec.Directory.num_entries.? (Poly%spec.Directory. self@)) (spec.Directory.entry_size.?
;                          (Poly%spec.Directory. self@)
;                  ))))))))
;                  :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                     (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                       (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                          (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;                     )))))
;                    ) va$
;              ))))))
;              (block
;               (assert
;                ("assertion failure")
;                (req%pervasive.assert. tmp%46@)
;               )
;               (assume
;                (ens%pervasive.assert. tmp%46@)
;              ))
;              (assume
;               (= i1_interp@ (%Poly%pervasive.set.Set<nat.>. (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                  (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                    (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                       (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;              )))))))))
;              (assume
;               (= d_interp@ (%Poly%pervasive.set.Set<nat.>. (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                  (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                    (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                       (Poly%spec.Directory. d@) (I 0)
;              )))))))))
;              (switch
;               (block
;                (assume
;                 (and
;                  (pervasive.set.Set.contains.? NAT (Poly%pervasive.set.Set<nat.>. i1_interp@) (I c1@))
;                  (pervasive.set.Set.contains.? NAT (Poly%pervasive.set.Set<nat.>. i1_interp@) (I c2@))
;                ))
;                (assume
;                 (= tmp%47@ (spec.PageTableContents.inv.? (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                     (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;                )))))
;                (block
;                 (assert
;                  ("assertion failure")
;                  (req%pervasive.assert. tmp%47@)
;                 )
;                 (assume
;                  (ens%pervasive.assert. tmp%47@)
;                ))
;                (assume
;                 (= tmp%48@ (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                    (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                      (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                         (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;                    )))))
;                   ) (I c1@)
;                )))
;                (block
;                 (assert
;                  ("assertion failure")
;                  (req%pervasive.assert. tmp%48@)
;                 )
;                 (assume
;                  (ens%pervasive.assert. tmp%48@)
;                ))
;                (assume
;                 (= tmp%49@ (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                    (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                      (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                         (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;                    )))))
;                   ) (I c2@)
;                )))
;                (block
;                 (assert
;                  ("assertion failure")
;                  (req%pervasive.assert. tmp%49@)
;                 )
;                 (assume
;                  (ens%pervasive.assert. tmp%49@)
;                ))
;                (assume
;                 (= tmp%50@ (not (= c1@ c2@)))
;                )
;                (block
;                 (assert
;                  ("assertion failure")
;                  (req%pervasive.assert. tmp%50@)
;                 )
;                 (assume
;                  (ens%pervasive.assert. tmp%50@)
;                ))
;                (assume
;                 (= tmp%51@ (not (spec.overlap.? (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I
;                        c1@
;                       )
;                      ) (%I (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
;                           NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                             (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;                            )
;                           ) (I c1@)
;                     ))))))
;                    ) (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I c2@)) (%I (I (spec.MemRegion./MemRegion/size
;                         (%Poly%spec.MemRegion. (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                            (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                               interp@
;                            )))
;                           ) (I c2@)
;                )))))))))))
;                (block
;                 (assume
;                  (ens%pervasive.assume. tmp%51@)
;               )))
;               (block
;                (assume
;                 (not (and
;                   (pervasive.set.Set.contains.? NAT (Poly%pervasive.set.Set<nat.>. i1_interp@) (I c1@))
;                   (pervasive.set.Set.contains.? NAT (Poly%pervasive.set.Set<nat.>. i1_interp@) (I c2@))
;                )))
;                (switch
;                 (block
;                  (assume
;                   (and
;                    (pervasive.set.Set.contains.? NAT (Poly%pervasive.set.Set<nat.>. d_interp@) (I c1@))
;                    (pervasive.set.Set.contains.? NAT (Poly%pervasive.set.Set<nat.>. d_interp@) (I c2@))
;                  ))
;                  (assume
;                   (= tmp%52@ (not (spec.overlap.? (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I
;                          c1@
;                         )
;                        ) (%I (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
;                             NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                               (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;                              )
;                             ) (I c1@)
;                       ))))))
;                      ) (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I c2@)) (%I (I (spec.MemRegion./MemRegion/size
;                           (%Poly%spec.MemRegion. (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                              (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                                 interp@
;                              )))
;                             ) (I c2@)
;                  )))))))))))
;                  (block
;                   (assert
;                    ("assertion failure")
;                    (req%pervasive.assert. tmp%52@)
;                   )
;                   (assume
;                    (ens%pervasive.assert. tmp%52@)
;                 )))
;                 (block
;                  (assume
;                   (not (and
;                     (pervasive.set.Set.contains.? NAT (Poly%pervasive.set.Set<nat.>. d_interp@) (I c1@))
;                     (pervasive.set.Set.contains.? NAT (Poly%pervasive.set.Set<nat.>. d_interp@) (I c2@))
;                  )))
;                  (switch
;                   (block
;                    (assume
;                     (and
;                      (pervasive.set.Set.contains.? NAT (Poly%pervasive.set.Set<nat.>. i1_interp@) (I c2@))
;                      (pervasive.set.Set.contains.? NAT (Poly%pervasive.set.Set<nat.>. d_interp@) (I c1@))
;                    ))
;                    (assume
;                     (= tmp%53@ (< c1@ c2@))
;                    )
;                    (block
;                     (assert
;                      ("assertion failure")
;                      (req%pervasive.assert. tmp%53@)
;                     )
;                     (assume
;                      (ens%pervasive.assert. tmp%53@)
;                    ))
;                    (assume
;                     (= tmp%54@ (<= c2@ (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;                           (Poly%spec.Directory. self@)
;                          )
;                         ) (nClip (* (spec.Directory.num_entries.? (Poly%spec.Directory. self@)) (spec.Directory.entry_size.?
;                            (Poly%spec.Directory. self@)
;                    ))))))))
;                    (block
;                     (assert
;                      ("assertion failure")
;                      (req%pervasive.assert. tmp%54@)
;                     )
;                     (assume
;                      (ens%pervasive.assert. tmp%54@)
;                    ))
;                    (assume
;                     (= tmp%55@ (<= c2@ c1@))
;                    )
;                    (block
;                     (assume
;                      (ens%pervasive.assume. tmp%55@)
;                    ))
;                    (block
;                     (assert
;                      ("assertion failure")
;                      (req%pervasive.assert. false)
;                     )
;                     (assume
;                      (ens%pervasive.assert. false)
;                   )))
;                   (block
;                    (assume
;                     (not (and
;                       (pervasive.set.Set.contains.? NAT (Poly%pervasive.set.Set<nat.>. i1_interp@) (I c2@))
;                       (pervasive.set.Set.contains.? NAT (Poly%pervasive.set.Set<nat.>. d_interp@) (I c1@))
;                    )))
;                    (block
;                     (assume
;                      (ens%pervasive.assume. false)
;              ))))))))
;              (assert
;               ("assertion failed" "assertion failed")
;               (not (spec.overlap.? (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I c1@)) (%I
;                    (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
;                        NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                          (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;                         )
;                        ) (I c1@)
;                  ))))))
;                 ) (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I c2@)) (%I (I (spec.MemRegion./MemRegion/size
;                      (%Poly%spec.MemRegion. (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                         (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                            interp@
;                         )))
;                        ) (I c2@)
;            ))))))))))))
;            (assume
;             (not (spec.overlap.? (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I c1@)) (%I
;                  (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
;                      NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                        (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;                       )
;                      ) (I c1@)
;                ))))))
;               ) (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I c2@)) (%I (I (spec.MemRegion./MemRegion/size
;                    (%Poly%spec.MemRegion. (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                       (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                          interp@
;                       )))
;                      ) (I c2@)
;           )))))))))))
;           (block
;            (assume
;             (not (is-spec.NodeEntry./Directory tmp%%2@))
;        )))))
;        (assume
;         (= tmp%56@ (not (spec.overlap.? (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I
;                c1@
;               )
;              ) (%I (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
;                   NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                     (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;                    )
;                   ) (I c1@)
;             ))))))
;            ) (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I c2@)) (%I (I (spec.MemRegion./MemRegion/size
;                 (%Poly%spec.MemRegion. (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                    (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                       interp@
;                    )))
;                   ) (I c2@)
;        )))))))))))
;        (block
;         (assert
;          ("assertion failure")
;          (req%pervasive.assert. tmp%56@)
;         )
;         (assume
;          (ens%pervasive.assert. tmp%56@)
;      ))))
;      (assert
;       ("assertion failed" "assertion failed")
;       (not (spec.overlap.? (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I b1@) (%I (I (
;              spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (pervasive.map.Map.index.? NAT
;                TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                  (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;                 )
;                ) b1@
;          ))))))
;         ) (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I b2@) (%I (I (spec.MemRegion./MemRegion/size
;              (%Poly%spec.MemRegion. (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                 (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                    interp@
;                 )))
;                ) b2@
;    ))))))))))))
;    (assume
;     (forall ((b1$ Poly) (b2$ Poly)) (!
;       (=>
;        (and
;         (has_type b1$ NAT)
;         (has_type b2$ NAT)
;        )
;        (=>
;         (and
;          (and
;           (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;             (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;               (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;             ))
;            ) b1$
;           )
;           (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;             (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;               (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;             ))
;            ) b2$
;          ))
;          (not (= b1$ b2$))
;         )
;         (not (spec.overlap.? (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I b1$) (%I (I (
;                spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (pervasive.map.Map.index.? NAT
;                  TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                    (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;                   )
;                  ) b1$
;            ))))))
;           ) (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I b2$) (%I (I (spec.MemRegion./MemRegion/size
;                (%Poly%spec.MemRegion. (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                   (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                      interp@
;                   )))
;                  ) b2$
;       )))))))))))
;       :pattern ((spec.overlap.? (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I b1$) (
;            %I (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
;                NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                  (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;                 )
;                ) b1$
;          ))))))
;         ) (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I b2$) (%I (I (spec.MemRegion./MemRegion/size
;              (%Poly%spec.MemRegion. (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                 (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                    interp@
;                 )))
;                ) b2$
;    ))))))))))))
;    (assume
;     (= tmp%57@ (forall ((va$ Poly)) (!
;        (=>
;         (has_type va$ NAT)
;         (=>
;          (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;            (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;              (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                 (Poly%spec.Directory. self@) (I i@)
;            )))))
;           ) va$
;          )
;          (>= (%I va$) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                self@
;              ))
;             ) (nClip (* i@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;        )))))
;        :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;           (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;             (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                (Poly%spec.Directory. self@) (I i@)
;           )))))
;          ) va$
;    ))))))
;    (block
;     (assume
;      (ens%pervasive.assume. tmp%57@)
;    ))
;    (assume
;     (= tmp%58@ (forall ((va$ Poly)) (!
;        (=>
;         (has_type va$ NAT)
;         (=>
;          (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;            (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;              (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                 (Poly%spec.Directory. self@) (I i@)
;            )))))
;           ) va$
;          )
;          (<= (%I va$) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                self@
;              ))
;             ) (nClip (* (spec.Directory.num_entries.? (Poly%spec.Directory. self@)) (spec.Directory.entry_size.?
;                (Poly%spec.Directory. self@)
;        ))))))))
;        :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;           (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;             (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                (Poly%spec.Directory. self@) (I i@)
;           )))))
;          ) va$
;    ))))))
;    (block
;     (assume
;      (ens%pervasive.assume. tmp%58@)
;    ))
;    (assert
;     ("postcondition not satisfied" "at the end of the function body" "failed this postcondition")
;     (spec.PageTableContents.inv.? (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;        (Poly%spec.Directory. self@) (I i@)
;    ))))
;    (assert
;     ("postcondition not satisfied" "at the end of the function body" "failed this postcondition")
;     (forall ((va$ Poly)) (!
;       (=>
;        (has_type va$ NAT)
;        (=>
;         (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;           (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;             (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                (Poly%spec.Directory. self@) (I i@)
;           )))))
;          ) va$
;         )
;         (>= (%I va$) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;               self@
;             ))
;            ) (nClip (* i@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;       )))))
;       :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;          (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;            (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;               (Poly%spec.Directory. self@) (I i@)
;          )))))
;         ) va$
;    )))))
;    (assert
;     ("postcondition not satisfied" "at the end of the function body" "failed this postcondition")
;     (forall ((va$ Poly)) (!
;       (=>
;        (has_type va$ NAT)
;        (=>
;         (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;           (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;             (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                (Poly%spec.Directory. self@) (I i@)
;           )))))
;          ) va$
;         )
;         (<= (%I va$) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;               self@
;             ))
;            ) (nClip (* (spec.Directory.num_entries.? (Poly%spec.Directory. self@)) (spec.Directory.entry_size.?
;               (Poly%spec.Directory. self@)
;       ))))))))
;       :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;          (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;            (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;               (Poly%spec.Directory. self@) (I i@)
;          )))))
;         ) va$
;  )))))))
; 
;  ;; Function-Check-Recommends crate::spec::Directory::inv_implies_interp_aux_inv
;  (check-valid
;   (declare-const self@ spec.Directory.)
;   (declare-const i@ Int)
;   (declare-const va@ Poly)
;   (declare-const tmp%1@ Int)
;   (declare-const tmp%2@ Bool)
;   (declare-const va$1@ Poly)
;   (declare-const tmp%3@ Int)
;   (declare-const tmp%4@ Int)
;   (declare-const tmp%5@ Bool)
;   (declare-const tmp%6@ Bool)
;   (declare-const i$1@ Poly)
;   (declare-const tmp%7@ Poly)
;   (declare-const tmp%8@ Poly)
;   (declare-const tmp%9@ Bool)
;   (declare-const tmp%10@ Poly)
;   (declare-const tmp%11@ Poly)
;   (declare-const tmp%12@ spec.Directory.)
;   (declare-const tmp%13@ Poly)
;   (declare-const tmp%14@ Poly)
;   (declare-const tmp%15@ Bool)
;   (declare-const tmp%16@ Poly)
;   (declare-const tmp%17@ Poly)
;   (declare-const tmp%18@ Bool)
;   (declare-const tmp%19@ Int)
;   (declare-const tmp%20@ Poly)
;   (declare-const tmp%21@ Poly)
;   (declare-const tmp%22@ Int)
;   (declare-const tmp%23@ Poly)
;   (declare-const tmp%24@ Poly)
;   (declare-const tmp%25@ Bool)
;   (declare-const tmp%26@ Int)
;   (declare-const tmp%27@ Bool)
;   (declare-const rem@ pervasive.map.Map<nat./spec.MemRegion.>.)
;   (declare-const va$2@ Poly)
;   (declare-const va$3@ Poly)
;   (declare-const tmp%28@ Int)
;   (declare-const tmp%29@ Bool)
;   (declare-const tmp%30@ Bool)
;   (declare-const va$4@ Poly)
;   (declare-const tmp%31@ Int)
;   (declare-const tmp%32@ Bool)
;   (declare-const tmp%33@ Bool)
;   (declare-const tmp%34@ Poly)
;   (declare-const tmp%35@ Poly)
;   (declare-const tmp%36@ Int)
;   (declare-const tmp%37@ Bool)
;   (declare-const tmp%38@ Int)
;   (declare-const tmp%39@ Int)
;   (declare-const tmp%40@ Bool)
;   (declare-const tmp%41@ Bool)
;   (declare-const tmp%42@ Int)
;   (declare-const tmp%43@ Int)
;   (declare-const tmp%44@ Int)
;   (declare-const tmp%45@ Bool)
;   (declare-const tmp%46@ Int)
;   (declare-const tmp%47@ Int)
;   (declare-const tmp%48@ Bool)
;   (declare-const es@ Int)
;   (declare-const tmp%49@ Int)
;   (declare-const tmp%50@ Poly)
;   (declare-const tmp%51@ Poly)
;   (declare-const tmp%52@ Int)
;   (declare-const tmp%53@ Bool)
;   (declare-const tmp%54@ Bool)
;   (declare-const tmp%55@ Int)
;   (declare-const tmp%56@ Int)
;   (declare-const tmp%57@ Bool)
;   (declare-const tmp%58@ Int)
;   (declare-const tmp%59@ Bool)
;   (declare-const tmp%60@ Int)
;   (declare-const tmp%61@ Int)
;   (declare-const tmp%62@ Bool)
;   (declare-const tmp%63@ Int)
;   (declare-const tmp%64@ Int)
;   (declare-const tmp%65@ Bool)
;   (declare-const tmp%66@ Int)
;   (declare-const tmp%67@ Int)
;   (declare-const tmp%68@ Bool)
;   (declare-const tmp%69@ Poly)
;   (declare-const tmp%70@ Poly)
;   (declare-const tmp%71@ Bool)
;   (declare-const tmp%72@ Poly)
;   (declare-const tmp%73@ Poly)
;   (declare-const tmp%74@ Bool)
;   (declare-const tmp%75@ Poly)
;   (declare-const tmp%76@ Poly)
;   (declare-const tmp%77@ Poly)
;   (declare-const tmp%78@ Poly)
;   (declare-const tmp%79@ Bool)
;   (declare-const j@ Int)
;   (declare-const tmp%80@ Poly)
;   (declare-const tmp%81@ Poly)
;   (declare-const tmp%82@ Bool)
;   (declare-const tmp%83@ Poly)
;   (declare-const tmp%84@ Poly)
;   (declare-const tmp%85@ Poly)
;   (declare-const tmp%86@ Poly)
;   (declare-const tmp%87@ Bool)
;   (declare-const b1@ Poly)
;   (declare-const b2@ Poly)
;   (declare-const tmp%88@ Int)
;   (declare-const va$5@ Poly)
;   (declare-const tmp%89@ Int)
;   (declare-const tmp%90@ Bool)
;   (declare-const tmp%91@ Bool)
;   (declare-const va$6@ Poly)
;   (declare-const tmp%92@ Int)
;   (declare-const tmp%93@ Int)
;   (declare-const tmp%94@ Bool)
;   (declare-const tmp%95@ Bool)
;   (declare-const tmp%96@ Bool)
;   (declare-const tmp%97@ Poly)
;   (declare-const tmp%98@ Poly)
;   (declare-const tmp%99@ Int)
;   (declare-const tmp%100@ Poly)
;   (declare-const tmp%101@ Poly)
;   (declare-const tmp%102@ Poly)
;   (declare-const tmp%103@ Poly)
;   (declare-const tmp%104@ Bool)
;   (declare-const tmp%105@ Bool)
;   (declare-const tmp%106@ Bool)
;   (declare-const tmp%107@ Int)
;   (declare-const tmp%108@ Bool)
;   (declare-const tmp%109@ Int)
;   (declare-const tmp%110@ Int)
;   (declare-const tmp%111@ Int)
;   (declare-const tmp%112@ Int)
;   (declare-const tmp%113@ Bool)
;   (declare-const tmp%114@ Int)
;   (declare-const tmp%115@ Int)
;   (declare-const tmp%116@ Int)
;   (declare-const tmp%117@ Bool)
;   (declare-const tmp%118@ Int)
;   (declare-const tmp%119@ Int)
;   (declare-const tmp%120@ Bool)
;   (declare-const tmp%121@ Poly)
;   (declare-const tmp%122@ Poly)
;   (declare-const tmp%123@ Poly)
;   (declare-const tmp%124@ Poly)
;   (declare-const tmp%125@ Bool)
;   (declare-const tmp%126@ Bool)
;   (declare-const tmp%127@ Bool)
;   (declare-const tmp%128@ Int)
;   (declare-const tmp%129@ Bool)
;   (declare-const tmp%130@ Int)
;   (declare-const tmp%131@ Bool)
;   (declare-const tmp%132@ Bool)
;   (declare-const tmp%133@ Poly)
;   (declare-const tmp%134@ Poly)
;   (declare-const tmp%135@ Poly)
;   (declare-const tmp%136@ Poly)
;   (declare-const new_va@ Int)
;   (declare-const p@ spec.MemRegion.)
;   (declare-const va$7@ Poly)
;   (declare-const tmp%137@ Int)
;   (declare-const tmp%138@ Int)
;   (declare-const tmp%139@ Bool)
;   (declare-const tmp%140@ Bool)
;   (declare-const va$8@ Poly)
;   (declare-const tmp%141@ Bool)
;   (declare-const va$9@ Poly)
;   (declare-const tmp%142@ Int)
;   (declare-const tmp%143@ Bool)
;   (declare-const tmp%144@ Bool)
;   (declare-const va$10@ Poly)
;   (declare-const tmp%145@ Int)
;   (declare-const tmp%146@ Int)
;   (declare-const tmp%147@ Bool)
;   (declare-const tmp%148@ Bool)
;   (declare-const tmp%149@ Bool)
;   (declare-const tmp%150@ Bool)
;   (declare-const tmp%151@ Bool)
;   (declare-const tmp%152@ Bool)
;   (declare-const tmp%153@ Poly)
;   (declare-const tmp%154@ Poly)
;   (declare-const tmp%155@ Poly)
;   (declare-const tmp%156@ Poly)
;   (declare-const tmp%157@ Bool)
;   (declare-const tmp%158@ Poly)
;   (declare-const tmp%159@ Poly)
;   (declare-const tmp%160@ Poly)
;   (declare-const tmp%161@ Poly)
;   (declare-const tmp%162@ Bool)
;   (declare-const tmp%163@ Bool)
;   (declare-const tmp%164@ Int)
;   (declare-const tmp%165@ Int)
;   (declare-const tmp%166@ Bool)
;   (declare-const tmp%167@ Bool)
;   (declare-const i1_interp@ pervasive.set.Set<nat.>.)
;   (declare-const d_interp@ pervasive.set.Set<nat.>.)
;   (declare-const tmp%168@ Poly)
;   (declare-const tmp%169@ Poly)
;   (declare-const tmp%170@ Poly)
;   (declare-const tmp%171@ Poly)
;   (declare-const d@ spec.Directory.)
;   (declare-const tmp%%2@ spec.NodeEntry.)
;   (declare-const tmp%172@ Poly)
;   (declare-const tmp%173@ Poly)
;   (declare-const tmp%174@ Poly)
;   (declare-const tmp%175@ Poly)
;   (declare-const tmp%176@ Bool)
;   (declare-const tmp%%1@ tuple%2.)
;   (declare-const c1@ Int)
;   (declare-const c2@ Int)
;   (declare-const tmp%177@ Poly)
;   (declare-const tmp%178@ Poly)
;   (declare-const tmp%179@ Poly)
;   (declare-const tmp%180@ Poly)
;   (declare-const va$11@ Poly)
;   (declare-const tmp%181@ Int)
;   (declare-const tmp%182@ Bool)
;   (declare-const tmp%183@ Bool)
;   (declare-const va$12@ Poly)
;   (declare-const tmp%184@ Int)
;   (declare-const tmp%185@ Int)
;   (declare-const tmp%186@ Bool)
;   (declare-const tmp%187@ Bool)
;   (declare-const interp@ spec.PageTableContents.)
;   (axiom fuel_defaults)
;   (axiom (has_type (Poly%spec.Directory. self@) TYPE%spec.Directory.))
;   (axiom (<= 0 i@))
;   (block
;    (assume
;     (spec.Directory.inv.? (Poly%spec.Directory. self@))
;    )
;    (assume
;     (= interp@ (spec.Directory.interp_aux.? (Poly%spec.Directory. self@) (I i@)))
;    )
;    (block
;     (assert
;      ("recommendation not met")
;      (req%spec.Directory.directories_obey_invariant. (Poly%spec.Directory. self@))
;    ))
;    (assume
;     (= tmp%6@ (spec.Directory.directories_obey_invariant.? (Poly%spec.Directory. self@)))
;    )
;    (block
;     (assume
;      (ens%pervasive.assert. tmp%6@)
;    ))
;    (deadend (block
;      (assume
;       (has_type i$1@ NAT)
;      )
;      (switch
;       (block
;        (assume
;         (< (%I i$1@) (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;            (spec.Directory./Directory/entries (%Poly%spec.Directory. (Poly%spec.Directory. self@)))
;        ))))
;        (assume
;         (= tmp%14@ (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries
;            (%Poly%spec.Directory. (Poly%spec.Directory. self@))
;        ))))
;        (block
;         (assert
;          ("recommendation not met")
;          (req%pervasive.seq.Seq.index. TYPE%spec.NodeEntry. tmp%14@ i$1@)
;        ))
;        (assume
;         (= tmp%13@ (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;            (spec.Directory./Directory/entries (%Poly%spec.Directory. (Poly%spec.Directory. self@)))
;           ) i$1@
;        )))
;        (assume
;         (= tmp%15@ (is-spec.NodeEntry./Directory (%Poly%spec.NodeEntry. tmp%13@)))
;       ))
;       (block
;        (assume
;         (not (< (%I i$1@) (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;             (spec.Directory./Directory/entries (%Poly%spec.Directory. (Poly%spec.Directory. self@)))
;        )))))
;        (assume
;         (= tmp%15@ false)
;      )))
;      (assume
;       (and
;        (< (%I i$1@) (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;           (spec.Directory./Directory/entries (%Poly%spec.Directory. (Poly%spec.Directory. self@)))
;        )))
;        (is-spec.NodeEntry./Directory (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry.
;           (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries (%Poly%spec.Directory.
;              (Poly%spec.Directory. self@)
;            ))
;           ) i$1@
;      )))))
;      (assume
;       (= tmp%8@ (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries
;          (%Poly%spec.Directory. (Poly%spec.Directory. self@))
;      ))))
;      (block
;       (assert
;        ("recommendation not met")
;        (req%pervasive.seq.Seq.index. TYPE%spec.NodeEntry. tmp%8@ i$1@)
;      ))
;      (assume
;       (= tmp%7@ (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;          (spec.Directory./Directory/entries (%Poly%spec.Directory. (Poly%spec.Directory. self@)))
;         ) i$1@
;      )))
;      (assume
;       (= tmp%9@ (spec.Directory.inv.? (Poly%spec.Directory. (spec.NodeEntry./Directory/_0 (
;            %Poly%spec.NodeEntry. tmp%7@
;      ))))))
;      (block
;       (assume
;        (ens%pervasive.assert. tmp%9@)
;      ))
;      (assume
;       (= tmp%11@ (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries
;          (%Poly%spec.Directory. (Poly%spec.Directory. self@))
;      ))))
;      (block
;       (assert
;        ("recommendation not met")
;        (req%pervasive.seq.Seq.index. TYPE%spec.NodeEntry. tmp%11@ i$1@)
;      ))
;      (assume
;       (= tmp%10@ (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;          (spec.Directory./Directory/entries (%Poly%spec.Directory. (Poly%spec.Directory. self@)))
;         ) i$1@
;      )))
;      (assume
;       (= tmp%12@ (spec.NodeEntry./Directory/_0 (%Poly%spec.NodeEntry. tmp%10@)))
;      )
;      (block
;       (assume
;        (ens%spec.Directory.inv_implies_interp_aux_inv. tmp%12@ 0)
;      ))
;      (assume
;       (= tmp%17@ (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries
;          (%Poly%spec.Directory. (Poly%spec.Directory. self@))
;      ))))
;      (block
;       (assert
;        ("recommendation not met")
;        (req%pervasive.seq.Seq.index. TYPE%spec.NodeEntry. tmp%17@ i$1@)
;      ))
;      (assume
;       (= tmp%16@ (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;          (spec.Directory./Directory/entries (%Poly%spec.Directory. (Poly%spec.Directory. self@)))
;         ) i$1@
;    )))))
;    (assume
;     (forall ((i$ Poly)) (!
;       (=>
;        (has_type i$ NAT)
;        (=>
;         (and
;          (< (%I i$) (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;             (spec.Directory./Directory/entries (%Poly%spec.Directory. (Poly%spec.Directory. self@)))
;          )))
;          (is-spec.NodeEntry./Directory (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry.
;             (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries (%Poly%spec.Directory.
;                (Poly%spec.Directory. self@)
;              ))
;             ) i$
;         ))))
;         (spec.PageTableContents.inv.? (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;            (Poly%spec.Directory. (spec.NodeEntry./Directory/_0 (%Poly%spec.NodeEntry. (pervasive.seq.Seq.index.?
;                TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries
;                  (%Poly%spec.Directory. (Poly%spec.Directory. self@))
;                 )
;                ) i$
;             )))
;            ) (I 0)
;       )))))
;       :pattern ((pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;          (spec.Directory./Directory/entries (%Poly%spec.Directory. (Poly%spec.Directory. self@)))
;         ) i$
;    )))))
;    (assume
;     (= tmp%18@ (spec.Arch.inv.? (Poly%spec.Arch. (spec.PageTableContents./PageTableContents/arch
;         (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;    )))))
;    (block
;     (assume
;      (ens%pervasive.assert. tmp%18@)
;    ))
;    (switch
;     (block
;      (assume
;       (>= i@ (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;          (spec.Directory./Directory/entries (%Poly%spec.Directory. (Poly%spec.Directory. self@)))
;     )))))
;     (block
;      (assume
;       (not (>= i@ (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;           (spec.Directory./Directory/entries (%Poly%spec.Directory. (Poly%spec.Directory. self@)))
;      )))))
;      (assume
;       (= tmp%19@ (nClip (+ i@ 1)))
;      )
;      (block
;       (assume
;        (ens%spec.Directory.inv_implies_interp_aux_inv. self@ tmp%19@)
;      ))
;      (assume
;       (= tmp%21@ (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries
;          (%Poly%spec.Directory. (Poly%spec.Directory. self@))
;      ))))
;      (block
;       (assert
;        ("recommendation not met")
;        (req%pervasive.seq.Seq.index. TYPE%spec.NodeEntry. tmp%21@ (I i@))
;      ))
;      (assume
;       (= tmp%20@ (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;          (spec.Directory./Directory/entries (%Poly%spec.Directory. (Poly%spec.Directory. self@)))
;         ) (I i@)
;      )))
;      (switch
;       (block
;        (assume
;         (is-spec.NodeEntry./Page (%Poly%spec.NodeEntry. tmp%20@))
;        )
;        (assume
;         (= rem@ (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents.
;            (Poly%spec.PageTableContents. (spec.Directory.interp_aux.? (Poly%spec.Directory. self@)
;              (I (nClip (+ i@ 1)))
;        ))))))
;        (block
;         (assert
;          ("recommendation not met")
;          (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;        ))
;        (assume
;         (= tmp%22@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;        )
;        (assume
;         (= tmp%24@ (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries
;            (%Poly%spec.Directory. (Poly%spec.Directory. self@))
;        ))))
;        (block
;         (assert
;          ("recommendation not met")
;          (req%pervasive.seq.Seq.index. TYPE%spec.NodeEntry. tmp%24@ (I i@))
;        ))
;        (assume
;         (= tmp%23@ (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;            (spec.Directory./Directory/entries (%Poly%spec.Directory. (Poly%spec.Directory. self@)))
;           ) (I i@)
;        )))
;        (assume
;         (= tmp%25@ (= (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents.
;             (Poly%spec.PageTableContents. (spec.Directory.interp_aux.? (Poly%spec.Directory. self@)
;               (I i@)
;            )))
;           ) (%Poly%pervasive.map.Map<nat./spec.MemRegion.>. (pervasive.map.Map.insert.? NAT TYPE%spec.MemRegion.
;             (Poly%pervasive.map.Map<nat./spec.MemRegion.>. rem@) (I (nClip (+ (spec.Directory./Directory/base_vaddr
;                 (%Poly%spec.Directory. (Poly%spec.Directory. self@))
;                ) (nClip (* i@ tmp%22@))
;              ))
;             ) (Poly%spec.MemRegion. (spec.NodeEntry./Page/_0 (%Poly%spec.NodeEntry. tmp%23@)))
;        )))))
;        (block
;         (assume
;          (ens%pervasive.assume. tmp%25@)
;        ))
;        (block
;         (assert
;          ("recommendation not met")
;          (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;        ))
;        (assume
;         (= tmp%26@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;        )
;        (assume
;         (= tmp%27@ (= (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;             (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                (spec.Directory.interp_aux.? (Poly%spec.Directory. self@) (I i@))
;            ))))
;           ) (pervasive.set.Set.insert.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;             (Poly%pervasive.map.Map<nat./spec.MemRegion.>. rem@)
;            ) (I (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                  self@
;                ))
;               ) (nClip (* i@ tmp%26@))
;        )))))))
;        (block
;         (assume
;          (ens%pervasive.assert. tmp%27@)
;       )))
;       (block
;        (assume
;         (not (is-spec.NodeEntry./Page (%Poly%spec.NodeEntry. tmp%20@)))
;    )))))
;    (deadend (block
;      (assume
;       (has_type va$2@ NAT)
;      )
;      (assume
;       (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;         (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;           (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;         ))
;        ) va$2@
;      ))
;      (switch
;       (block
;        (assume
;         (>= i@ (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;            (spec.Directory./Directory/entries (%Poly%spec.Directory. (Poly%spec.Directory. self@)))
;       )))))
;       (block
;        (assume
;         (not (>= i@ (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;             (spec.Directory./Directory/entries (%Poly%spec.Directory. (Poly%spec.Directory. self@)))
;        )))))
;        (assume
;         (= j@ (nClip (+ i@ 1)))
;        )
;        (block
;         (assume
;          (ens%spec.Directory.inv_implies_interp_aux_inv. self@ j@)
;        ))
;        (assume
;         (has_type va$3@ NAT)
;        )
;        (switch
;         (block
;          (assume
;           (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;             (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;               (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                  (Poly%spec.Directory. self@) (I j@)
;             )))))
;            ) va$3@
;          ))
;          (block
;           (assert
;            ("recommendation not met")
;            (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;          ))
;          (assume
;           (= tmp%28@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;          )
;          (assume
;           (= tmp%29@ (>= (%I va$3@) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;                 (Poly%spec.Directory. self@)
;                )
;               ) (nClip (* j@ tmp%28@))
;         ))))))
;         (block
;          (assume
;           (not (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;              (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                   (Poly%spec.Directory. self@) (I j@)
;              )))))
;             ) va$3@
;          )))
;          (assume
;           (= tmp%29@ true)
;        )))
;        (assume
;         (= tmp%30@ (forall ((va$ Poly)) (!
;            (=>
;             (has_type va$ NAT)
;             (=>
;              (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                  (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                     (Poly%spec.Directory. self@) (I j@)
;                )))))
;               ) va$
;              )
;              (>= (%I va$) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                    self@
;                  ))
;                 ) (nClip (* j@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;            )))))
;            :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;               (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                 (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                    (Poly%spec.Directory. self@) (I j@)
;               )))))
;              ) va$
;        ))))))
;        (block
;         (assume
;          (ens%pervasive.assert. tmp%30@)
;        ))
;        (assume
;         (has_type va$4@ NAT)
;        )
;        (switch
;         (block
;          (assume
;           (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;             (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;               (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                  (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;             )))))
;            ) va$4@
;          ))
;          (block
;           (assert
;            ("recommendation not met")
;            (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;          ))
;          (assume
;           (= tmp%31@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;          )
;          (assume
;           (= tmp%32@ (>= (%I va$4@) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;                 (Poly%spec.Directory. self@)
;                )
;               ) (nClip (* (nClip (+ i@ 1)) tmp%31@))
;         ))))))
;         (block
;          (assume
;           (not (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;              (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                   (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;              )))))
;             ) va$4@
;          )))
;          (assume
;           (= tmp%32@ true)
;        )))
;        (assume
;         (= tmp%33@ (forall ((va$ Poly)) (!
;            (=>
;             (has_type va$ NAT)
;             (=>
;              (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                  (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                     (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;                )))))
;               ) va$
;              )
;              (>= (%I va$) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                    self@
;                  ))
;                 ) (nClip (* (nClip (+ i@ 1)) (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;            )))))
;            :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;               (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                 (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                    (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;               )))))
;              ) va$
;        ))))))
;        (block
;         (assume
;          (ens%pervasive.assume. tmp%33@)
;        ))
;        (assume
;         (= tmp%35@ (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries
;            (%Poly%spec.Directory. (Poly%spec.Directory. self@))
;        ))))
;        (block
;         (assert
;          ("recommendation not met")
;          (req%pervasive.seq.Seq.index. TYPE%spec.NodeEntry. tmp%35@ (I i@))
;        ))
;        (assume
;         (= tmp%34@ (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;            (spec.Directory./Directory/entries (%Poly%spec.Directory. (Poly%spec.Directory. self@)))
;           ) (I i@)
;        )))
;        (switch
;         (block
;          (assume
;           (is-spec.NodeEntry./Page (%Poly%spec.NodeEntry. tmp%34@))
;          )
;          (block
;           (assert
;            ("recommendation not met")
;            (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;          ))
;          (assume
;           (= tmp%36@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;          )
;          (assume
;           (= tmp%37@ (= (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;               (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                  (spec.Directory.interp_aux.? (Poly%spec.Directory. self@) (I i@))
;              ))))
;             ) (pervasive.set.Set.insert.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;               (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                 (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                    (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;               )))))
;              ) (I (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                    self@
;                  ))
;                 ) (nClip (* i@ tmp%36@))
;          )))))))
;          (block
;           (assume
;            (ens%pervasive.assert. tmp%37@)
;          ))
;          (block
;           (assert
;            ("recommendation not met")
;            (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;          ))
;          (assume
;           (= tmp%38@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;          )
;          (switch
;           (block
;            (assume
;             (< (%I va$2@) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (
;                   Poly%spec.Directory. self@
;                 ))
;                ) (nClip (* i@ tmp%38@))
;            ))))
;            (block
;             (assert
;              ("recommendation not met")
;              (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;            ))
;            (assume
;             (= tmp%39@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;            )
;            (assume
;             (= tmp%40@ (>= (%I va$2@) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;                   (Poly%spec.Directory. self@)
;                  )
;                 ) (nClip (* (nClip (+ i@ 1)) tmp%39@))
;            )))))
;            (block
;             (assume
;              (ens%pervasive.assert. tmp%40@)
;            ))
;            (block
;             (assert
;              ("recommendation not met")
;              (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;            ))
;            (block
;             (assume
;              (ens%lib.mul_distributive. i@ es@)
;            ))
;            (assume
;             (= tmp%41@ (= (nClip (* (nClip (+ i@ 1)) es@)) (nClip (+ (nClip (* i@ es@)) es@))))
;            )
;            (block
;             (assume
;              (ens%pervasive.assume. tmp%41@)
;            ))
;            (block
;             (assert
;              ("recommendation not met")
;              (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;            ))
;            (assume
;             (= tmp%42@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;            )
;            (block
;             (assert
;              ("recommendation not met")
;              (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;            ))
;            (assume
;             (= tmp%43@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;            )
;            (block
;             (assert
;              ("recommendation not met")
;              (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;            ))
;            (assume
;             (= tmp%44@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;            )
;            (assume
;             (= tmp%45@ (= (nClip (* (nClip (+ i@ 1)) tmp%42@)) (nClip (+ (nClip (* i@ tmp%43@)) tmp%44@))))
;            )
;            (block
;             (assume
;              (ens%pervasive.assume. tmp%45@)
;            ))
;            (block
;             (assert
;              ("recommendation not met")
;              (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;            ))
;            (assume
;             (= tmp%46@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;            )
;            (block
;             (assert
;              ("recommendation not met")
;              (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;            ))
;            (assume
;             (= tmp%47@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;            )
;            (assume
;             (= tmp%48@ (>= (%I va$2@) (nClip (+ (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;                     (Poly%spec.Directory. self@)
;                    )
;                   ) (nClip (* i@ tmp%46@))
;                  )
;                 ) tmp%47@
;            )))))
;            (block
;             (assume
;              (ens%pervasive.assert. tmp%48@)
;            ))
;            (block
;             (assume
;              (ens%pervasive.assert. false)
;           )))
;           (block
;            (assume
;             (not (< (%I va$2@) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;                   (Poly%spec.Directory. self@)
;                  )
;                 ) (nClip (* i@ tmp%38@))
;            )))))
;            (block
;             (assert
;              ("recommendation not met")
;              (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;            ))
;            (assume
;             (= tmp%49@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;            )
;            (switch
;             (block
;              (assume
;               (= (%I va$2@) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (
;                     Poly%spec.Directory. self@
;                   ))
;                  ) (nClip (* i@ tmp%49@))
;              ))))
;              (assume
;               (= tmp%51@ (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                  (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;              ))))
;              (block
;               (assert
;                ("recommendation not met")
;                (req%pervasive.map.Map.index. NAT TYPE%spec.MemRegion. tmp%51@ va$2@)
;              ))
;              (assume
;               (= tmp%50@ (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                  (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                     interp@
;                  )))
;                 ) va$2@
;              )))
;              (block
;               (assert
;                ("recommendation not met")
;                (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;              ))
;              (assume
;               (= tmp%52@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;              )
;              (assume
;               (= tmp%53@ (= (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. tmp%50@)) tmp%52@))
;              )
;              (block
;               (assume
;                (ens%pervasive.assert. tmp%53@)
;              ))
;              (assume
;               (= tmp%54@ (spec.Directory.well_formed.? (Poly%spec.Directory. self@)))
;              )
;              (block
;               (assume
;                (ens%pervasive.assert. tmp%54@)
;              ))
;              (block
;               (assert
;                ("recommendation not met")
;                (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;              ))
;              (assume
;               (= tmp%55@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;              )
;              (block
;               (assert
;                ("recommendation not met")
;                (req%spec.Directory.num_entries. (Poly%spec.Directory. self@))
;              ))
;              (assume
;               (= tmp%56@ (spec.Directory.num_entries.? (Poly%spec.Directory. self@)))
;              )
;              (assume
;               (= tmp%57@ (spec.aligned.? (I (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;                    (Poly%spec.Directory. self@)
;                  ))
;                 ) (I (nClip (* tmp%55@ tmp%56@)))
;              )))
;              (block
;               (assume
;                (ens%pervasive.assume. tmp%57@)
;              ))
;              (block
;               (assert
;                ("recommendation not met")
;                (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;              ))
;              (assume
;               (= tmp%58@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;              )
;              (assume
;               (= tmp%59@ (spec.aligned.? (I (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;                    (Poly%spec.Directory. self@)
;                  ))
;                 ) (I tmp%58@)
;              )))
;              (block
;               (assume
;                (ens%pervasive.assume. tmp%59@)
;              ))
;              (block
;               (assert
;                ("recommendation not met")
;                (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;              ))
;              (assume
;               (= tmp%60@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;              )
;              (block
;               (assert
;                ("recommendation not met")
;                (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;              ))
;              (assume
;               (= tmp%61@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;              )
;              (assume
;               (= tmp%62@ (= (mod (nClip (* i@ tmp%60@)) tmp%61@) 0))
;              )
;              (block
;               (assume
;                (ens%pervasive.assume. tmp%62@)
;              ))
;              (block
;               (assert
;                ("recommendation not met")
;                (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;              ))
;              (assume
;               (= tmp%63@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;              )
;              (block
;               (assert
;                ("recommendation not met")
;                (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;              ))
;              (assume
;               (= tmp%64@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;              )
;              (assume
;               (= tmp%65@ (spec.aligned.? (I (nClip (* i@ tmp%63@))) (I tmp%64@)))
;              )
;              (block
;               (assume
;                (ens%pervasive.assert. tmp%65@)
;              ))
;              (block
;               (assert
;                ("recommendation not met")
;                (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;              ))
;              (assume
;               (= tmp%66@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;              )
;              (block
;               (assert
;                ("recommendation not met")
;                (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;              ))
;              (assume
;               (= tmp%67@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;              )
;              (assume
;               (= tmp%68@ (spec.aligned.? (I (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;                      (Poly%spec.Directory. self@)
;                     )
;                    ) (nClip (* i@ tmp%66@))
;                  ))
;                 ) (I tmp%67@)
;              )))
;              (block
;               (assume
;                (ens%pervasive.assume. tmp%68@)
;              ))
;              (assume
;               (= tmp%70@ (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                  (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;              ))))
;              (block
;               (assert
;                ("recommendation not met")
;                (req%pervasive.map.Map.index. NAT TYPE%spec.MemRegion. tmp%70@ va$2@)
;              ))
;              (assume
;               (= tmp%69@ (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                  (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                     interp@
;                  )))
;                 ) va$2@
;              )))
;              (assume
;               (= tmp%71@ (spec.aligned.? va$2@ (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion.
;                    tmp%69@
;              ))))))
;              (block
;               (assume
;                (ens%pervasive.assert. tmp%71@)
;             )))
;             (block
;              (assume
;               (not (= (%I va$2@) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;                     (Poly%spec.Directory. self@)
;                    )
;                   ) (nClip (* i@ tmp%49@))
;              )))))
;              (assume
;               (= tmp%73@ (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                  (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;              ))))
;              (block
;               (assert
;                ("recommendation not met")
;                (req%pervasive.map.Map.index. NAT TYPE%spec.MemRegion. tmp%73@ va$2@)
;              ))
;              (assume
;               (= tmp%72@ (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                  (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                     interp@
;                  )))
;                 ) va$2@
;              )))
;              (assume
;               (= tmp%74@ (spec.aligned.? va$2@ (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion.
;                    tmp%72@
;              ))))))
;              (block
;               (assume
;                (ens%pervasive.assert. tmp%74@)
;          ))))))
;          (assume
;           (= tmp%76@ (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;              (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;          ))))
;          (block
;           (assert
;            ("recommendation not met")
;            (req%pervasive.map.Map.index. NAT TYPE%spec.MemRegion. tmp%76@ va$2@)
;          ))
;          (assume
;           (= tmp%75@ (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;              (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                 interp@
;              )))
;             ) va$2@
;          )))
;          (assume
;           (= tmp%78@ (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;              (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;          ))))
;          (block
;           (assert
;            ("recommendation not met")
;            (req%pervasive.map.Map.index. NAT TYPE%spec.MemRegion. tmp%78@ va$2@)
;          ))
;          (assume
;           (= tmp%77@ (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;              (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                 interp@
;              )))
;             ) va$2@
;          )))
;          (assume
;           (= tmp%79@ (spec.aligned.? (I (spec.MemRegion./MemRegion/base (%Poly%spec.MemRegion. tmp%75@)))
;             (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. tmp%77@)))
;          )))
;          (block
;           (assume
;            (ens%pervasive.assert. tmp%79@)
;         )))
;         (block
;          (assume
;           (not (is-spec.NodeEntry./Page (%Poly%spec.NodeEntry. tmp%34@)))
;      )))))
;      (switch
;       (block
;        (assume
;         true
;        )
;        (assume
;         (= tmp%81@ (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;            (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;        ))))
;        (block
;         (assert
;          ("recommendation not met")
;          (req%pervasive.map.Map.index. NAT TYPE%spec.MemRegion. tmp%81@ va$2@)
;        ))
;        (assume
;         (= tmp%80@ (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;            (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;               interp@
;            )))
;           ) va$2@
;        )))
;        (assume
;         (= tmp%82@ (spec.aligned.? va$2@ (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion.
;              tmp%80@
;       )))))))
;       (block
;        (assume
;         (not true)
;        )
;        (assume
;         (= tmp%82@ false)
;      )))
;      (switch
;       (block
;        (assume
;         tmp%82@
;        )
;        (assume
;         (= tmp%84@ (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;            (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;        ))))
;        (block
;         (assert
;          ("recommendation not met")
;          (req%pervasive.map.Map.index. NAT TYPE%spec.MemRegion. tmp%84@ va$2@)
;        ))
;        (assume
;         (= tmp%83@ (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;            (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;               interp@
;            )))
;           ) va$2@
;        )))
;        (assume
;         (= tmp%86@ (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;            (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;        ))))
;        (block
;         (assert
;          ("recommendation not met")
;          (req%pervasive.map.Map.index. NAT TYPE%spec.MemRegion. tmp%86@ va$2@)
;        ))
;        (assume
;         (= tmp%85@ (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;            (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;               interp@
;            )))
;           ) va$2@
;        )))
;        (assume
;         (= tmp%87@ (spec.aligned.? (I (spec.MemRegion./MemRegion/base (%Poly%spec.MemRegion. tmp%83@)))
;           (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. tmp%85@)))
;       ))))
;       (block
;        (assume
;         (not tmp%82@)
;        )
;        (assume
;         (= tmp%87@ false)
;    )))))
;    (assume
;     (forall ((va$ Poly)) (!
;       (=>
;        (has_type va$ NAT)
;        (=>
;         (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;           (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;             (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;           ))
;          ) va$
;         )
;         (and
;          (spec.aligned.? va$ (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
;               NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                 (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;                )
;               ) va$
;          )))))
;          (spec.aligned.? (I (spec.MemRegion./MemRegion/base (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
;               NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                 (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;                )
;               ) va$
;            )))
;           ) (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
;               NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                 (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;                )
;               ) va$
;       ))))))))
;       :pattern ((pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;          (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;             interp@
;          )))
;         ) va$
;    )))))
;    (deadend (block
;      (assume
;       (has_type b1@ NAT)
;      )
;      (assume
;       (has_type b2@ NAT)
;      )
;      (assume
;       (and
;        (and
;         (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;           (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;             (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;           ))
;          ) b1@
;         )
;         (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;           (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;             (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;           ))
;          ) b2@
;        ))
;        (not (= b1@ b2@))
;      ))
;      (switch
;       (block
;        (assume
;         (>= i@ (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;            (spec.Directory./Directory/entries (%Poly%spec.Directory. (Poly%spec.Directory. self@)))
;       )))))
;       (block
;        (assume
;         (not (>= i@ (pervasive.seq.Seq.len.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;             (spec.Directory./Directory/entries (%Poly%spec.Directory. (Poly%spec.Directory. self@)))
;        )))))
;        (assume
;         (= tmp%88@ (nClip (+ i@ 1)))
;        )
;        (block
;         (assume
;          (ens%spec.Directory.inv_implies_interp_aux_inv. self@ tmp%88@)
;        ))
;        (assume
;         (has_type va$5@ NAT)
;        )
;        (switch
;         (block
;          (assume
;           (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;             (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;               (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                  (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;             )))))
;            ) va$5@
;          ))
;          (block
;           (assert
;            ("recommendation not met")
;            (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;          ))
;          (assume
;           (= tmp%89@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;          )
;          (assume
;           (= tmp%90@ (>= (%I va$5@) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;                 (Poly%spec.Directory. self@)
;                )
;               ) (nClip (* (nClip (+ i@ 1)) tmp%89@))
;         ))))))
;         (block
;          (assume
;           (not (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;              (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                   (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;              )))))
;             ) va$5@
;          )))
;          (assume
;           (= tmp%90@ true)
;        )))
;        (assume
;         (= tmp%91@ (forall ((va$ Poly)) (!
;            (=>
;             (has_type va$ NAT)
;             (=>
;              (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                  (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                     (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;                )))))
;               ) va$
;              )
;              (>= (%I va$) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                    self@
;                  ))
;                 ) (nClip (* (nClip (+ i@ 1)) (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;            )))))
;            :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;               (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                 (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                    (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;               )))))
;              ) va$
;        ))))))
;        (block
;         (assume
;          (ens%pervasive.assume. tmp%91@)
;        ))
;        (assume
;         (has_type va$6@ NAT)
;        )
;        (switch
;         (block
;          (assume
;           (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;             (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;               (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                  (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;             )))))
;            ) va$6@
;          ))
;          (block
;           (assert
;            ("recommendation not met")
;            (req%spec.Directory.num_entries. (Poly%spec.Directory. self@))
;          ))
;          (assume
;           (= tmp%92@ (spec.Directory.num_entries.? (Poly%spec.Directory. self@)))
;          )
;          (block
;           (assert
;            ("recommendation not met")
;            (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;          ))
;          (assume
;           (= tmp%93@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;          )
;          (assume
;           (= tmp%94@ (<= (%I va$6@) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;                 (Poly%spec.Directory. self@)
;                )
;               ) (nClip (* tmp%92@ tmp%93@))
;         ))))))
;         (block
;          (assume
;           (not (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;              (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                   (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;              )))))
;             ) va$6@
;          )))
;          (assume
;           (= tmp%94@ true)
;        )))
;        (assume
;         (= tmp%95@ (forall ((va$ Poly)) (!
;            (=>
;             (has_type va$ NAT)
;             (=>
;              (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                  (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                     (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;                )))))
;               ) va$
;              )
;              (<= (%I va$) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                    self@
;                  ))
;                 ) (nClip (* (spec.Directory.num_entries.? (Poly%spec.Directory. self@)) (spec.Directory.entry_size.?
;                    (Poly%spec.Directory. self@)
;            ))))))))
;            :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;               (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                 (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                    (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;               )))))
;              ) va$
;        ))))))
;        (block
;         (assume
;          (ens%pervasive.assume. tmp%95@)
;        ))
;        (assume
;         (= tmp%%1@ (ite
;           (< (%I b1@) (%I b2@))
;           (tuple%2./tuple%2 b1@ b2@)
;           (tuple%2./tuple%2 b2@ b1@)
;        )))
;        (assume
;         (= c1@ (%I (tuple%2./tuple%2/field%0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%1@)))))
;        )
;        (assume
;         (= c2@ (%I (tuple%2./tuple%2/field%1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%1@)))))
;        )
;        (assume
;         (= tmp%96@ (< c1@ c2@))
;        )
;        (block
;         (assume
;          (ens%pervasive.assert. tmp%96@)
;        ))
;        (assume
;         (= tmp%98@ (Poly%pervasive.seq.Seq<spec.NodeEntry.>. (spec.Directory./Directory/entries
;            (%Poly%spec.Directory. (Poly%spec.Directory. self@))
;        ))))
;        (block
;         (assert
;          ("recommendation not met")
;          (req%pervasive.seq.Seq.index. TYPE%spec.NodeEntry. tmp%98@ (I i@))
;        ))
;        (assume
;         (= tmp%97@ (pervasive.seq.Seq.index.? TYPE%spec.NodeEntry. (Poly%pervasive.seq.Seq<spec.NodeEntry.>.
;            (spec.Directory./Directory/entries (%Poly%spec.Directory. (Poly%spec.Directory. self@)))
;           ) (I i@)
;        )))
;        (assume
;         (= tmp%%2@ (%Poly%spec.NodeEntry. tmp%97@))
;        )
;        (switch
;         (block
;          (assume
;           (is-spec.NodeEntry./Page tmp%%2@)
;          )
;          (assume
;           (= p@ (spec.NodeEntry./Page/_0 (%Poly%spec.NodeEntry. (Poly%spec.NodeEntry. tmp%%2@))))
;          )
;          (block
;           (assert
;            ("recommendation not met")
;            (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;          ))
;          (assume
;           (= tmp%99@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;          )
;          (assume
;           (= new_va@ (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                 self@
;               ))
;              ) (nClip (* i@ tmp%99@))
;          ))))
;          (deadend (block
;            (assume
;             true
;            )
;            (switch
;             (block
;              (assume
;               (and
;                (not (= c1@ new_va@))
;                (not (= c2@ new_va@))
;              ))
;              (assume
;               (= tmp%101@ (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                  (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;              ))))
;              (block
;               (assert
;                ("recommendation not met")
;                (req%pervasive.map.Map.index. NAT TYPE%spec.MemRegion. tmp%101@ (I c1@))
;              ))
;              (assume
;               (= tmp%100@ (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                  (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                     interp@
;                  )))
;                 ) (I c1@)
;              )))
;              (assume
;               (= tmp%103@ (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                  (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;              ))))
;              (block
;               (assert
;                ("recommendation not met")
;                (req%pervasive.map.Map.index. NAT TYPE%spec.MemRegion. tmp%103@ (I c2@))
;              ))
;              (assume
;               (= tmp%102@ (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                  (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                     interp@
;                  )))
;                 ) (I c2@)
;              )))
;              (assume
;               (= tmp%104@ (not (spec.overlap.? (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (
;                      I c1@
;                     )
;                    ) (%I (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. tmp%100@))))
;                   )
;                  ) (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I c2@)) (%I (I (spec.MemRegion./MemRegion/size
;                       (%Poly%spec.MemRegion. tmp%102@)
;              )))))))))
;              (block
;               (assume
;                (ens%pervasive.assert. tmp%104@)
;             )))
;             (block
;              (assume
;               (not (and
;                 (not (= c1@ new_va@))
;                 (not (= c2@ new_va@))
;              )))
;              (switch
;               (block
;                (assume
;                 (= c1@ new_va@)
;                )
;                (assume
;                 (= tmp%105@ (= (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                     (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                        (spec.Directory.interp_aux.? (Poly%spec.Directory. self@) (I i@))
;                    ))))
;                   ) (pervasive.set.Set.insert.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                     (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                       (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                          (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;                     )))))
;                    ) (I new_va@)
;                ))))
;                (block
;                 (assume
;                  (ens%pervasive.assert. tmp%105@)
;                ))
;                (assume
;                 (= tmp%106@ (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                    (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                      (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                         (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;                    )))))
;                   ) (I c2@)
;                )))
;                (block
;                 (assume
;                  (ens%pervasive.assert. tmp%106@)
;                ))
;                (block
;                 (assert
;                  ("recommendation not met")
;                  (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;                ))
;                (assume
;                 (= tmp%107@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;                )
;                (assume
;                 (= tmp%108@ (>= c2@ (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;                       (Poly%spec.Directory. self@)
;                      )
;                     ) (nClip (* (nClip (+ i@ 1)) tmp%107@))
;                )))))
;                (block
;                 (assume
;                  (ens%pervasive.assert. tmp%108@)
;                ))
;                (block
;                 (assert
;                  ("recommendation not met")
;                  (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;                ))
;                (assume
;                 (= tmp%109@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;                )
;                (block
;                 (assume
;                  (ens%lib.mul_distributive. i@ tmp%109@)
;                ))
;                (block
;                 (assert
;                  ("recommendation not met")
;                  (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;                ))
;                (assume
;                 (= tmp%110@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;                )
;                (block
;                 (assert
;                  ("recommendation not met")
;                  (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;                ))
;                (assume
;                 (= tmp%111@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;                )
;                (block
;                 (assert
;                  ("recommendation not met")
;                  (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;                ))
;                (assume
;                 (= tmp%112@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;                )
;                (assume
;                 (= tmp%113@ (= (nClip (+ (nClip (* i@ tmp%110@)) tmp%111@)) (nClip (* (nClip (+ i@ 1))
;                     tmp%112@
;                )))))
;                (block
;                 (assume
;                  (ens%pervasive.assume. tmp%113@)
;                ))
;                (block
;                 (assert
;                  ("recommendation not met")
;                  (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;                ))
;                (assume
;                 (= tmp%114@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;                )
;                (block
;                 (assert
;                  ("recommendation not met")
;                  (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;                ))
;                (assume
;                 (= tmp%115@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;                )
;                (block
;                 (assert
;                  ("recommendation not met")
;                  (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;                ))
;                (assume
;                 (= tmp%116@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;                )
;                (assume
;                 (= tmp%117@ (= (nClip (+ (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;                         (Poly%spec.Directory. self@)
;                        )
;                       ) (nClip (* i@ tmp%114@))
;                      )
;                     ) tmp%115@
;                    )
;                   ) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                        self@
;                      ))
;                     ) (nClip (* (nClip (+ i@ 1)) tmp%116@))
;                )))))
;                (block
;                 (assume
;                  (ens%pervasive.assert. tmp%117@)
;                ))
;                (block
;                 (assert
;                  ("recommendation not met")
;                  (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;                ))
;                (assume
;                 (= tmp%118@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;                )
;                (block
;                 (assert
;                  ("recommendation not met")
;                  (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;                ))
;                (assume
;                 (= tmp%119@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;                )
;                (assume
;                 (= tmp%120@ (= (nClip (+ c1@ tmp%118@)) (nClip (+ (spec.Directory./Directory/base_vaddr
;                      (%Poly%spec.Directory. (Poly%spec.Directory. self@))
;                     ) (nClip (* (nClip (+ i@ 1)) tmp%119@))
;                )))))
;                (block
;                 (assume
;                  (ens%pervasive.assert. tmp%120@)
;                ))
;                (assume
;                 (= tmp%122@ (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                    (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;                ))))
;                (block
;                 (assert
;                  ("recommendation not met")
;                  (req%pervasive.map.Map.index. NAT TYPE%spec.MemRegion. tmp%122@ (I c1@))
;                ))
;                (assume
;                 (= tmp%121@ (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                    (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                       interp@
;                    )))
;                   ) (I c1@)
;                )))
;                (assume
;                 (= tmp%124@ (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                    (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;                ))))
;                (block
;                 (assert
;                  ("recommendation not met")
;                  (req%pervasive.map.Map.index. NAT TYPE%spec.MemRegion. tmp%124@ (I c2@))
;                ))
;                (assume
;                 (= tmp%123@ (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                    (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                       interp@
;                    )))
;                   ) (I c2@)
;                )))
;                (assume
;                 (= tmp%125@ (not (spec.overlap.? (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (
;                        I c1@
;                       )
;                      ) (%I (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. tmp%121@))))
;                     )
;                    ) (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I c2@)) (%I (I (spec.MemRegion./MemRegion/size
;                         (%Poly%spec.MemRegion. tmp%123@)
;                )))))))))
;                (block
;                 (assume
;                  (ens%pervasive.assert. tmp%125@)
;               )))
;               (block
;                (assume
;                 (not (= c1@ new_va@))
;                )
;                (assume
;                 (= tmp%126@ (= c2@ new_va@))
;                )
;                (block
;                 (assume
;                  (ens%pervasive.assert. tmp%126@)
;                ))
;                (assume
;                 (= tmp%127@ (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                    (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                      (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                         (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;                    )))))
;                   ) (I c1@)
;                )))
;                (block
;                 (assume
;                  (ens%pervasive.assert. tmp%127@)
;                ))
;                (block
;                 (assert
;                  ("recommendation not met")
;                  (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;                ))
;                (assume
;                 (= tmp%128@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;                )
;                (assume
;                 (= tmp%129@ (>= c1@ (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;                       (Poly%spec.Directory. self@)
;                      )
;                     ) (nClip (* (nClip (+ i@ 1)) tmp%128@))
;                )))))
;                (block
;                 (assume
;                  (ens%pervasive.assert. tmp%129@)
;                ))
;                (block
;                 (assert
;                  ("recommendation not met")
;                  (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;                ))
;                (assume
;                 (= tmp%130@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;                )
;                (assume
;                 (= tmp%131@ (= c2@ (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;                       (Poly%spec.Directory. self@)
;                      )
;                     ) (nClip (* i@ tmp%130@))
;                )))))
;                (block
;                 (assume
;                  (ens%pervasive.assert. tmp%131@)
;                ))
;                (assume
;                 (= tmp%132@ (>= c1@ c2@))
;                )
;                (block
;                 (assume
;                  (ens%pervasive.assume. tmp%132@)
;                ))
;                (block
;                 (assume
;                  (ens%pervasive.assert. false)
;            ))))))
;            (assume
;             (= tmp%134@ (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;            ))))
;            (block
;             (assert
;              ("recommendation not met")
;              (req%pervasive.map.Map.index. NAT TYPE%spec.MemRegion. tmp%134@ (I c1@))
;            ))
;            (assume
;             (= tmp%133@ (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                   interp@
;                )))
;               ) (I c1@)
;            )))
;            (assume
;             (= tmp%136@ (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;            ))))
;            (block
;             (assert
;              ("recommendation not met")
;              (req%pervasive.map.Map.index. NAT TYPE%spec.MemRegion. tmp%136@ (I c2@))
;            ))
;            (assume
;             (= tmp%135@ (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                   interp@
;                )))
;               ) (I c2@)
;          )))))
;          (assume
;           (not (spec.overlap.? (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I c1@)) (%I
;                (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
;                    NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                      (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;                     )
;                    ) (I c1@)
;              ))))))
;             ) (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I c2@)) (%I (I (spec.MemRegion./MemRegion/size
;                  (%Poly%spec.MemRegion. (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                     (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                        interp@
;                     )))
;                    ) (I c2@)
;         )))))))))))
;         (block
;          (assume
;           (not (is-spec.NodeEntry./Page tmp%%2@))
;          )
;          (switch
;           (block
;            (assume
;             (is-spec.NodeEntry./Directory tmp%%2@)
;            )
;            (assume
;             (= d@ (spec.NodeEntry./Directory/_0 (%Poly%spec.NodeEntry. (Poly%spec.NodeEntry. tmp%%2@))))
;            )
;            (deadend (block
;              (assume
;               true
;              )
;              (block
;               (assume
;                (ens%spec.Directory.inv_implies_interp_aux_inv. d@ 0)
;              ))
;              (assume
;               (has_type va$7@ NAT)
;              )
;              (switch
;               (block
;                (assume
;                 (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                   (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                     (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                        (Poly%spec.Directory. d@) (I 0)
;                   )))))
;                  ) va$7@
;                ))
;                (block
;                 (assert
;                  ("recommendation not met")
;                  (req%spec.Directory.num_entries. (Poly%spec.Directory. d@))
;                ))
;                (assume
;                 (= tmp%137@ (spec.Directory.num_entries.? (Poly%spec.Directory. d@)))
;                )
;                (block
;                 (assert
;                  ("recommendation not met")
;                  (req%spec.Directory.entry_size. (Poly%spec.Directory. d@))
;                ))
;                (assume
;                 (= tmp%138@ (spec.Directory.entry_size.? (Poly%spec.Directory. d@)))
;                )
;                (assume
;                 (= tmp%139@ (<= (%I va$7@) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;                       (Poly%spec.Directory. d@)
;                      )
;                     ) (nClip (* tmp%137@ tmp%138@))
;               ))))))
;               (block
;                (assume
;                 (not (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                    (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                      (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                         (Poly%spec.Directory. d@) (I 0)
;                    )))))
;                   ) va$7@
;                )))
;                (assume
;                 (= tmp%139@ true)
;              )))
;              (assume
;               (= tmp%140@ (forall ((va$ Poly)) (!
;                  (=>
;                   (has_type va$ NAT)
;                   (=>
;                    (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                      (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                        (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                           (Poly%spec.Directory. d@) (I 0)
;                      )))))
;                     ) va$
;                    )
;                    (<= (%I va$) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                          d@
;                        ))
;                       ) (nClip (* (spec.Directory.num_entries.? (Poly%spec.Directory. d@)) (spec.Directory.entry_size.?
;                          (Poly%spec.Directory. d@)
;                  ))))))))
;                  :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                     (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                       (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                          (Poly%spec.Directory. d@) (I 0)
;                     )))))
;                    ) va$
;              ))))))
;              (block
;               (assume
;                (ens%pervasive.assume. tmp%140@)
;              ))
;              (assume
;               (has_type va$8@ NAT)
;              )
;              (assume
;               (= tmp%141@ (forall ((va$ Poly)) (!
;                  (=>
;                   (has_type va$ NAT)
;                   (=>
;                    (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                      (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                        (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                           (Poly%spec.Directory. d@) (I 0)
;                      )))))
;                     ) va$
;                    )
;                    (>= (%I va$) (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                        d@
;                  ))))))
;                  :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                     (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                       (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                          (Poly%spec.Directory. d@) (I 0)
;                     )))))
;                    ) va$
;              ))))))
;              (block
;               (assume
;                (ens%pervasive.assert. tmp%141@)
;              ))
;              (assume
;               (has_type va$9@ NAT)
;              )
;              (switch
;               (block
;                (assume
;                 (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                   (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                     (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                        (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;                   )))))
;                  ) va$9@
;                ))
;                (block
;                 (assert
;                  ("recommendation not met")
;                  (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;                ))
;                (assume
;                 (= tmp%142@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;                )
;                (assume
;                 (= tmp%143@ (>= (%I va$9@) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;                       (Poly%spec.Directory. self@)
;                      )
;                     ) (nClip (* (nClip (+ i@ 1)) tmp%142@))
;               ))))))
;               (block
;                (assume
;                 (not (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                    (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                      (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                         (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;                    )))))
;                   ) va$9@
;                )))
;                (assume
;                 (= tmp%143@ true)
;              )))
;              (assume
;               (= tmp%144@ (forall ((va$ Poly)) (!
;                  (=>
;                   (has_type va$ NAT)
;                   (=>
;                    (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                      (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                        (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                           (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;                      )))))
;                     ) va$
;                    )
;                    (>= (%I va$) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                          self@
;                        ))
;                       ) (nClip (* (nClip (+ i@ 1)) (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;                  )))))
;                  :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                     (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                       (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                          (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;                     )))))
;                    ) va$
;              ))))))
;              (block
;               (assume
;                (ens%pervasive.assert. tmp%144@)
;              ))
;              (assume
;               (has_type va$10@ NAT)
;              )
;              (switch
;               (block
;                (assume
;                 (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                   (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                     (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                        (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;                   )))))
;                  ) va$10@
;                ))
;                (block
;                 (assert
;                  ("recommendation not met")
;                  (req%spec.Directory.num_entries. (Poly%spec.Directory. self@))
;                ))
;                (assume
;                 (= tmp%145@ (spec.Directory.num_entries.? (Poly%spec.Directory. self@)))
;                )
;                (block
;                 (assert
;                  ("recommendation not met")
;                  (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;                ))
;                (assume
;                 (= tmp%146@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;                )
;                (assume
;                 (= tmp%147@ (<= (%I va$10@) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;                       (Poly%spec.Directory. self@)
;                      )
;                     ) (nClip (* tmp%145@ tmp%146@))
;               ))))))
;               (block
;                (assume
;                 (not (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                    (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                      (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                         (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;                    )))))
;                   ) va$10@
;                )))
;                (assume
;                 (= tmp%147@ true)
;              )))
;              (assume
;               (= tmp%148@ (forall ((va$ Poly)) (!
;                  (=>
;                   (has_type va$ NAT)
;                   (=>
;                    (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                      (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                        (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                           (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;                      )))))
;                     ) va$
;                    )
;                    (<= (%I va$) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                          self@
;                        ))
;                       ) (nClip (* (spec.Directory.num_entries.? (Poly%spec.Directory. self@)) (spec.Directory.entry_size.?
;                          (Poly%spec.Directory. self@)
;                  ))))))))
;                  :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                     (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                       (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                          (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;                     )))))
;                    ) va$
;              ))))))
;              (block
;               (assume
;                (ens%pervasive.assert. tmp%148@)
;              ))
;              (assume
;               (= i1_interp@ (%Poly%pervasive.set.Set<nat.>. (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                  (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                    (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                       (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;              )))))))))
;              (assume
;               (= d_interp@ (%Poly%pervasive.set.Set<nat.>. (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                  (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                    (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                       (Poly%spec.Directory. d@) (I 0)
;              )))))))))
;              (switch
;               (block
;                (assume
;                 (and
;                  (pervasive.set.Set.contains.? NAT (Poly%pervasive.set.Set<nat.>. i1_interp@) (I c1@))
;                  (pervasive.set.Set.contains.? NAT (Poly%pervasive.set.Set<nat.>. i1_interp@) (I c2@))
;                ))
;                (assume
;                 (= tmp%149@ (spec.PageTableContents.inv.? (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                     (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;                )))))
;                (block
;                 (assume
;                  (ens%pervasive.assert. tmp%149@)
;                ))
;                (assume
;                 (= tmp%150@ (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                    (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                      (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                         (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;                    )))))
;                   ) (I c1@)
;                )))
;                (block
;                 (assume
;                  (ens%pervasive.assert. tmp%150@)
;                ))
;                (assume
;                 (= tmp%151@ (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;                    (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                      (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                         (Poly%spec.Directory. self@) (I (nClip (+ i@ 1)))
;                    )))))
;                   ) (I c2@)
;                )))
;                (block
;                 (assume
;                  (ens%pervasive.assert. tmp%151@)
;                ))
;                (assume
;                 (= tmp%152@ (not (= c1@ c2@)))
;                )
;                (block
;                 (assume
;                  (ens%pervasive.assert. tmp%152@)
;                ))
;                (assume
;                 (= tmp%154@ (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                    (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;                ))))
;                (block
;                 (assert
;                  ("recommendation not met")
;                  (req%pervasive.map.Map.index. NAT TYPE%spec.MemRegion. tmp%154@ (I c1@))
;                ))
;                (assume
;                 (= tmp%153@ (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                    (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                       interp@
;                    )))
;                   ) (I c1@)
;                )))
;                (assume
;                 (= tmp%156@ (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                    (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;                ))))
;                (block
;                 (assert
;                  ("recommendation not met")
;                  (req%pervasive.map.Map.index. NAT TYPE%spec.MemRegion. tmp%156@ (I c2@))
;                ))
;                (assume
;                 (= tmp%155@ (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                    (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                       interp@
;                    )))
;                   ) (I c2@)
;                )))
;                (assume
;                 (= tmp%157@ (not (spec.overlap.? (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (
;                        I c1@
;                       )
;                      ) (%I (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. tmp%153@))))
;                     )
;                    ) (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I c2@)) (%I (I (spec.MemRegion./MemRegion/size
;                         (%Poly%spec.MemRegion. tmp%155@)
;                )))))))))
;                (block
;                 (assume
;                  (ens%pervasive.assume. tmp%157@)
;               )))
;               (block
;                (assume
;                 (not (and
;                   (pervasive.set.Set.contains.? NAT (Poly%pervasive.set.Set<nat.>. i1_interp@) (I c1@))
;                   (pervasive.set.Set.contains.? NAT (Poly%pervasive.set.Set<nat.>. i1_interp@) (I c2@))
;                )))
;                (switch
;                 (block
;                  (assume
;                   (and
;                    (pervasive.set.Set.contains.? NAT (Poly%pervasive.set.Set<nat.>. d_interp@) (I c1@))
;                    (pervasive.set.Set.contains.? NAT (Poly%pervasive.set.Set<nat.>. d_interp@) (I c2@))
;                  ))
;                  (assume
;                   (= tmp%159@ (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                      (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;                  ))))
;                  (block
;                   (assert
;                    ("recommendation not met")
;                    (req%pervasive.map.Map.index. NAT TYPE%spec.MemRegion. tmp%159@ (I c1@))
;                  ))
;                  (assume
;                   (= tmp%158@ (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                      (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                         interp@
;                      )))
;                     ) (I c1@)
;                  )))
;                  (assume
;                   (= tmp%161@ (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                      (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;                  ))))
;                  (block
;                   (assert
;                    ("recommendation not met")
;                    (req%pervasive.map.Map.index. NAT TYPE%spec.MemRegion. tmp%161@ (I c2@))
;                  ))
;                  (assume
;                   (= tmp%160@ (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                      (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                         interp@
;                      )))
;                     ) (I c2@)
;                  )))
;                  (assume
;                   (= tmp%162@ (not (spec.overlap.? (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (
;                          I c1@
;                         )
;                        ) (%I (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. tmp%158@))))
;                       )
;                      ) (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I c2@)) (%I (I (spec.MemRegion./MemRegion/size
;                           (%Poly%spec.MemRegion. tmp%160@)
;                  )))))))))
;                  (block
;                   (assume
;                    (ens%pervasive.assert. tmp%162@)
;                 )))
;                 (block
;                  (assume
;                   (not (and
;                     (pervasive.set.Set.contains.? NAT (Poly%pervasive.set.Set<nat.>. d_interp@) (I c1@))
;                     (pervasive.set.Set.contains.? NAT (Poly%pervasive.set.Set<nat.>. d_interp@) (I c2@))
;                  )))
;                  (switch
;                   (block
;                    (assume
;                     (and
;                      (pervasive.set.Set.contains.? NAT (Poly%pervasive.set.Set<nat.>. i1_interp@) (I c2@))
;                      (pervasive.set.Set.contains.? NAT (Poly%pervasive.set.Set<nat.>. d_interp@) (I c1@))
;                    ))
;                    (assume
;                     (= tmp%163@ (< c1@ c2@))
;                    )
;                    (block
;                     (assume
;                      (ens%pervasive.assert. tmp%163@)
;                    ))
;                    (block
;                     (assert
;                      ("recommendation not met")
;                      (req%spec.Directory.num_entries. (Poly%spec.Directory. self@))
;                    ))
;                    (assume
;                     (= tmp%164@ (spec.Directory.num_entries.? (Poly%spec.Directory. self@)))
;                    )
;                    (block
;                     (assert
;                      ("recommendation not met")
;                      (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;                    ))
;                    (assume
;                     (= tmp%165@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;                    )
;                    (assume
;                     (= tmp%166@ (<= c2@ (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;                           (Poly%spec.Directory. self@)
;                          )
;                         ) (nClip (* tmp%164@ tmp%165@))
;                    )))))
;                    (block
;                     (assume
;                      (ens%pervasive.assert. tmp%166@)
;                    ))
;                    (assume
;                     (= tmp%167@ (<= c2@ c1@))
;                    )
;                    (block
;                     (assume
;                      (ens%pervasive.assume. tmp%167@)
;                    ))
;                    (block
;                     (assume
;                      (ens%pervasive.assert. false)
;                   )))
;                   (block
;                    (assume
;                     (not (and
;                       (pervasive.set.Set.contains.? NAT (Poly%pervasive.set.Set<nat.>. i1_interp@) (I c2@))
;                       (pervasive.set.Set.contains.? NAT (Poly%pervasive.set.Set<nat.>. d_interp@) (I c1@))
;                    )))
;                    (block
;                     (assume
;                      (ens%pervasive.assume. false)
;              ))))))))
;              (assume
;               (= tmp%169@ (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                  (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;              ))))
;              (block
;               (assert
;                ("recommendation not met")
;                (req%pervasive.map.Map.index. NAT TYPE%spec.MemRegion. tmp%169@ (I c1@))
;              ))
;              (assume
;               (= tmp%168@ (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                  (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                     interp@
;                  )))
;                 ) (I c1@)
;              )))
;              (assume
;               (= tmp%171@ (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                  (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;              ))))
;              (block
;               (assert
;                ("recommendation not met")
;                (req%pervasive.map.Map.index. NAT TYPE%spec.MemRegion. tmp%171@ (I c2@))
;              ))
;              (assume
;               (= tmp%170@ (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                  (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                     interp@
;                  )))
;                 ) (I c2@)
;            )))))
;            (assume
;             (not (spec.overlap.? (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I c1@)) (%I
;                  (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
;                      NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                        (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;                       )
;                      ) (I c1@)
;                ))))))
;               ) (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I c2@)) (%I (I (spec.MemRegion./MemRegion/size
;                    (%Poly%spec.MemRegion. (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                       (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                          interp@
;                       )))
;                      ) (I c2@)
;           )))))))))))
;           (block
;            (assume
;             (not (is-spec.NodeEntry./Directory tmp%%2@))
;        )))))
;        (assume
;         (= tmp%173@ (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;            (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;        ))))
;        (block
;         (assert
;          ("recommendation not met")
;          (req%pervasive.map.Map.index. NAT TYPE%spec.MemRegion. tmp%173@ (I c1@))
;        ))
;        (assume
;         (= tmp%172@ (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;            (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;               interp@
;            )))
;           ) (I c1@)
;        )))
;        (assume
;         (= tmp%175@ (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;            (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;        ))))
;        (block
;         (assert
;          ("recommendation not met")
;          (req%pervasive.map.Map.index. NAT TYPE%spec.MemRegion. tmp%175@ (I c2@))
;        ))
;        (assume
;         (= tmp%174@ (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;            (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;               interp@
;            )))
;           ) (I c2@)
;        )))
;        (assume
;         (= tmp%176@ (not (spec.overlap.? (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (
;                I c1@
;               )
;              ) (%I (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. tmp%172@))))
;             )
;            ) (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I (I c2@)) (%I (I (spec.MemRegion./MemRegion/size
;                 (%Poly%spec.MemRegion. tmp%174@)
;        )))))))))
;        (block
;         (assume
;          (ens%pervasive.assert. tmp%176@)
;      ))))
;      (assume
;       (= tmp%178@ (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;          (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;      ))))
;      (block
;       (assert
;        ("recommendation not met")
;        (req%pervasive.map.Map.index. NAT TYPE%spec.MemRegion. tmp%178@ b1@)
;      ))
;      (assume
;       (= tmp%177@ (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;          (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;             interp@
;          )))
;         ) b1@
;      )))
;      (assume
;       (= tmp%180@ (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;          (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;      ))))
;      (block
;       (assert
;        ("recommendation not met")
;        (req%pervasive.map.Map.index. NAT TYPE%spec.MemRegion. tmp%180@ b2@)
;      ))
;      (assume
;       (= tmp%179@ (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;          (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;             interp@
;          )))
;         ) b2@
;    )))))
;    (assume
;     (forall ((b1$ Poly) (b2$ Poly)) (!
;       (=>
;        (and
;         (has_type b1$ NAT)
;         (has_type b2$ NAT)
;        )
;        (=>
;         (and
;          (and
;           (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;             (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;               (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;             ))
;            ) b1$
;           )
;           (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;             (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;               (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;             ))
;            ) b2$
;          ))
;          (not (= b1$ b2$))
;         )
;         (not (spec.overlap.? (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I b1$) (%I (I (
;                spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (pervasive.map.Map.index.? NAT
;                  TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                    (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;                   )
;                  ) b1$
;            ))))))
;           ) (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I b2$) (%I (I (spec.MemRegion./MemRegion/size
;                (%Poly%spec.MemRegion. (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                   (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                      interp@
;                   )))
;                  ) b2$
;       )))))))))))
;       :pattern ((spec.overlap.? (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I b1$) (
;            %I (I (spec.MemRegion./MemRegion/size (%Poly%spec.MemRegion. (pervasive.map.Map.index.?
;                NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;                  (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. interp@))
;                 )
;                ) b1$
;          ))))))
;         ) (Poly%spec.MemRegion. (spec.MemRegion./MemRegion (%I b2$) (%I (I (spec.MemRegion./MemRegion/size
;              (%Poly%spec.MemRegion. (pervasive.map.Map.index.? NAT TYPE%spec.MemRegion. (Poly%pervasive.map.Map<nat./spec.MemRegion.>.
;                 (spec.PageTableContents./PageTableContents/map (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents.
;                    interp@
;                 )))
;                ) b2$
;    ))))))))))))
;    (assume
;     (has_type va$11@ NAT)
;    )
;    (switch
;     (block
;      (assume
;       (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;         (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;           (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;              (Poly%spec.Directory. self@) (I i@)
;         )))))
;        ) va$11@
;      ))
;      (block
;       (assert
;        ("recommendation not met")
;        (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;      ))
;      (assume
;       (= tmp%181@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;      )
;      (assume
;       (= tmp%182@ (>= (%I va$11@) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;             (Poly%spec.Directory. self@)
;            )
;           ) (nClip (* i@ tmp%181@))
;     ))))))
;     (block
;      (assume
;       (not (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;          (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;            (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;               (Poly%spec.Directory. self@) (I i@)
;          )))))
;         ) va$11@
;      )))
;      (assume
;       (= tmp%182@ true)
;    )))
;    (assume
;     (= tmp%183@ (forall ((va$ Poly)) (!
;        (=>
;         (has_type va$ NAT)
;         (=>
;          (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;            (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;              (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                 (Poly%spec.Directory. self@) (I i@)
;            )))))
;           ) va$
;          )
;          (>= (%I va$) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                self@
;              ))
;             ) (nClip (* i@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@))))
;        )))))
;        :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;           (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;             (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                (Poly%spec.Directory. self@) (I i@)
;           )))))
;          ) va$
;    ))))))
;    (block
;     (assume
;      (ens%pervasive.assume. tmp%183@)
;    ))
;    (assume
;     (has_type va$12@ NAT)
;    )
;    (switch
;     (block
;      (assume
;       (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;         (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;           (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;              (Poly%spec.Directory. self@) (I i@)
;         )))))
;        ) va$12@
;      ))
;      (block
;       (assert
;        ("recommendation not met")
;        (req%spec.Directory.num_entries. (Poly%spec.Directory. self@))
;      ))
;      (assume
;       (= tmp%184@ (spec.Directory.num_entries.? (Poly%spec.Directory. self@)))
;      )
;      (block
;       (assert
;        ("recommendation not met")
;        (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;      ))
;      (assume
;       (= tmp%185@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;      )
;      (assume
;       (= tmp%186@ (<= (%I va$12@) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;             (Poly%spec.Directory. self@)
;            )
;           ) (nClip (* tmp%184@ tmp%185@))
;     ))))))
;     (block
;      (assume
;       (not (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;          (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;            (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;               (Poly%spec.Directory. self@) (I i@)
;          )))))
;         ) va$12@
;      )))
;      (assume
;       (= tmp%186@ true)
;    )))
;    (assume
;     (= tmp%187@ (forall ((va$ Poly)) (!
;        (=>
;         (has_type va$ NAT)
;         (=>
;          (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;            (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;              (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                 (Poly%spec.Directory. self@) (I i@)
;            )))))
;           ) va$
;          )
;          (<= (%I va$) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory. (Poly%spec.Directory.
;                self@
;              ))
;             ) (nClip (* (spec.Directory.num_entries.? (Poly%spec.Directory. self@)) (spec.Directory.entry_size.?
;                (Poly%spec.Directory. self@)
;        ))))))))
;        :pattern ((pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;           (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;             (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;                (Poly%spec.Directory. self@) (I i@)
;           )))))
;          ) va$
;    ))))))
;    (block
;     (assume
;      (ens%pervasive.assume. tmp%187@)
;    ))
;    (assume
;     (has_type va@ NAT)
;    )
;    (switch
;     (block
;      (assume
;       (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;         (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;           (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;              (Poly%spec.Directory. self@) (I i@)
;         )))))
;        ) va@
;      ))
;      (block
;       (assert
;        ("recommendation not met")
;        (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;      ))
;      (assume
;       (= tmp%1@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;      )
;      (assume
;       (= tmp%2@ (>= (%I va@) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;             (Poly%spec.Directory. self@)
;            )
;           ) (nClip (* i@ tmp%1@))
;     ))))))
;     (block
;      (assume
;       (not (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;          (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;            (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;               (Poly%spec.Directory. self@) (I i@)
;          )))))
;         ) va@
;      )))
;      (assume
;       (= tmp%2@ true)
;    )))
;    (assume
;     (has_type va$1@ NAT)
;    )
;    (switch
;     (block
;      (assume
;       (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;         (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;           (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;              (Poly%spec.Directory. self@) (I i@)
;         )))))
;        ) va$1@
;      ))
;      (block
;       (assert
;        ("recommendation not met")
;        (req%spec.Directory.num_entries. (Poly%spec.Directory. self@))
;      ))
;      (assume
;       (= tmp%3@ (spec.Directory.num_entries.? (Poly%spec.Directory. self@)))
;      )
;      (block
;       (assert
;        ("recommendation not met")
;        (req%spec.Directory.entry_size. (Poly%spec.Directory. self@))
;      ))
;      (assume
;       (= tmp%4@ (spec.Directory.entry_size.? (Poly%spec.Directory. self@)))
;      )
;      (assume
;       (= tmp%5@ (<= (%I va$1@) (nClip (+ (spec.Directory./Directory/base_vaddr (%Poly%spec.Directory.
;             (Poly%spec.Directory. self@)
;            )
;           ) (nClip (* tmp%3@ tmp%4@))
;     ))))))
;     (block
;      (assume
;       (not (pervasive.set.Set.contains.? NAT (pervasive.map.Map.dom.? NAT TYPE%spec.MemRegion.
;          (Poly%pervasive.map.Map<nat./spec.MemRegion.>. (spec.PageTableContents./PageTableContents/map
;            (%Poly%spec.PageTableContents. (Poly%spec.PageTableContents. (spec.Directory.interp_aux.?
;               (Poly%spec.Directory. self@) (I i@)
;          )))))
;         ) va$1@
;      )))
;      (assume
;       (= tmp%5@ true)
;  )))))
; (pop)
; 
; ;; MODULE 'lib'
; (push)
; 
;  ;; Fuel
;  (axiom true)
; 
;  ;; Datatypes
;  (declare-datatypes () ((tuple%0. (tuple%0./tuple%0))))
;  (declare-fun TYPE%pervasive.invariant.Invariant. (Type) Type)
;  (declare-fun TYPE%pervasive.invariant.LocalInvariant. (Type) Type)
;  (declare-const TYPE%tuple%0. Type)
;  (declare-fun Poly%tuple%0. (tuple%0.) Poly)
;  (declare-fun %Poly%tuple%0. (Poly) tuple%0.)
;  (axiom (forall ((x@ tuple%0.)) (!
;     (= x@ (%Poly%tuple%0. (Poly%tuple%0. x@)))
;     :pattern ((Poly%tuple%0. x@))
;  )))
;  (axiom (forall ((x@ Poly)) (!
;     (=>
;      (has_type x@ TYPE%tuple%0.)
;      (= x@ (Poly%tuple%0. (%Poly%tuple%0. x@)))
;     )
;     :pattern ((has_type x@ TYPE%tuple%0.))
;  )))
;  (axiom (forall ((x@ tuple%0.)) (!
;     (has_type (Poly%tuple%0. x@) TYPE%tuple%0.)
;     :pattern ((has_type (Poly%tuple%0. x@) TYPE%tuple%0.))
;  )))
; 
;  ;; Function-Decl crate::pervasive::invariant::Invariant::inv
;  (declare-fun pervasive.invariant.Invariant.inv.? (Type Poly Poly) Bool)
; 
;  ;; Function-Decl crate::pervasive::invariant::Invariant::namespace
;  (declare-fun pervasive.invariant.Invariant.namespace.? (Type Poly) Int)
; 
;  ;; Function-Decl crate::pervasive::invariant::LocalInvariant::inv
;  (declare-fun pervasive.invariant.LocalInvariant.inv.? (Type Poly Poly) Bool)
; 
;  ;; Function-Decl crate::pervasive::invariant::LocalInvariant::namespace
;  (declare-fun pervasive.invariant.LocalInvariant.namespace.? (Type Poly) Int)
; 
;  ;; Function-Axioms crate::lib::mul_distributive
;  (declare-fun ens%lib.mul_distributive. (Int Int) Bool)
;  (axiom (forall ((a@ Int) (b@ Int)) (!
;     (= (ens%lib.mul_distributive. a@ b@) (= (nClip (* (nClip (+ a@ 1)) b@)) (nClip (+ (nClip
;          (* a@ b@)
;         ) b@
;     ))))
;     :pattern ((ens%lib.mul_distributive. a@ b@))
;  )))
(pop)
